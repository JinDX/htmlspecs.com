<!DOCTYPE html>
<html>

<head>
    <title>Web NFC</title>
    <meta charset="UTF-8">
    <link rel="icon" type="image/png" href="https://w3c.github.io/web-nfc/images/webnfc-favicon-simple.png">
    <script type="module" src="https://w3c.github.io/web-nfc/ndef-record.js"></script>
    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' async class='remove'></script>
    <script class="remove">
        var respecConfig = {
            shortName: "web-nfc",
            group: "cg/web-nfc",
            specStatus: "CG-DRAFT",
            editors: [
                {
                    name: "Kenneth Rohde Christiansen",
                    company: "Intel",
                    companyURL: "https://intel.com/",
                },
                {
                    name: "Zoltan Kis",
                    company: "Intel",
                    companyURL: "https://intel.com/"
                },
                {
                    name: "François Beaufort",
                    company: "Google LLC",
                    companyURL: "https://google.com/"
                },
            ],
            formerEditors: [
                {
                    name: "Alexander Shalamov",
                    company: "Intel",
                    companyURL: "https://intel.com/",
                },
            ],
            logos: [
                {
                    src: 'https://w3c.github.io/web-nfc/images/webnfc-logo.svg',
                    url: "https://w3c.github.io/web-nfc/",
                    alt: "Web NFC logo",
                    width: 95,
                    height: 68,
                    id: 'webnfc-logo'
                }
            ],
            testSuiteURI: "https://wpt.fyi/web-nfc/",
            github: "w3c/web-nfc",
            xref: "web-platform",
            localBiblio: {
                "NFC-SECURITY": {
                    href: "https://w3c.github.io/web-nfc/archive/security-privacy.html",
                    title: "Web NFC Security and Privacy",
                    publisher: "W3C",
                    date: "25 April 2015",
                },
                "NFC-USECASES": {
                    href: "https://w3c.github.io/web-nfc/use-cases.html",
                    title: "Web NFC Use Cases",
                    publisher: "W3C",
                    date: "25 April 2015",
                },
                "NFC-STANDARDS": {
                    href: "http://members.nfc-forum.org/specs/spec_list/",
                    title: "NFC Forum Technical Specifications",
                    publisher: "NFC Forum",
                    date: "24 July 2006",
                },
                "NFC-NDEF": {
                    href: "http://members.nfc-forum.org/specs/spec_list/",
                    title: "NFC Data Exchange Format (NDEF) Technical Specification",
                    publisher: "NFC Forum",
                    date: "24 July 2006",
                },
                "NFC-RTD": {
                    href: "http://members.nfc-forum.org/specs/spec_list/",
                    title: "NFC Record Type Definition (RTD) Technical Specification",
                    publisher: "NFC Forum",
                    date: "24 July 2006",
                },
                "NDEF-TEXT": {
                    href: "http://members.nfc-forum.org/specs/spec_list/",
                    title: "NFC Forum Text Record Type Definition",
                    publisher: "NFC Forum",
                    date: "14 August 2013",
                },
                "NDEF-URI": {
                    href: "http://members.nfc-forum.org/specs/spec_list/",
                    title: "NFC Forum URI Record Type Definition",
                    publisher: "NFC Forum",
                    date: "24 July 2006",
                },
                "NDEF-SMARTPOSTER": {
                    href: "http://members.nfc-forum.org/specs/spec_list/",
                    title: "NFC Forum Smart Poster Record Type Definition",
                    publisher: "NFC Forum",
                    date: "24 July 2006",
                },
                "NDEF-SIGNATURE": {
                    href: "http://members.nfc-forum.org/specs/spec_list/",
                    title: "NFC Forum Signature Record Type Definition",
                    publisher: "NFC Forum",
                    date: "18 November 2010",
                },
                "NFC-HANDOVER": {
                    href: "http://members.nfc-forum.org/specs/spec_list/",
                    title: "NFC Forum Connection Handover Technical Specification",
                    publisher: "NFC Forum",
                    date: "16 January 2014",
                },
                "ISO-639.2": {
                    href: "https://www.loc.gov/standards/iso639-2/php/code_list.php",
                    title: "Codes for the Representation of Names of Languages",
                    publisher: "ISO",
                    date: "18 March 2014",
                },
            },
            lint: { "no-unused-dfns": false },
        };
    </script>
    <style>
        table.simple {
            border: 1px solid #000;
        }

        table.simple td {
            border-right: 1px solid #000;
        }

        img.illustration {
            width: 100%;
            height: auto
        }

        body {
            background-repeat: no-repeat !important;
        }
    </style>
</head>

<body data-cite="MIMESNIFF SECURE-CONTEXTS PERMISSIONS ENCODING">

    <!-- - - - - - - - - - - - - - - - Abstract - - - - - - - - - - - - - - - - -->
    <section id="abstract">
        <p>
            近场通信（NFC）使两个设备在近距离内（通常少于几厘米）进行无线通信成为可能。
            NFC 是一项国际标准（ISO/IEC 18092），定义了在 13.56 MHz 工作的紧密耦合设备之间用于简单无线互联的接口和协议。
        </p>
        <p>
            硬件标准在 [[[NFC-STANDARDS]]] 中定义。
        </p>
        <p>
            本文档定义了基于 NFC 技术启用若干选定用例的 API。本规范当前的范围是 <a>NDEF</a>。
        </p>
        <p class="advisement">
            低级别 I/O 操作（例如 ISO-DEP、NFC-A/B、NFC-F）以及基于主机的卡模拟（HCE）在当前范围内 <b>不</b>受支持。
        </p>
    </section>

    <!-- - - - - - - - - - - - Status of this document  - - - - - - - - - - - - -->
    <section id="sotd">
        <p>
            实现者需要注意，本规范被视为不稳定。
            不参与讨论的实现者会发现规范会以不兼容的方式不断变化。希望在规范最终进入候选推荐阶段之前实现本规范的厂商，应订阅 GitHub 上的仓库并参与讨论。
        </p>
    </section>

    <!-- - - - - - - - - - - - Conformance  - - - - - - - - - - - - - - - -->
    <section id="conformance">
        <p>
            本文档定义了适用于单一产品的符合性标准：实现其所包含接口的 <dfn>UA</dfn>（用户代理）。
        </p>
    </section>

    <!-- - - - - - - - - - - -  Introduction  - - - - - - - - - - - - - - -->
    <section class="informative">
        <h2>引言</h2>
        <p>
            Web NFC 的用户场景如下：将设备保持在被动供电的 NFC 标签（例如塑料卡或贴纸）近旁，以读取和/或写入数据。
        </p>
        <p>
            NFC 使用磁感应工作，这意味着读取器（一个有源、有电的设备）会发出微小电荷，从而产生磁场。
            该磁场为被动设备供电，被动设备将其转换为电信号以传输数据。因此，当设备处于有效范围内时，会始终进行读取（参见 NFC Analog Specification 和 NFC Digital Protocol，NFC
            Forum，2006）。
            对等连接的工作方式类似，设备会周期性地切换到所谓的发起器模式以扫描目标，然后再切换回目标模式。如果找到目标，则以与标签相同的方式读取数据。
        </p>
        <p>
            由于 NFC 基于现有的 RFID 标准，许多 NFC 芯片组支持读取 RFID 标签，但其中有些仅由单一厂商支持，并非 NFC 标准的一部分。因此，本文件规定了与 NFC 数据交换格式（NDEF）交互的方法。
        </p>
    </section> <!-- Introduction -->

    <!-- - - - - - - - - - - - - - -  Terminology - - - - - - - - - - - - - - - -->
    <section>
        <h2>术语和约定</h2>
        <p>
            使用的扩充巴科斯-诺尔范式（ABNF）表示法在 [[RFC5234]] 中规定。
        </p>
        <p>
            <b>NFC</b> 表示近场通信，一种在 13.56 MHz 工作的短距离无线技术，使设备在小于 10 cm 的距离内进行通信。NFC 通信协议和数据交换格式基于现有的射频识别（RFID）标准，包括 ISO/IEC
            14443 和 FeliCa。
            NFC 标准包括 ISO/IEC 18092[5] 以及 NFC Forum 定义的标准。完整列表请参见 <a href="https://www.nfc-forum.org/specs/spec_list/">
                NFC Forum 技术规范</a>。
        </p>
        <p>
            <dfn>NFC adapter</dfn> 是底层平台中的软件实体，提供对在给定硬件组件（NFC 芯片）中实现的 NFC 功能的访问。设备可能有多个 NFC 适配器，例如内置的一个，或者通过 USB
            连接的一个或多个。
        </p>
        <div>
            <dfn>NFC tag</dfn> 是一个被动的 NFC 设备，且未被 <a>blocklisted</a>。当有源 NFC 设备在近旁时，<a>NFC tag</a> 由磁感应供电。支持 <a>NDEF</a>
            的 <a>NFC tag</a> 包含单个 <a>NDEF message</a>。
            <p class="note">
                读取消息的方式可能通过专有技术发生，这些技术要求读取器和标签来自相同厂商。它们也可能暴露一个 <a>NDEF</a> 消息。
            </p>
        </div>
        <div>
            <dfn>NFC peer</dfn> 是一个有源、有电的设备，可以与其他设备交互以使用 NFC 交换数据。
            <p class="issue" data-number="529">
                如当前规范所述，点对点（peer-to-peer）不被支持。
            </p>
        </div>
        <p>
            <dfn>NFC device</dfn> 是 <a>NFC peer</a> 或 <a>NFC tag</a>。
        </p>
        <p>
            <dfn>NDEF</dfn> 是 NFC Forum 数据交换格式（NFC Forum Data Exchange Format）的缩写，一种在 [[!NFC-NDEF]] 中标准化的轻量二进制消息格式。
        </p>
        <p>
            <dfn>NDEF message</dfn> 封装一个或多个应用定义的 <a>NDEF record</a>。NDEF 消息可以存储在 <a>NFC tag</a> 上或在启用 NFC 的设备之间交换。
        </p>
        <p>
            术语 <dfn>NFC content</dfn> 表示发送到或从 <a>NFC tag</a> 接收的所有字节。在当前 API 中，它与 <a>NDEF message</a> 同义。
        </p>
    </section> <!-- Terminology -->


    <section class="informative">
        <h2>NFC 标准</h2>
        <p>
            NFC 在 NFC Forum 中被标准化，并在 [[NFC-STANDARDS]] 中描述。
        </p>
        <section class="informative">
            <h3>NDEF 兼容标签类型</h3>
            <p>
                NFC Forum 已规定支持五种不同的标签类型以便与 NFC 设备一起操作。操作系统（如 Android）也要求同样的支持。
            </p>
            <p>
                除此之外，<a>MIFARE Standard</a> 指定了一种在较旧的 <a>MIFARE Standard</a> 之上使 NDEF 工作的方式，实施者可选择性地支持该方式。
            </p>
            <p>
                关于 NDEF 映射的说明可以在此找到：
                <a href="https://www.nxp.com/docs/en/application-note/AN1305.pdf">
                    MIFARE Classic 作为 NFC 类型 MIFARE Classic 标签</a>。
            </p>
            <div>
                <ol>
                    <li>
                        <dfn>NFC Forum Type 1</dfn>：该标签基于 ISO/IEC 14443-3A（NFC-A）。标签可重写并可配置为只读。内存大小可在 `96` 字节到 `2`
                        Kbytes 之间。通信速度为 `106` kbit/s。与所有其他类型相比，此类标签没有用于处理多个标签同时处于 NFC 场中的防冲突保护。
                    </li>
                    <li>
                        <dfn>NFC Forum Type 2</dfn>：该标签基于 ISO/IEC 14443-3A（NFC-A）。标签可重写并可配置为只读。内存大小可在 `48` 字节到 `2`
                        Kbytes 之间。通信速度为 `106` kbit/s。
                    </li>
                    <li>
                        <dfn>NFC Forum Type 3</dfn>：该标签基于日本工业标准（JIS）X 6319-4（ISO/IEC 18092），通常称为 FeliCa。标签预配置为可重写或只读。内存为
                        `2` kbytes。通信速度为 `212` kbit/s 或 `424` kbit/s。
                    </li>
                    <li>
                        <dfn>NFC Forum Type 4</dfn>：该标签基于 ISO/IEC 14443-4 A/B（NFC A、NFC B），因此支持 NFC-A 或 NFC-B
                        进行通信。此外，标签可以可选地支持 ISO-DEP（ISO/IEC 14443 中定义的数据交换协议（ISO/IEC 14443-4:2008
                        第4部分：传输协议））。标签预配置为可重写或只读。可变内存，最高可达 `32` kbytes。支持三种不同的通信速度：`106`、`212` 或 `424` kbit/s。
                    </li>
                    <li>
                        <dfn>NFC Forum Type 5</dfn>：该标签基于 ISO/IEC 15693（NFC-V），允许在 ISO/IEC 15693 RF 标签上读取和写入 NDEF
                        消息，该标签也可被长距离 RFID 读取器访问。NFC 通信限于短距离，可能使用 ISO/IEC 18092 的主动通信模式（Active Communication
                        Mode），在该模式下发送方生成场，以平衡功耗并提高链路稳定性。可变内存，最高可达 `64` kbytes。通信速度为 `26.48` kbit/s。
                    </li>
                    <li>
                        <dfn>MIFARE Standard</dfn>：该标签通常以 MIFARE Classic 或 MIFARE Mini 等品牌出售，基于 ISO/IEC 14443-3A（亦称为
                        NFC-A，定义于 ISO/IEC 14443-3:2011 第3部分：初始化和防冲突）。标签可重写并可配置为只读。内存大小可在 `320` 到 `4` kbytes 之间。通信速度为
                        `106` kbit/s。
                        <p class="note">
                            <a>MIFARE Standard</a> 不是 NFC Forum 类型，只能被使用 NXP 硬件的设备读取。对基于 <a>MIFARE Standard</a>
                            的标签进行读写的支持因此不是命名性支持，但由于其在传统系统中的流行性和使用而被包含在内。
                        </p>
                    </li>
                </ol>
            </div>
            <p>
                除了 NFC Forum 为 <a>NDEF record</a> 标准化的数据类型外，许多商业产品（例如公交卡、门禁卡）可能基于 <a>MIFARE Standard</a>，其依赖特定的 NFC
                芯片（卡和读取器来自相同厂商）才能工作。
            </p>
        </section>

        <section>
            <h3>
                NDEF 记录和字段
            </h3>
            <p>
                <dfn>NDEF record</dfn> 是 <a>NDEF message</a>
                的一部分。每个记录都是包含数据有效载荷及相关类型信息的二进制结构。此外，它还包含有关数据结构的信息，例如有效载荷大小、数据是否在多个记录之间分片等。
            </p>
            <div>
                通用记录如下所示：
                <ndef-record class="ndef" header="*,*,*,*,*,*"
                    content="*,PAYLOAD LENGTH - 1 (SR) to 4 bytes,ID LENGTH (optional),TYPE (optional),ID (optional),PAYLOAD (optional)">
                </ndef-record>
            </div>
            <p>
                只有前三个字节（图中行）是强制性的。首先是头字节，其次是 <a>TYPE LENGTH field</a> 和 <a>PAYLOAD LENGTH field</a>，二者都可以为零。
            </p>
            <div>
                <dfn>TNF field</dfn>（位 `0-2`，类型名格式）指示类型名的格式，通常由本地 NFC 软件栈暴露。该字段可以取二进制值，表示以下 NDEF 记录有效载荷类型：
                <table class="simple">
                    <tr>
                        <th><strong>TNF 值</strong></th>
                        <th><strong>描述</strong></th>
                    </tr>
                    <tr>
                        <td>0</td>
                        <td><a>空记录</a></td>
                    </tr>
                    <tr>
                        <td>1</td>
                        <td>NFC Forum [=well-known type record=]</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td><a>MIME type record</a></td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td><a>Absolute-URL record</a></td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>NFC Forum <a>external type record</a></td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td><a>Unknown record</a></td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td><a>Unchanged record</a></td>
                    </tr>
                    <tr>
                        <td>7</td>
                        <td>预留用于将来使用</td>
                    </tr>
                </table>
            </div>
            <p>
                <dfn>IL field</dfn>（位 `3`，ID 长度）指示是否存在 <a>ID LENGTH field</a>。如果 <a>IL field</a> 为 `0`，则 <a>ID field</a>
                也不存在。
            </p>
            <p>
                <dfn>SR field</dfn>（位 `4`，短记录）指示短记录，其有效载荷长度 <= `255` 字节。普通记录的有效载荷长度可以超过 `255` 字节，最大可达 `4`
                    GB。短记录只使用一个字节指示长度，而普通记录使用 `4` 字节（`2`<sup>`32`</sup>`-1` 字节）。
            </p>
            <p>
                <dfn>CF field</dfn>（位 `5`，分片标志）指示有效载荷是否在多个记录之间被 <a>chunked</a>（分片）。
            </p>
            <p class="note">
                Web NFC 会将所有接收到的分片记录转换为逻辑记录，并在需要时透明地对发送的有效载荷进行分片。
            </p>
            <p>
                <dfn>ME field</dfn>（位 `6`，消息结束）指示该记录是否为 <a>NDEF message</a> 中的最后一个记录。
            </p>
            <p>
                <dfn>MB field</dfn>（位 `7`，消息开始）指示该记录是否为 <a>NDEF message</a> 的第一个记录。
            </p>
            <p>
                <dfn>TYPE LENGTH field</dfn> 是一个无符号 8 位整数，表示 <a>TYPE field</a> 的字节大小。
            </p>
            <p>
                <dfn>TYPE field</dfn> 是一个全局唯一且维护的标识符，用以描述 <a>PAYLOAD field</a> 的类型，其结构、编码和格式由 <a>TNF field</a> 的值决定。
            </p>
            <p class="note">
                [[[!NFC-RTD]]] 要求 <a>TYPE field</a> 的名称比较必须以不区分大小写的方式进行。
            </p>
            <p>
                <dfn>ID LENGTH field</dfn> 是一个无符号 8 位整数，表示 <a>ID field</a> 的字节大小。
            </p>
            <p>
                <dfn>ID field</dfn> 是以 URI 引用 ([[RFC3986]]) 形式的标识符，具有唯一性，可以是绝对或相对的（在后者情况下，应用必须提供基 URI）。中间和终止的分片记录必须不具有
                <a>ID field</a>，其他记录可以具有该字段。
            </p>
            <p>
                <dfn>PAYLOAD LENGTH field</dfn> 表示 <a>PAYLOAD field</a> 的字节大小。如果 <a>SR field</a> 为 `1`，则其大小为 1 字节，否则为 4
                字节，分别表示 8 位或 32 位无符号整数。
            </p>
            <p>
                <dfn>PAYLOAD field</dfn> 承载应用字节。NDEF 对数据的任何内部结构保持不透明。注意在后文讨论的某些情况下，该字段可以包含作为数据的 <a>NDEF message</a>。
            </p>
        </section>

        <section>
            <h3>
                NDEF 记录类型
            </h3>
            <section>
                <h4>空 NDEF 记录（TNF 0）</h4>
                <p>
                    <dfn>空记录</dfn> 的 <a>TYPE LENGTH field</a>、<a>ID LENGTH field</a> 和 <a>PAYLOAD LENGTH field</a> 必须为
                    `0`，因此 <a>TYPE field</a>、<a>ID field</a> 和 <a>PAYLOAD field</a> 不得存在。
                </p>
                <ndef-record header="1,1,0,1,0,0 (EMPTY)" content="0,0,_,_,_,_" short>
                </ndef-record>
            </section>

            <section>
                <h4>
                    规范类型记录（TNF 1）
                </h4>
                <p>
                    NFC Forum 在 [[NFC-RTD]]（资源类型定义规范）中标准化了一些有用的子记录类型，称为
                    <dfn>规范类型记录</dfn>，例如文本、URL、媒体等。此外，还有为更复杂交互设计的记录类型，如智能海报（包含用于 url、text、signature 和 actions
                    的可选嵌入记录）和交接（handover）记录。
                </p>
                <p>
                    存储在 <a>TYPE field</a> 的 <a>规范类型记录</a> 的类型信息可以有两种：
                    <a href="#well-known-local-types">本地类型</a>
                    和 <a href="#well-known-global-types">全局类型</a>。
                </p>

                <section>
                    <h4>规范本地类型</h4>
                    <p>
                        NFC Forum 的 <dfn>本地类型</dfn> 由 NFC Forum
                        或应用定义，并且总是以小写字母或数字开头。这些通常是简短字符串，仅在包含记录的本地上下文中唯一。当类型含义在包含记录的本地上下文之外不重要且存储使用是硬性约束时使用本地类型。有关如何使用本地类型的示例，请参见
                        <a>Smart poster</a>。
                    </p>
                    <p class="note">
                        因此，[=local type=] 是根据包含记录类型定义的，因此不需要任何命名空间。基于此，相同的本地类型名称可以在另一个记录类型中以不同含义和不同有效载荷类型重复使用。
                    </p>
                </section>
            </section> <!-- Well-known (TNF 1) types -->

            <section>
                <h4>规范全局类型</h4>
                <p>
                    NFC Forum 的 <dfn>全局类型</dfn> 由 NFC Forum 定义和管理，通常以大写字母开头。
                    示例："`T`" 表示文本，"`U`" 表示 URL，"`Sp`" 表示智能海报，"`Sig`" 表示签名，"`Hc`" 表示交接载体，"`Hr`" 表示交接请求，"`Hs`" 表示交接选择，等等。
                </p>

                <section>
                    <h5>文本记录</h5>
                    <div>
                        <dfn>文本记录</dfn> 是在 [[NDEF-TEXT]] 规范中定义的 [=规范类型记录=]。
                        <a>TNF field</a> 为 `1`，<a>TYPE field</a> 为 "`T`"（`0x54`）。
                        <a>PAYLOAD field</a> 的第一个字节是状态字节，后跟以 US-ASCII 编码的 [=language tag=]。
                        剩余的有效载荷是实际文本，按状态字节所指示以 UTF-8 或 UTF-16 编码，如下所示：
                        <ul>
                            <li>位 0 到 5 定义 [=language tag=] 的长度。</li>
                            <li>位 6 为 `0`。</li>
                            <li>
                                如果位 7 为 `0`，表示有效载荷以 UTF-8 编码，否则若位 7 为 `1` 则以 UTF-16 编码。
                            </li>
                        </ul>
                    </div>
                </section>

                <section>
                    <h5>URI 记录</h5>
                    <p>
                        <dfn>URI 记录</dfn> 在 [[NDEF-URI]] 中定义。
                        <a>TNF field</a> 为 `1`，<a>TYPE field</a> 为 "`U`"（`0x55`）。
                        <a>PAYLOAD field</a> 的第一个字节是 URI 标识符代码，实际上是缩写表中的索引，其值会预先加入到 URI 的其余部分。例如，值 `0` 表示不添加前缀，`1` 表示
                        "`http://www.`"，`0x04` 表示 "`https://`" 等等。
                        有效载荷的其余部分包含作为 UTF-8 字符串的 URI 的其余部分（如果第一个字节为 `0`，则表示整个 URI）。
                    </p>
                    <p>
                        该 URI 在 [[RFC3987]] 中定义，实际上是一个 UTF-8 编码的 IRI，可以是 URN 或 URL。
                    </p>
                </section>

                <section>
                    <h5>智能海报记录</h5>
                    <div>
                        <dfn>智能海报</dfn> 在 [[NDEF-SMARTPOSTER]] 中定义，用于将给定的 Web 内容描述为包含一个 <a>NDEF message</a> 作为有效载荷的 NDEF
                        记录，该消息包含以下记录：
                        <ul>
                            <li>
                                一个单一的强制性 <a>URI record</a>，指向 <a>smart poster</a> 内容。
                                <p class="note">
                                    [[NDEF-SMARTPOSTER]] 规定，当 <a>NDEF message</a> 中存在 <a>smart poster</a> 记录且该消息中还包含其他
                                    <a>URI records</a> 时，应用程序应该仅使用该 <a>smart poster</a> 记录。
                                </p>
                            </li>
                            <li>
                                零个或多个 <a>Text records</a>，作为与内容相关的 <dfn>title record</dfn>。当存在多个标题记录时，它们必须具有不同的
                                <a>language tags</a>。应用程序应选择一个 <a>title record</a> 向终端用户展示。
                            </li>
                            <li>
                                零个或多个 <a>MIME type records</a>，作为与内容相关的 <dfn>icon record</dfn>。<a>MIME type</a> 通常为
                                "`image/jpg`"、"`image/png`"、"`image/gif`" 或甚至 "`video/mpeg`"。应用程序应选择一个 <a>icon
                                    record</a> 向终端用户展示。
                            </li>
                            <li>
                                一个可选的 <dfn>type record</dfn>，其具有特定于 <a>smart poster</a> 的 [=local type name=] "`t`"，并且
                                <a>PAYLOAD field</a> 包含指向 <a>URI record</a> 所引用内容的 UTF-8 编码 MIME 类型。
                            </li>
                            <li>
                                一个可选的 <dfn>size record</dfn>，其具有特定于 <a>smart poster</a> 的 [=local type name=] "`s`"，并且
                                <a>PAYLOAD field</a> 包含一个 4 字节的 32 位无符号整数，表示 <a>smart poster</a> 中 <a>URI record</a> 所引用
                                URL 的对象大小。
                            </li>
                            <li>
                                一个可选的 <dfn>action record</dfn>，其具有特定于 <a>smart poster</a> 的 [=local type name=]
                                "`act`"，并且 <a>PAYLOAD field</a> 包含单个字节，其值含义如下：
                                <table class="simple">
                                    <tr>
                                        <th><strong>值</strong></th>
                                        <th><strong>描述</strong></th>
                                    </tr>
                                    <tr>
                                        <td>0</td>
                                        <td>执行该动作</td>
                                    </tr>
                                    <tr>
                                        <td>1</td>
                                        <td>稍后保存</td>
                                    </tr>
                                    <tr>
                                        <td>2</td>
                                        <td>打开以供编辑</td>
                                    </tr>
                                    <tr>
                                        <td>3..0xFF</td>
                                        <td>预留用于将来使用</td>
                                    </tr>
                                </table>
                                如果 <a>action record</a> 缺失，则 <a>smart poster</a> 内容没有默认动作。
                                <p class="note">
                                    在 NDEF 标准化时，值 `0`（“执行该动作”）原本用于诸如发送 SMS、拨打电话或启动浏览器等用例。类似地，值 `1`（“稍后保存”）用于诸如将 SMS
                                    存入收件箱、将 URL 保存到书签或将电话号码保存到联系人等用例。此外，值 `2`（“打开以供编辑”）旨在使用默认应用打开智能海报内容以进行编辑。
                                </p>
                                <p>
                                    实现不需要对此处定义的动作实现任何标准化行为。在此 API 中，由应用决定其定义的动作（可能包括上述用例）。Web NFC 仅提供这些值。
                                </p>
                            </li>
                            <li>
                                <a>smart poster</a> 还可以包含其他记录，这些记录可以由应用以特定方式处理。
                            </li>
                        </ul>
                    </div>

                    <div>
                        下面的示例显示了一个嵌入了文本和 URL 记录的智能海报记录。
                        <ndef-record header="1,1,0,1,0,1 (WELL KNOWN)" content="*,*,_,'Sp' (0x53 0x70),_,*" short>
                            <ndef-record slot="payload" header="1,0,0,1,0,1 (WELL KNOWN)"
                                content="TYPE LENGTH (1 byte),*,_,'T' (0x54),_,*" short noindices>
                            </ndef-record>
                            <ndef-record slot="payload" header="0,1,0,1,0,1 (WELL KNOWN)"
                                content="TYPE LENGTH (1 byte),*,_,'U' (0x55),_,*" short noindices>
                            </ndef-record>
                        </ndef-record>
                    </div>
                </section>

                <section>
                    <h5>签名记录</h5>
                    <p>
                        <dfn>NDEF Signature</dfn> 在 [[NDEF-SIGNATURE]] 中定义。
                        其 <a>TYPE field</a> 包含 "`Sig`"（`0x53`, `0x69`, `0x67`），其 <a>PAYLOAD field</a> 包含版本、签名和证书链。
                    </p>
                    <p class="issue" data-number="363">
                        如当前规范所述，该项不被支持。
                    </p>
                </section>

                <section>
                    <h5>交接（Handover）记录</h5>
                    <p>
                        <dfn>NFC handover</dfn> 在 [[NFC-HANDOVER]] 中定义，对应的消息结构允许协商并激活备用通信载体，例如蓝牙或
                        WiFi。随后协商出的通信载体将被（单独地）用于在两个设备之间执行某些活动，例如向另一设备发送照片、向蓝牙打印机打印或向电视流式传输视频。
                    </p>
                    <p class="issue" data-number="364">
                        如当前规范所述，该项不被支持。
                    </p>
                </section>
            </section> <!-- well-known global types -->

            <section>
                <h4>
                    MIME 类型记录（TNF 2）
                </h4>
                <div>
                    <dfn>MIME type record</dfn> 是存储二进制数据并带有关联 <a>MIME type</a> 的记录。
                    <ndef-record header="*,*,*,*,*,2 (MIME)" content="*,*,*,SERIALIZED MIME TYPE,*,MIME TYPE PAYLOAD"
                        short>
                    </ndef-record>
                </div>
            </section>

            <section>
                <h4>
                    绝对 URL 记录（TNF 3）
                </h4>
                <p>
                    在 <dfn>绝对 URL 记录</dfn> 中，<a>TYPE field</a> 包含 <a>绝对 URL 字符串</a>，而不是有效载荷。
                </p>
                <p class=note>
                    注意：某些平台（如 Windows Phone）在有效载荷中存储了额外的数据，但这些记录中的任何有效载荷数据在其他平台（如 Android）上会被忽略。在 Android 上读取此类记录时，会尝试在
                    Chrome 中加载该 URL，因此并不打算供客户端应用使用。
                </p>
                <div>
                    <ndef-record header="*,*,*,*,*,3 (ABSOLUTE URL)"
                        content="*,*,*,ABSOLUTE URL STRING,*,PAYLOAD (optional/ignored)" short>
                    </ndef-record>
                </div>
            </section>

            <section>
                <h4>
                    外部类型记录（TNF 4）
                </h4>
                <p>
                    NFC Forum 的 <dfn data-no-export="">外部类型记录</dfn> 用于应用指定的数据类型，并在 [[[NFC-RTD]]] 中定义。
                </p>
                <p>
                    <dfn>外部类型</dfn> 是以前缀 `"urn:nfc:ext:"` 开头的 URN，后跟所有者的名称 [=domain=]，再添加一个 `U+003A`（`:`），然后是非零的类型名，例如
                    `"urn:nfc:ext:w3.org:atype"`，在 <a>TYPE field</a> 中存储为 `"w3.org:atype"`。
                </p>
                <div>
                    <ndef-record header="*,*,*,*,*,4 (EXTERNAL)" content="*,*,*,EXTERNAL TYPE (eg. w3.org:member),*,*"
                        short>
                    </ndef-record>
                </div>
            </section>

            <section>
                <h4>
                    未知类型记录（TNF 5）
                </h4>
                <p>
                    <dfn>未知记录</dfn> 是存储不带关联 <a>MIME type</a> 的不透明数据的记录，这意味着可以假定默认的 `application/octet-stream` <a>MIME
                        type</a>。[[NFC-NDEF]] 规范建议 <a>NDEF</a> 解析器将有效载荷存储或转发而不进行处理。
                </p>
                <div>
                    <ndef-record header="*,*,*,*,*,5 (UNKNOWN)" content="0,*,*,_,*,*" short>
                    </ndef-record>
                </div>
            </section>
            <section>
                <h4>
                    未更改类型记录（TNF 6）
                </h4>
                <div>
                    <dfn>未更改记录</dfn> 是分片数据集的记录分片，用于除第一条记录之外的任何记录。
                    <dfn>分片</dfn> 的有效载荷分布在多个 <a>NDEF record</a> 中，并遵循以下规则：
                    <ul>
                        <li>
                            初始分片记录设置了 <a>CF field</a>，其 <a>TYPE field</a> 设置为整个分片有效载荷的类型，其 <a>ID field</a>
                            可选地设置为用于整个分片有效载荷的标识符。其 <a>PAYLOAD LENGTH field</a> 表示本记录中该分片的大小。
                        </li>
                        <li>
                            中间分片记录设置了 <a>CF field</a>，具有与第一分片相同的 <a>ID field</a>，其 <a>TYPE LENGTH field</a> 和 <a>IL
                                field</a> 必须为 `0`，其 <a>TNF field</a> 必须为 `6`（未更改）。
                        </li>
                        <li>
                            终止分片记录清除了该标志，其余规则与中间分片记录相同。
                        </li>
                        <li>
                            一个分片有效载荷必须包含在单个 <a>NDEF message</a> 中，因此初始和中间分片记录不能设置 <a>ME field</a>。
                        </li>
                    </ul>
                </div>
                <div>
                    第一条记录：
                    <ndef-record header="1,0,1,1,0,*" content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*" short>
                    </ndef-record>
                    <br>
                    中间记录：
                    <ndef-record header="0,0,1,1,0,6 (UNCHANGED)" content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*"
                        short>
                    </ndef-record>
                    <br>
                    最后一条记录：
                    <ndef-record header="0,1,0,1,0,6 (UNCHANGED)" content="0,PAYLOAD LENGTH FOR THIS RECORD,_,_,_,*"
                        short>
                    </ndef-record>
                </div>
                <p>
                    Web NFC 的任何实现必须将分片记录透明地呈现为单个逻辑记录。
                </p>
            </section>
        </section>
    </section> <!-- NFC Standard -->

    <section class="informative">
        <h3>用例</h3>
        <p>
            已经在
            <a
                href="http://www.w3.org/2009/dap/wiki/Near_field_communications_%28NFC%29#Use_cases_submitted_to_DAP_mailing_list">
                此处</a> 和
            <a href="https://w3c.github.io/web-nfc/use-cases.html">Web NFC 用例</a>
            文档中枚举了一些 NFC 用户场景。基本的 Web NFC 交互如下。
        </p>

        <section>
            <h3>读取一个 <a>NFC tag</a></h3>
            <p>
                在使用 Web NFC 的 <a>top-level browsing context</a> 的 {{Document}} 可见时，
                读取包含 <a>NDEF message</a> 的 <a>NFC tag</a>。例如，网页指示用户触碰 NFC 标签，然后从标签接收信息。
            </p>
        </section>

        <section>
            <h3>向 <a>NFC tag</a> 写入</h3>
            <div>
                用户打开一个可以向 <a>NFC tag</a> 写入的网页。写入操作可能为下列之一：
                <ol>
                    <li>
                        向未格式化的 <a>NFC tag</a> 写入。
                    </li>
                    <li>
                        向空但已格式化的 <a>NFC tag</a> 写入。
                    </li>
                    <li>
                        向已包含 <a>NDEF message</a> 的 <a>NFC tag</a> 写入。
                    </li>
                    <li>
                        向其他可写的 <a>NFC tag</a> 写入（即覆盖通用标签）。
                    </li>
                </ol>
            </div>
            <p class="note">
                注意，对 <a>NFC tag</a> 的 NFC 写入操作总是同时涉及一次读取操作。
            </p>
        </section>

        <section>
            <h3>将 <a>NFC tag</a> 设为只读</h3>
            <div>
                用户打开一个可以将 <a>NFC tag</a> 永久设为只读的网页。操作可能为下列之一：
                <ol>
                    <li>
                        将未格式化的 <a>NFC tag</a> 永久设为只读。
                    </li>
                    <li>
                        将空但已格式化的 <a>NFC tag</a> 永久设为只读。
                    </li>
                    <li>
                        将已包含 <a>NDEF message</a> 的 <a>NFC tag</a> 永久设为只读。
                    </li>
                </ol>
            </div>
            <p class="note">
                注意，将 <a>NFC tag</a> 永久设为只读总是涉及一次读取操作。
            </p>
        </section>

        <section>
            <h3>支持多个 NFC 适配器</h3>
            <p>
                除了内置适配器外，用户可能为其设备附加一个或多个外部 <a>NFC adapter</a>。用户可以使用任意一个 <a>NFC adapter</a>。
            </p>
        </section>
    </section> <!-- Use Cases -->

    <section class="informative">
        <h3>功能</h3>
        <div>
            Web NFC 规范的高级功能包括以下内容：
            <ol>
                <li>
                    支持具有单个或多个 <a>NFC adapter</a> 的设备。
                    如果在调用 NFC 功能时存在多个适配器，则 UA 会并行操作所有 <a>NFC adapter</a>。
                </li>
                <li>
                    支持与被动（智能卡、标签等） NFC 设备的通信。
                </li>
                <li>
                    允许用户对被发现的被动 NFC 设备执行操作（例如读取、写入或收发），并访问在过程中读取到的作为 <a>NDEF message</a> 的有效载荷。
                </li>
                <li>
                    当兼容设备（例如可写标签）进入范围时，允许用户通过 <a>NDEF record</a> 将有效载荷写入这些设备，作为 <a>NDEF message</a>。
                </li>
            </ol>
        </div>
    </section> <!-- Features -->

    <!-- - - - - - - - - - - - - - Usage Examples - - - - - - - - - - - - - - -->
    <section class="informative">
        <h2>示例</h2>
        <p>
            本节展示开发者如何使用本规范的各项功能。
        </p>

        <section>
            <h3>功能支持</h3>
            <p>
                检测是否支持 Web NFC 可以通过检查 {{NDEFReader}} 对象来完成。注意，这并不保证 NFC 硬件可用。
            </p>
            <pre class="example">
      if ("NDEFReader" in window) { /* Scan and write NDEF Tags */ }
    </pre>
        </section>

        <section>
            <h3>关于写入数据的一般信息</h3>
            <p>
                写入数据通常很直接，但在 NFC 写入工作方式上有一些需要注意的地方。
            </p>
            <p>
                NFC 读取器通过轮询工作，因此为了能够写入标签或将其永久设为只读，需要先找到并读取标签，这意味着需要首先初始化轮询。
            </p>
            <p>
                如果尚未通过先调用 `scan()` 启动轮询，则 `write()` 和 `makeReadOnly()` 方法会临时启动轮询，直到找到并读取到标签并尝试执行操作为止。
            </p>
            <p>
                这意味着流程是先在首次找到标签时执行一次读取，然后再执行写入操作。
            </p>
            <p>
                这也意味着如果 `scan()` 正在运行且你为 `reading` 事件添加了事件监听器，那么在 `write()` 或 `makeReadOnly()`
                操作期间该事件监听器会被触发一次，这可能不是预期的行为。
            </p>
            <p>
                在接下来的各节中，我们将讨论如何轻松处理此行为，但先给出几个简单示例。
            </p>
        </section>

        <section>
            <h3>写入文本字符串</h3>
            <p>
                向 NFC 标签写入文本字符串很简单。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      ndef.write(
        "Hello World"
      ).then(() => {
        console.log("Message written.");
      }).catch(error => {
        console.log(`Write failed :-( try again: ${error}.`);
      });
    </pre>
        </section>

        <section>
            <h3>写入 URL</h3>
            <p>
                为了写入 URL 类型的 NDEF 记录，只需使用 NDEFMessage。下面示例使用 async/await。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      try {
        await ndef.write({
          records: [{ recordType: "url", data: "https://w3c.github.io/web-nfc/" }]
        });
      } catch {
        console.log("Write failed :-( try again.");
      };
    </pre>
        </section>

        <section>
            <h3>在写入时处理初始读取</h3>
            <p>
                为了写入，需要找到并读取标签。这使你能够通过检查现有数据或序列号来判断是否确实是要写入的标签。
            </p>
            <p>
                因此，建议在 `reading` 事件中调用 `write()`。`makeReadOnly()` 也同理。
            </p>
            下例展示如何在通用的 `reading` 处理器和用于单次写入的处理器之间进行协调。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      let ignoreRead = false;

      ndef.onreading = (event) => {
        if (ignoreRead) {
          return; // write pending, ignore read.
        }

        console.log("We read a tag, but not during pending write!");
      };

      function write(data) {
        ignoreRead = true;
        return new Promise((resolve, reject) => {
          ndef.addEventListener("reading", event => {
            // Check if we want to write to this tag, or reject.
            ndef.write(data).then(resolve, reject).finally(() => ignoreRead = false);
          }, { once: true });
        });
      }

      await ndef.scan();
      try {
        await write("Hello World");
        console.log("We wrote to a tag!")
      } catch(err) {
        console.error("Something went wrong", err);
      }
    </pre>
        </section>

        <section>
            <h3>带超时的写入调度</h3>
            <p>
                有时为写入操作设置时间限制会很有用。比如要求用户触碰标签，如果在一定时间内未找到标签，则超时。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      ndef.onreading = (event) => console.log("We read a tag!");

      function write(data, { timeout } = {}) {
        return new Promise((resolve, reject) => {
          const ctlr = new AbortController();
          ctlr.signal.onabort = () => reject("Time is up, bailing out!");
          setTimeout(() => ctlr.abort(), timeout);

          ndef.addEventListener("reading", event => {
            ndef.write(data, { signal: ctlr.signal }).then(resolve, reject);
          }, { once: true });
        });
      }

      await ndef.scan();
      try {
        // Let's wait for 5 seconds only.
        await write("Hello World", { timeout: 5_000 });
      } catch(err) {
        console.error("Something went wrong", err);
      } finally {
        console.log("We wrote to a tag!");
      }
    </pre>
        </section>

        <section>
            <h3>处理扫描错误</h3>
            <p>
                本示例展示当 {{NDEFReader/scan}} promise 被拒绝并触发 `readingerror` 时会发生什么。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      ndef.scan().then(() => {
        console.log("Scan started successfully.");
        ndef.onreadingerror = (event) => {
          console.log("Error! Cannot read data from the NFC tag. Try a different one?");
        };
        ndef.onreading = (event) => {
          console.log("NDEF message read.");
        };
      }).catch(error => {
        console.log(`Error! Scan failed to start: ${error}.`);
      });
    </pre>
        </section>

        <section>
            <h3>读取单个标签，仅一次</h3>
            <p>
                本示例展示如何轻松创建一个便捷函数，该函数只读取单个标签然后停止轮询，从而通过减少不必要的工作来节省电量。
            </p>
            <p>
                该示例可以很容易扩展为在给定毫秒后超时。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();

      function read() {
        return new Promise((resolve, reject) => {
          const ctlr = new AbortController();
          ctlr.signal.onabort = reject;
          ndef.addEventListener("reading", event => {
            ctlr.abort();
            resolve(event);
          }, { once: true });
          ndef.scan({ signal: ctlr.signal }).catch(err => reject(err));
        });
      }

      read().then(({ serialNumber }) => {
        console.log(serialNumber);
      });
    </pre>
        </section>

        <section>
            <h3>从标签读取数据，并向空标签写入</h3>
            <p>
                本示例展示如何读取可存储在标签上的各种不同类型的数据。如果标签未格式化或包含空记录，则写入一条值为 "Hello World" 的文本消息。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      await ndef.scan();
      ndef.onreading = async ({ message }) => {
        if (message.records.length == 0 ||               // unformatted tag
            message.records[0].recordType == "empty") {  // empty record
          await ndef.write({
            records: [{ recordType: "text", data: "Hello World" }]
          });
          return;
        }

        const decoder = new TextDecoder();
        for (const record of message.records) {
          switch (record.recordType) {
            case "text":
              const textDecoder = new TextDecoder(record.encoding);
              console.log(`Text: ${textDecoder.decode(record.data)} (${record.lang})`);
              break;
            case "url":
              console.log(`URL: ${decoder.decode(record.data)}`);
              break;
            case "mime":
              if (record.mediaType === "application/json") {
                console.log(`JSON: ${JSON.parse(decoder.decode(record.data))}`);
              }
              else if (record.mediaType.startsWith("image/")) {
                const blob = new Blob([record.data], { type: record.mediaType });

                const img = document.createElement("img");
                img.src = URL.createObjectURL(blob);
                img.onload = () => window.URL.revokeObjectURL(this.src);

                document.body.appendChild(img);
              }
              else {
                console.log(`Media not handled`);
              }
              break;
            default:
              console.log(`Record not handled`);
          }
        }
      };
    </pre>
        </section>

        <section>
            <h3>使用 NFC 标签保存并恢复游戏进度</h3>
            <p>
                通过使用自定义记录标识符（在本例中为 "`/my-game-progress`"）可以筛选相关数据源。当我们读取数据时，会立即通过使用自定义 NDEF 数据布局写入来更新游戏进度。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      await ndef.scan();
      ndef.onreading = async ({ message }) => {
        if (message.records[0]?.id !== "/my-game-progress")
          return;
        console.log(`Game state: ${ JSON.stringify(message.records) }`);

        const encoder = new TextEncoder();
        const newMessage = {
          records: [{
            id: "/my-game-progress",
            recordType: "mime",
            mediaType: "application/json",
            data: encoder.encode(JSON.stringify({
              level: 3,
              points: 4500,
              lives: 3
            }))
          }]
        };
        await ndef.write(newMessage);
        console.log("Message written");
      };
    </pre>
        </section>

        <section>
            <h3>写入与读取 JSON（序列化与反序列化）</h3>
            <p>
                使用序列化与反序列化存储和接收 JSON 数据很容易。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      await ndef.scan();
      ndef.onreading = (event) => {
        const decoder = new TextDecoder();
        for (const record of event.message.records) {
          if (record.mediaType === "application/json") {
            const json = JSON.parse(decoder.decode(record.data));
            const article =/^[aeio]/i.test(json.title) ? "an" : "a";
            console.log(`${json.name} is ${article} ${json.title}`);
          }
        }
      };

      const encoder = new TextEncoder();
      await ndef.write({
        records: [
          {
            recordType: "mime",
            mediaType: "application/json",
            data: encoder.encode(JSON.stringify({
              name: "Benny Jensen",
              title: "Banker"
            }))
          },
          {
            recordType: "mime",
            mediaType: "application/json",
            data: encoder.encode(JSON.stringify({
              name: "Zoey Braun",
              title: "Engineer"
            }))
          }]
      });
    </pre>
        </section>

        <section>
            <h3>写入数据并打印现有数据</h3>
            <p>
                写入数据需要触碰 <a>NFC tag</a>。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      await ndef.scan();
      ndef.onreading = async (event) => {
        const decoder = new TextDecoder();
        for (const record of event.message.records) {
          console.log("Record type:  " + record.recordType);
          console.log("MIME type:    " + record.mediaType);
          console.log("=== data ===\n" + decoder.decode(record.data));
        }

        try {
          await ndef.write("Overriding data is fun!");
        } catch(error) {
          console.log(`Write failed :-( try again: ${error}.`);
        }
      };
    </pre>
        </section>

        <section>
            <h3>停止监听 NDEF 消息</h3>
            <p>
                使用 {{NDEFScanOptions/signal}} 读取 NDEF 消息 3 秒。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      const ctrl = new AbortController();

      await ndef.scan({ signal: ctrl.signal });
      ndef.onreading = () => {
        console.log("NDEF message read.");
      };

      ctrl.signal.onabort = () => {
        console.log("We're done waiting for NDEF messages.");
      };

      // Stop listening to NDEF messages after 3s.
      setTimeout(() => ctrl.abort(), 3_000);
    </pre>
        </section>

        <section>
            <h3>写入智能海报消息</h3>
            <pre class="example">
      const ndef = new NDEFReader();
      const encoder = new TextEncoder();
      await ndef.write({ records: [
        {
          recordType: "smart-poster",  // Sp
          data: { records: [
            {
              recordType: "url",  // URL record for the Sp content
              data: "https://my.org/content/19911"
            },
            {
              recordType: "text",  // title record for the Sp content
              data: "Funny dance"
            },
            {
              recordType: ":t",  // type record, a local type to Sp
              data: encoder.encode("image/gif") // MIME type of the Sp content
            },
            {
              recordType: ":s",  // size record, a local type to Sp
              data: new Uint32Array([4096]) // byte size of Sp content
            },
            {
              recordType: ":act",  // action record, a local type to Sp
              // do the action, in this case open in the browser
              data: new Uint8Array([0])
            },
            {
              recordType: "mime", // icon record, a MIME type record
              mediaType: "image/png",
              data: await (await fetch("icon1.png")).arrayBuffer()
            },
            {
              recordType: "mime", // another icon record
              mediaType: "image/jpg",
              data: await (await fetch("icon2.jpg")).arrayBuffer()
            }
          ]}
        }
      ]});
    </pre>
        </section>

        <section>
            <h3>读取以 NDEF 消息作为有效载荷的外部记录</h3>
            <p>
                外部类型记录可以用于创建应用定义的记录。这些记录可以包含一个作为有效载荷的 <a>NDEF message</a>，
                其内部可以有自己的 <a>NDEF records</a>，包括在应用上下文中使用的 <a>local types</a>。
            </p>
            <p>
                注意，<a>smart poster</a> 记录类型也包含一个作为有效载荷的 <a>NDEF message</a>。
            </p>
            <p>
                由于 NDEF 不保证记录的顺序，使用包含 <a>NDEF message</a> 作为有效载荷的外部类型记录，对于封装相关数据可能很有用。
            </p>
            <p>
                本示例展示如何读取用于社交发布的外部记录，该记录包含一个 <a>NDEF message</a>，其中包含一个文本记录和一个具有 <a>local type</a> "act"（动作）的记录，
                其定义借用自 <a>smart poster</a>，但在本地应用上下文中使用。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      await ndef.scan();
      ndef.onreading = (event) => {
        const externalRecord = event.message.records.find(
          record => record.type == "example.com:smart-poster"
        );

        let action, text;

        for (const record of externalRecord.toRecords()) {
          if (record.recordType == "text") {
            const decoder = new TextDecoder(record.encoding);
            text = decoder.decode(record.data);
          } else if (record.recordType == ":act") {
            action = record.data.getUint8(0);
          }
        }

        switch (action) {
          case 0: // do the action
            console.log(`Post "${text}" to timeline`);
            break;
          case 1: // save for later
            console.log(`Save "${text}" as a draft`);
            break;
          case 2: // open for editing
            console.log(`Show editable post with "${text}"`);
            break;
        }
      };
    </pre>
        </section>

        <section>
            <h3>写入以 NDEF 消息作为有效载荷的外部记录</h3>
            <p>
                外部类型记录可以用于创建应用定义的记录，这些记录甚至可以包含一个作为有效载荷的 <a>NDEF message</a>。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      await ndef.write({ records: [
        {
          recordType: "example.game:a",
          data: {
            records: [
              {
                recordType: "url",
                data: "https://example.game/42"
              },
              {
                recordType: "text",
                data: "Game context given here"
              },
              {
                recordType: "mime",
                mediaType: "image/png",
                data: getImageBytes(fromURL)
              }
            ]
          }
        }
      ]});
    </pre>
        </section>

        <section>
            <h3>在外部记录内写入和读取未知记录</h3>
            <p>
                未知类型记录在外部类型记录内可能很有用，因为开发者知道它们代表什么，因此可以避免指定 MIME 类型。
            </p>
            <pre class="example">
      const encoder = new TextEncoder();
      const ndef = new NDEFReader();
      await ndef.write({ records: [
        {
          recordType: "example.com:shoppingItem", // External record
          data: {
            records: [
              {
                recordType: "unknown", // Shopping item name
                data: encoder.encode("Food")
              },
              {
                recordType: "unknown", // Shopping item description
                data: encoder.encode("Provide nutritional support for an organism.")
              }
            ]
          }
        }
      ]});
    </pre>
            <pre class="example">
      const ndef = new NDEFReader();
      await ndef.scan();
      ndef.onreading = (event) => {
        const shoppingItemRecord = event.message.records[0];
        if (shoppingItemRecord?.recordType !== "example.com:shoppingItem")
          return;

        const [nameRecord, descriptionRecord] = shoppingItemRecord.toRecords();

        const decoder = new TextDecoder();
        console.log("Item name: " + decoder.decode(nameRecord.data));
        console.log("Item description: " + decoder.decode(descriptionRecord.data));
      };
    </pre>
        </section>

        <section>
            <h3>将 NFC 标签永久设为只读</h3>
            <p>
                将 NFC 标签永久设为只读很直接。
            </p>
            <pre class="example">
      const ndef = new NDEFReader();
      ndef.makeReadOnly().then(() => {
        console.log("NFC tag has been made permanently read-only.");
      }).catch(error => {
        console.log(`Operation failed: ${error}`);
      });
    </pre>
            <pre class="example">
      const ndef = new NDEFReader();
      try {
        await ndef.write("Hello world");
        console.log("Message written.");
        await ndef.makeReadOnly();
        console.log("NFC tag has been made permanently read-only after writing to it.");
      } catch (error) {
        console.log(`Operation failed: ${error}`);
      }
    </pre>
        </section>
    </section> <!-- Usage examples -->

    <!-- - - - - - - - - - - - - Data representation - - - - - - - - - - - - - -->
    <section>
        <h2>数据表示</h2>
        <section>
            <h3>接口 <dfn>NDEFMessage</dfn></h3>
            <p>
                任意 <a>NDEF message</a> 的内容由 <a>NDEFMessage</a> 接口暴露：
            </p>
            <pre class="idl">
      [SecureContext, Exposed=Window]
      interface NDEFMessage {
        constructor(NDEFMessageInit messageInit);
        readonly attribute FrozenArray&lt;NDEFRecord&gt; records;
      };

      dictionary NDEFMessageInit {
        required sequence&lt;NDEFRecordInit&gt; records;
      };
    </pre>
            <p>
                <dfn data-dfn-for="NDEFMessage">records</dfn>
                属性表示定义该 <a>NDEF message</a> 的一列 <a>NDEF record</a>。
            </p>
            <p data-dfn-for="NDEFMessageInit">
                <dfn>NDEFMessageInit</dfn> 字典用于初始化一个 <a>NDEF message</a>。
            </p>
        </section>

        <section data-dfn-for="NDEFRecord">
            <h3>接口 <dfn>NDEFRecord</dfn></h3>
            <p>
                任意 <a>NDEF record</a> 的内容由 <a>NDEFRecord</a> 接口暴露：
            </p>
            <pre class="idl">
      [SecureContext, Exposed=Window]
      interface NDEFRecord {
        constructor(NDEFRecordInit recordInit);

        readonly attribute USVString recordType;
        readonly attribute USVString? mediaType;
        readonly attribute USVString? id;
        readonly attribute DataView? data;

        readonly attribute USVString? encoding;
        readonly attribute USVString? lang;

        sequence&lt;NDEFRecord&gt;? toRecords();
      };

      dictionary NDEFRecordInit {
        required USVString recordType;
        USVString mediaType;
        USVString id;

        USVString encoding;
        USVString lang;

        any data; // DOMString or BufferSource or NDEFMessageInit
      };
    </pre>
            <p>
                <dfn>mediaType</dfn> 属性表示 <a>NDEF record</a> 有效载荷的 <a>MIME type</a>。
            </p>
            <p>
                <dfn>recordType</dfn> 属性表示 <a>NDEF record</a> 的类型。
            </p>
            <div>
                <dfn>id</dfn> 属性表示 <dfn>record identifier</dfn>，它是一个绝对或相对的 URL。标识符的唯一性仅由生成者保证，本规范不负责保证。
                <p class=note>
                    NFC NDEF 规范使用术语“message identifier”和“payload identifier”而不是 <a>record
                        identifier</a>，但该标识符与每个记录相关联而非与消息（记录集合）相关联，并且在没有有效载荷时也可能存在。
                </p>
            </div>
            <p>
                <dfn>encoding</dfn> 属性表示在有效载荷为文本数据时用于对其进行编码的 [=encoding/name|encoding name=]。
            </p>
            <p>
                <dfn>lang</dfn> 属性表示在有效载荷已编码时的 [=language tag=]。
            </p>
            <p>
                <dfn>language tag</dfn> 是一个匹配 [[BCP47]] 规范中 <code>Language-Tag</code> 产生式的 <a>string</a>（关于可能值的权威列表，请参见
                <a href="https://www.iana.org/assignments/language-subtag-registry">IANA Language Subtag
                    Registry</a>）。语言范围由一个或多个由 U+002D HYPHEN-MINUS ("-") 分隔的 <dfn>subtags</dfn>
                组成。例如，'<code>en-AU</code>' 表示澳大利亚的英语，'<code>fr-CA</code>' 表示加拿大的法语。在不参考 IANA Language Subtag Registry
                的情况下，可根据 [[RFC5646]] 第 2.2.9 节验证其结构有效性的语言标签被视为结构上有效。
            </p>
            <p>
                <dfn>data</dfn> 属性表示 <a>PAYLOAD field</a> 的数据。
            </p>
            <p>
                <dfn>toRecords()</dfn> 方法在被调用时，必须返回对给定 <a>NDEF Record</a> 运行 <a>convert NDEFRecord.data bytes</a> 的结果。
            </p>
            <p data-dfn-for="NDEFRecordInit">
                <dfn>NDEFRecordInit</dfn> 字典用于使用其 <a>record type</a> <dfn>recordType</dfn>、可选的 <a>record identifier</a>
                <dfn>id</dfn> 和有效载荷数据 <dfn>data</dfn> 来初始化一个 <a>NDEF record</a>。
            </p>
            <div data-dfn-for="NDEFRecordInit">
                此外，还有仅适用于某些 <a>record types</a> 的可选字段：
                <ul>
                    <li data-dfn-for="NDEFRecordInit">
                        "<a>mime</a>"：可选的 <a>MIME type</a> <dfn>mediaType</dfn>。
                    </li>
                    <li data-dfn-for="NDEFRecordInit">
                        "<a>text</a>"：可选的 [=encoding/label|encoding label=] <dfn>encoding</dfn> 和 [=language tag=]
                        <dfn>lang</dfn>。
                    </li>
                </ul>
            </div>
            <p>
                从 <a>NDEFRecordInit</a> 的数据类型映射到 <a>NDEF record</a> 的规则在处理数据的算法步骤中给出，并在 [[[#steps-receiving]]] 和
                [[[#writing-content]]] 节中描述。
            </p>
            <p>
                要对给定 |record:NDEFRecord| 执行 <dfn>convert NDEFRecord.data bytes</dfn>，请运行以下步骤：
            </p>
            <ol class=algorithm data-link-for="NDEFRecord">
                <li>
                    令 |bytes:byte sequence| 为 record 的 <a>data</a> 属性的值。
                </li>
                <li>
                    令 |recordType:record type| 为 |record| 的 <a>recordType</a> 属性的值。
                </li>
                <li>
                    如果 |recordType| 的值为 "`smart-poster`"，则返回对给定 |bytes| 和 `"smart-poster"` 运行 <a>parse records from
                        bytes</a> 的结果。
                </li>
                <li>
                    如果对 |recordType| 运行 <a>validate external type</a> 返回 true，则返回对给定 |bytes| 和 `"external"` 运行 <a>parse
                        records from bytes</a> 的结果。
                </li>
                <li>
                    否则，抛出 {{"NotSupportedError"}}。
                </li>
            </ol>
        </section> <!-- NDEFRecord dictionary -->

        <section>
            <h2><dfn>record type</dfn> 字符串</h2>
            <p>
                该字符串定义了 <a>NDEFRecord</a> 的允许记录类型。[[[#data-mapping]]] 节描述了它如何映射到 <a>NDEF record</a> 类型。
            </p>
            <p>
                一个标准化的 <dfn>well known type name</dfn> 可以是以下之一：
            </p>
            <dl>
                <dt>字符串 "<dfn>empty</dfn>"</dt>
                <dd>
                    表示一个 <a href="#empty-ndef-record-tnf-0">empty</a> <a>NDEFRecord</a> 的值。
                </dd>
                <dt>字符串 "<dfn>text</dfn>"</dt>
                <dd>
                    表示一个 <a>Text record</a> 的值。
                </dd>
                <dt>字符串 "<dfn>url</dfn>"</dt>
                <dd>
                    表示一个 <a>URI record</a> 的值。
                </dd>
                <dt>字符串 "<dfn>smart-poster</dfn>"</dt>
                <dd>
                    表示一个 <a>Smart poster</a> 记录的值。
                </dd>
                <dt>字符串 "<dfn>absolute-url</dfn>"</dt>
                <dd>
                    表示一个 <a>absolute-URL record</a> 的值。
                </dd>
                <dt>字符串 "<dfn>mime</dfn>"</dt>
                <dd>
                    表示一个 <a>MIME type record</a> 的值。
                </dd>
                <dt>字符串 "<dfn>unknown</dfn>"</dt>
                <dd>
                    表示一个 <a>unknown record</a> 的值。
                </dd>
            </dl>
            <p>
                除了 [=well known type names=]，组织也可以创建自定义的 <dfn>external type name</dfn>，它是由 [=domain=]
                名称和自定义类型名组成的字符串，二者以冒号 `U+003A` (`:`) 分隔。
            </p>
            <p>
                应用也可以使用 <dfn>local type name</dfn>，该字符串必须以小写字符或数字开头，表示 NFC Forum [=local type=] 的类型。它通常用于作为父
                <a>NDEFRecord</a> 有效载荷的 <a>NDEFMessage</a> 中的记录，例如在 <a>smart poster</a> 中。<a>local type</a>
                的上下文是其父记录（其有效载荷为包含该记录的 <a>NDEFMessage</a>），并且 <a>local type name</a> 不应与该上下文中使用的任何其他类型名冲突。
            </p>
            <p>
                Web NFC 的任何实现必须将分片记录透明地呈现为单个逻辑记录，因此 <a>unchanged record</a> 不会被显式表示。
            </p>
            <p>
                两个 <a>well-known type records</a>（包括任何 NFC Forum 的 <a>local type</a> 和任何 NFC Forum 的 <a>global
                    type</a>）必须逐字符以区分大小写的方式比较。
            </p>
            <p>
                两个 external types 必须逐字符以不区分大小写的方式比较。
            </p>
            <p>
                任何 <a>well-known type record</a> 和 <a>external type</a> 的二进制表示必须作为相对 URI（RFC 3986）写入，分别省略命名空间标识符 (NID)
                "`nfc`" 与命名空间特定字符串 (NSS) "`wkt`" 和 "`ext`"，即省略 "`urn:nfc:wkt:`" 与 "`urn:nfc:ext:`"
                前缀。例如，"`urn:nfc:ext:company.com:a" 存储为 "`company.com:a`"，而 <a>Text record</a> 的 <a>well-known type
                    records</a> 为 "`urn:nfc:wkt:T`"，但存储为 "`T`"。
            </p>

        </section>

        <section id="data-mapping">
            <h3>数据映射</h3>
            <p>
                从 <a>NDEFRecordInit</a> 的数据类型到 <a>NDEF record</a> 类型的映射（在 [[[#writing-content]]] 节中使用）如下：
            </p>
            <table class="simple" data-link-for="NDEFRecordInit">
                <tr>
                    <th>{{recordType}}</th>
                    <th>{{mediaType}}</th>
                    <th>{{data}}</th>
                    <th nowrap><a href="#ndef-record-types">record type</a></th>
                    <th nowrap>[=TNF field=]</th>
                    <th nowrap>[=TYPE field=]</th>
                </tr>
                <tr>
                    <td><dfn>"`empty`"</dfn></td>
                    <td><i>未使用</i></td>
                    <td><i>未使用</i></td>
                    <td><a>Empty record</a></td>
                    <td>0</td>
                    <td><i>未使用</i></td>
                </tr>
                <tr>
                    <td><dfn>"`text`"</dfn></td>
                    <td><i>未使用</i></td>
                    <td>
                        {{BufferSource}} 或<br>
                        {{DOMString}}
                    </td>
                    <td>[=Well-known type record=]</td>
                    <td>1</td>
                    <td>"`T`"</td>
                </tr>
                <tr>
                    <td><dfn>"`url`"</dfn></td>
                    <td><i>未使用</i></td>
                    <td>{{DOMString}}</td>
                    <td>[=Well-known type record=]</td>
                    <td>1</td>
                    <td>"`U`"</td>
                </tr>
                <tr>
                    <td nowrap><dfn>"`smart-poster`"</dfn></td>
                    <td><i>未使用</i></td>
                    <td>{{NDEFMessageInit}}</td>
                    <td>[=Well-known type record=]</td>
                    <td>1</td>
                    <td>"`Sp`"</td>
                </tr>
                <tr>
                    <td>[=local type name=] 前缀为冒号 `U+003A` (`:`)，例如 "`:act`"、"`:s`" 和 "`:t`"</td>
                    <td><i>未使用</i></td>
                    <td>
                        {{BufferSource}} 或 {{NDEFMessageInit}}
                    </td>
                    <td>[=Local type=] record*</td>
                    <td>1</td>
                    <td>[=local type name=]，例如 "`act`"、"`s`" 和 "`t`"</td>
                </tr>
                <tr>
                    <td><dfn>"`mime`"</dfn></td>
                    <td>[= MIME type =]</td>
                    <td>{{BufferSource}}</td>
                    <td><a>MIME type record</a></td>
                    <td>2</td>
                    <td>[= MIME type =]</td>
                </tr>
                <tr>
                    <td nowrap><dfn>"`absolute-url`"</dfn></td>
                    <td><i>未使用</i></td>
                    <td>{{DOMString}} <i>url</i></td>
                    <td><a>Absolute-URL record</a></td>
                    <td>3</td>
                    <td>[=Absolute-URL=]</td>
                </tr>
                <tr>
                    <td><i>[=external type name=]</i></td>
                    <td><i>未使用</i></td>
                    <td>
                        {{BufferSource}} 或<br>
                        {{NDEFMessageInit}}
                    </td>
                    <td><a>External type record</a></td>
                    <td>4</td>
                    <td>[=external type name=]</td>
                </tr>
                <tr>
                    <td><dfn>"`unknown`"</dfn></td>
                    <td><i>未使用</i></td>
                    <td>{{BufferSource}}</td>
                    <td>[=Unknown record=]</td>
                    <td>5</td>
                    <td><i>未使用</i></td>
                </tr>
            </table>
            <p>
                * 一个 [=local type=] 记录必须嵌入在另一个记录的 <a>NDEFMessage</a> 有效载荷中。
            </p>
            <p>
                从 <a>NDEF record</a> 类型到 <a>NDEFRecord</a> 的映射（用于描述传入的 <a>NDEF message</a> 的 [[[#steps-receiving]]]
                节）如下。
            </p>
            <table class="simple" data-link-for="NDEFRecord">
                <tr>
                    <th><a href="#ndef-record-types">record type</a></th>
                    <th nowrap>[=TNF field=]</th>
                    <th nowrap>[=TYPE field=]</th>
                    <th>{{recordType}}</th>
                    <th>{{mediaType}}</th>
                </tr>
                <tr>
                    <td>[=Empty record=]</td>
                    <td>0</td>
                    <td><i>未使用</i></td>
                    <td>"`empty`"</td>
                    <td>null</td>
                </tr>
                <tr>
                    <td>[=Well-known type record=]</td>
                    <td>1</td>
                    <td>"`T`"</td>
                    <td>"`text`"</td>
                    <td>null</td>
                </tr>
                <tr>
                    <td>[=Well-known type record=]</td>
                    <td>1</td>
                    <td>"`U`"</td>
                    <td>"`url`"</td>
                    <td>null</td>
                </tr>
                <tr>
                    <td>[=Well-known type record=]</td>
                    <td>1</td>
                    <td>"`Sp`"</td>
                    <td nowrap>"`smart-poster`"</td>
                    <td>null</td>
                </tr>
                <tr>
                    <td>[=Local type=] record*</td>
                    <td>1</td>
                    <td>[=local type name=]，例如 "`act`"、"`s`" 和 "`t`"</td>
                    <td>[=local type name=] 前缀为冒号 `U+003A` (`:`)，例如 "`:act`"、"`:s`" 和 "`:t`"</td>
                    <td>null</td>
                </tr>
                <tr>
                    <td>[=MIME type record=]</td>
                    <td>2</td>
                    <td>[=MIME type=]</td>
                    <td>"`mime`"</td>
                    <td>NDEF 记录中使用的 <a>MIME type</a></td>
                </tr>
                <tr>
                    <td>[=Absolute-URL record=]</td>
                    <td>3</td>
                    <td>URL</td>
                    <td>"`absolute-url`"</td>
                    <td>null</td>
                </tr>
                <tr>
                    <td>[=External type record=]</td>
                    <td>4</td>
                    <td>[=external type name=]</td>
                    <td>[=external type name=]</td>
                    <td>null</td>
                </tr>
                <tr>
                    <td><a>Unknown record</a></td>
                    <td>5</td>
                    <td><i>未使用</i></td>
                    <td>"`unknown`"</td>
                    <td>null</td>
                </tr>
            </table>
        </section>
    </section> <!-- Data types and content -->


    <section data-dfn-for="NDEFReader" data-link-for="NDEFReader">
        <h2>NDEFReader 对象</h2>
        <p>
            <dfn>NDEFReader</dfn> 是一个将 NFC 功能暴露给<a>browsing context</a> 的对象：当设备（如标签）位于磁感应场内时读取 <a>NDEF
                messages</a>。此外，它也用于向范围内的 <a>NFC tag</a> 写入 <a>NDEF messages</a>。
        </p>
        <pre class="idl">
    typedef (DOMString or BufferSource or NDEFMessageInit) NDEFMessageSource;

    [SecureContext, Exposed=Window]
    interface NDEFReader : EventTarget {
      constructor();

      attribute EventHandler onreading;
      attribute EventHandler onreadingerror;

      Promise&lt;undefined&gt; scan(optional NDEFScanOptions options={});
      Promise&lt;undefined&gt; write(NDEFMessageSource message,
                                     optional NDEFWriteOptions options={});
      Promise&lt;undefined&gt; makeReadOnly(optional NDEFMakeReadOnlyOptions options={});
    };

    [SecureContext, Exposed=Window]
    interface NDEFReadingEvent : Event {
      constructor(DOMString type, NDEFReadingEventInit readingEventInitDict);

      readonly attribute DOMString serialNumber;
      [SameObject] readonly attribute NDEFMessage message;
    };

    dictionary NDEFReadingEventInit : EventInit {
      DOMString? serialNumber = "";
      required NDEFMessageInit message;
    };
  </pre>
        <p>
            <dfn>NDEFMessageSource</dfn> 是一个联合类型，表示 {{NDEFReader/write()}} 方法所接受的参数类型。
        </p>
        <p data-dfn-for="NDEFReadingEvent">
            <dfn>NDEFReadingEvent</dfn> 是在有新的 NFC 读取时分派的事件。<dfn>serialNumber</dfn>
            属性表示用于防冲突和标识的设备序列号；若不可用则为空字符串。<dfn>message</dfn> 是一个 <a>NDEFMessage</a> 对象。
        </p>
        <p data-dfn-for="NDEFReadingEventInit">
            <dfn>NDEFReadingEventInit</dfn> 用于通过成员 <dfn>message</dfn> 以序列号和 <a>NDEFMessageInit</a> 数据来初始化新事件。如果未提供或为
            null 的 <dfn>serialNumber</dfn>，则使用空字符串初始化事件。
        </p>
        <p class="note">
            虽然大多数标签都有稳定的唯一标识符（UID），但并非所有标签都有，有些标签甚至每次读取都会生成一个随机数。序列号通常由 4 或 7 个数字组成，以 `:` 分隔。
        </p>
        <p>
            一个 {{NDEFReader}} 对象具有以下<a data-cite="ECMASCRIPT#sec-object-internal-methods-and-internal-slots">
                内部槽位</a>：
        </p>
        <table class="simple">
            <thead>
                <tr>
                    <th>Internal Slot</th>
                    <th>Initial value</th>
                    <th>Description (<em>non-normative</em>)</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><dfn>[[\WriteOptions]]</dfn></td>
                    <td>null</td>
                    <td>
                        写入所用的 {{NDEFWriteOptions}} 值。
                    </td>
                </tr>
                <tr>
                    <td><dfn>[[\WriteMessage]]</dfn></td>
                    <td>null</td>
                    <td>
                        将要写入的 {{NDEFMessage}}。初始未设置。
                    </td>
                </tr>
            </tbody>
        </table>

        <p>
            <dfn data-dfn-for="NDEFReader">onreading</dfn> 是一个 {{EventHandler}}，用于在有新读取可用时通知。
        </p>
        <p>
            <dfn data-dfn-for="NDEFReader">onreadingerror</dfn> 是一个 {{EventHandler}}，用于在读取期间发生错误时通知。
        </p>
        <section>
            <h3>与 settings object 关联的 NFC 状态</h3>
            <p>
                支持 NFC 的<a>active document</a> 的<a>relevant settings object</a> 关联一个 <dfn>NFC state</dfn> 记录，其包含以下<a
                    data-cite="ECMASCRIPT#sec-object-internal-methods-and-internal-slots">内部槽位</a>：
            </p>
            <table class="simple">
                <thead>
                    <tr>
                        <th>Internal Slot</th>
                        <th>Initial value</th>
                        <th>Description (<em>non-normative</em>)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><dfn>[[\Suspended]]</dfn></td>
                        <td>false</td>
                        <td>
                            一个布尔标志，指示 NFC 功能是否<a href="#nfc-suspended">suspended</a>，初始为 false。
                        </td>
                    </tr>
                    <tr>
                        <td><dfn>[[\ActivatedReaderList]]</dfn></td>
                        <td>空<a>set</a></td>
                        <td>
                            一个 {{NDEFReader}} 实例的<a>set</a>。
                        </td>
                    </tr>
                    <tr>
                        <td><dfn>[[\PendingWrite]]</dfn></td>
                        <td>empty</td>
                        <td>
                            一个 &lt;|promise:Promise|, |writer:NDEFReader|&gt; 元组，其中 |promise| 保存一个挂起的
                            {{Promise}}，|writer| 保存一个 {{NDEFReader}}。
                        </td>
                    </tr>
                    <tr>
                        <td><dfn>[[\PendingMakeReadOnly]]</dfn></td>
                        <td>empty</td>
                        <td>
                            一个 &lt;|promise:Promise|, |writer:NDEFReader|&gt; 元组，其中 |promise| 保存一个挂起的
                            {{Promise}}，|writer| 保存一个 {{NDEFReader}}。
                        </td>
                    </tr>
                </tbody>
            </table>
            <p>
                <dfn>activated reader objects</dfn> 是 <a>[[\ActivatedReaderList]]</a> 内部槽位的值。
            </p>
            <p>
                <dfn>pending write tuple</dfn> 是 <a>[[\PendingWrite]]</a> 内部槽位的值。
            </p>
            <p>
                <dfn>pending makeReadOnly tuple</dfn> 是 <a>[[\PendingMakeReadOnly]]</a> 内部槽位的值。
            </p>
            <p>
                若 <a>[[\Suspended]]</a> 内部槽位为 true，则表示<dfn id="nfc-is-suspended">NFC is suspended</dfn>。
            </p>
            <p>
                要 <dfn id="suspend-nfc">suspend NFC</dfn>，将 <a>[[\Suspended]]</a> 内部槽位设为 true。
            </p>
            <p>
                要 <dfn id="resume-nfc">resume NFC</dfn>，将 <a>[[\Suspended]]</a> 内部槽位设为 false。
            </p>
            <p class="note">
                内部槽位仅作为本规范中的记法使用，实现不必将其映射为显式的内部属性。
            </p>
        </section>

        <section>
            <h3>处理 NFC 适配器</h3>
            实现可以（MAY）根据本规范中描述的算法步骤使用多个 <a>NFC adapter</a>。
        </section>

        <section>
            <h3>获取权限</h3>
            <p>
                Web NFC API 是一个 [=default powerful feature=]，其 [=powerful feature/name=] 为 "<code>nfc</code>"。
            </p>
            <div>
                要<dfn>obtain permission</dfn>，执行以下步骤：
                <ol class=algorithm>
                    <li>
                        令 |state:PermissionState|</var> 为使用 "<code>nfc</code>" [=getting the current permission state=]
                        的结果。
                    </li>
                    <li>
                        如果 |state| 是 {{PermissionState["granted"]}}（即已通过 [[[PERMISSIONS]]] API 将权限授予该<a>origin</a>
                        和<a>global object</a>），则返回 true。
                    </li>
                    <li>
                        否则，如果 |state| 是 {{PermissionState["prompt"]}}，则可选择<a>request permission to use</a>
                        "<code>nfc</code>" 向用户请求权限。如获授予，则返回 true。
                        <p class="issue" data-number="482">
                            <a data-lt="request permission to use">request permission</a> 步骤尚未明确定义。此时 UA 会就给定
                            <a>origin</a> 和 <a>global object</a> 使用 "<code>nfc</code>" 的策略询问用户；若用户授予权限，则返回 true。
                        </p>
                    </li>
                    <li>
                        返回 false。
                    </li>
                </ol>
            </div>
        </section>

        <section>
            <h3>处理可见性变化</h3>
            <p>
                本规范的 [=page visibility change steps=]，给定字符串 |visibilityState| 和 {{Document}} |document|，如下：
            </p>
            <ol class="algorithm">
                <li>
                    若 |visibilityState| 为 `"visible"`，<a>resume NFC</a> 并中止这些步骤。
                </li>
                <li>
                    否则，执行以下步骤：
                    <ol>
                        <li>
                            <a>Suspend NFC</a>。
                        </li>
                        <li>
                            尝试<a>abort a pending write operation</a>。
                        </li>
                        <li>
                            尝试<a>abort a pending make read-only operation</a>。
                        </li>
                    </ol>
                </li>
            </ol>
            <p>
                术语 <dfn id="nfc-suspended">suspended</dfn> 指 NFC 操作被暂停，这意味着在被暂停期间，任何 <a>NDEFReader</a> 都不会写入 <a>NFC
                    content</a>，且不会向任何 {{NDEFReader}} 呈现接收到的 <a>NFC content</a>。
            </p>
        </section>

        <section>
            <h3>中止挂起的写入操作</h3>
            <div>
                要尝试<dfn>abort a pending write operation</dfn>，执行以下步骤：
                <ol class=algorithm>
                    <li>
                        如果不存在<a>pending write tuple</a> |tuple|，则中止这些步骤。
                    </li>
                    <li>
                        如果 |tuple| 的 writer 已经启动了正在进行的 NFC 数据传输，则中止这些步骤。
                    </li>
                    <li>
                        使用 {{"AbortError"}} 拒绝 |tuple| 的 promise，并中止这些步骤。
                        <p class=note>
                            拒绝该 promise 将清除 <a>pending write tuple</a>。
                        </p>
                    </li>
                </ol>
            </div>
        </section>

        <section>
            <h3>中止挂起的只读化操作</h3>
            <div>
                要尝试<dfn>abort a pending make read-only operation</dfn>，执行以下步骤：
                <ol class=algorithm>
                    <li>
                        如果不存在<a>pending makeReadOnly tuple</a> |tuple|，则中止这些步骤。
                    </li>
                    <li>
                        如果 |tuple| 的 writer 已经将某个 NFC 标签永久设为只读，则中止这些步骤。
                    </li>
                    <li>
                        使用 {{"AbortError"}} 拒绝 |tuple| 的 promise，并中止这些步骤。
                        <p class=note>
                            拒绝该 promise 将清除 <a>pending makeReadOnly tuple</a>。
                        </p>
                    </li>
                </ol>
            </div>
        </section>

        <section>
            <h3>释放 NFC</h3>
            <p>
                要在<a>environment settings object</a> 上<dfn>release NFC</dfn>，执行以下步骤：
            </p>
            <ol id="steps-nfc-release">
                <li>
                    <a>Suspend NFC</a>。
                </li>
                <li>
                    尝试<a>abort a pending write operation</a>。
                </li>
                <li>
                    尝试<a>abort a pending make read-only operation</a>。
                </li>
                <li>
                    清空<a>activated reader objects</a>。
                </li>
                <li>
                    释放底层平台上的 NFC 资源。
                </li>
            </ol>
            <p>
                UA 必须在文档的<a>relevant settings object</a> 上作为额外的<a>unloading document cleanup steps</a> 来<a>release
                    NFC</a>。
            </p>
        </section> <!-- release NFC -->

        <section data-dfn-for="NDEFWriteOptions">
            <h3><dfn>NDEFWriteOptions</dfn> 字典</h3>
            <pre class="idl">
      dictionary NDEFWriteOptions {
        boolean overwrite = true;
        AbortSignal? signal;
      };
    </pre>
            <p>
                当 <dfn>overwrite</dfn> 属性的值为 false 时，<a href="#steps-write">write 算法</a> 将读取 <a>NFC tag</a> 以确定其上是否已有
                <a>NDEF</a> 记录；若有，则不会执行任何挂起的写入。
            </p>
            <p>
                <dfn>signal</dfn> 属性允许中止 {{NDEFReader/write()}} 操作。
            </p>
        </section>

        <section data-dfn-for="NDEFMakeReadOnlyOptions">
            <h3><dfn>NDEFMakeReadOnlyOptions</dfn> 字典</h3>
            <pre class="idl">
      dictionary NDEFMakeReadOnlyOptions {
        AbortSignal? signal;
      };
    </pre>
            <p>
                <dfn>signal</dfn> 属性允许中止 {{NDEFReader/makeReadOnly()}} 操作。
            </p>
        </section>

        <section data-dfn-for="NDEFScanOptions">
            <h3><dfn>NDEFScanOptions</dfn> 字典</h3>
            <pre class="idl">
        dictionary NDEFScanOptions {
          AbortSignal signal;
        };
      </pre>
            <p>
                <dfn>signal</dfn> 属性允许中止 {{NDEFReader/scan()}} 操作。
            </p>
        </section> <!-- NDEFScanOptions -->

        <section id="writing-content">
            <h3><dfn>Writing content</dfn></h3>
            <p>
                本节描述如何在定时器到期前，当某个 <a>NFC tag</a> 下次进入近距离范围时，向其写入一个 <a>NDEF message</a>。任一时刻，对于一个 <a>origin</a>
                最多只能设置一个待写入的 <a>NDEF message</a>，直至当前消息被发送或写入被中止。
            </p>
            <section>
                <h3><strong>write()</strong> 方法</h3>
                <div id="steps-write">
                    当调用
                    <dfn>NDEFReader.write</dfn> 方法时，必须运行 <dfn>write a message</dfn> 算法：
                    <ol class=algorithm>
                        <li>
                            令 |p:Promise| 为一个新的 {{Promise}} 对象。
                        </li>
                        <li>
                            如果当前未在当前激活的 <a>top-level browsing context</a> 中执行，则以 {{"InvalidStateError"}} 拒绝 |p| 并返回 |p|。
                        </li>
                        <li>
                            令 |message:NDEFMessageSource| 为第一个参数。
                        </li>
                        <li>
                            令 |options:NDEFWriteOptions| 为第二个参数。
                        </li>
                        <li>
                            令 |signal:AbortSignal| 为 |options| 中同名字典成员（若存在），否则为 null。
                        </li>
                        <li>
                            若 |signal| 已被 [= AbortSignal/aborted =]，则以 |signal| 的 [=AbortSignal/abort reason=] 拒绝 |p|
                            并返回 |p|。
                        </li>
                        <li>
                            若 |signal| 非 null，则<a data-cite="dom#abortsignal-abort-algorithms">向 |signal| 添加以下中止步骤</a>：
                            <ol>
                                <li>
                                    在<a>environment settings object</a> 上运行 <a>abort a pending write operation</a>。
                                </li>
                            </ol>
                        </li>
                        <li>
                            [=promise/React=] 至 |p|：
                            <ol>
                                <li>
                                    若 |p| 已 settle（履行或拒绝），则清除（若存在的）<a>pending write tuple</a>。
                                </li>
                            </ol>
                        </li>
                        <li>
                            返回 |p| 并<a>in parallel</a> 运行以下步骤：
                            <ol>
                                <li>
                                    若 <a>obtain permission</a> 步骤返回 false，则以 {{"NotAllowedError"}} 拒绝 |p| 并中止这些步骤。
                                </li>
                                <li>
                                    若不存在底层 <a>NFC Adapter</a>，或无法建立连接，则以 {{"NotSupportedError"}} 拒绝 |p| 并中止这些步骤。
                                </li>
                                <li>
                                    若 UA 不允许访问底层 <a>NFC Adapter</a>（例如用户偏好），则以 {{"NotReadableError"}} 拒绝 |p| 并中止这些步骤。
                                </li>
                                <li>
                                    若底层 <a>NFC Adapter</a> 不支持推送数据，则以 {{"NotSupportedError"}} 拒绝 |p| 并中止这些步骤。
                                </li>
                                <li>
                                    实现可以（MAY）以 {{"NotSupportedError"}} 拒绝 |p| 并中止这些步骤。
                                    <p class="note">
                                        UA 可能在此时中止写入。终止的原因属于实现细节。例如，实现可能无法支持所请求的操作。
                                    </p>
                                </li>
                                <li>
                                    令 |output| 表示将由 UA 创建的 <a>NDEF message</a>，其为用 |message|、`""` 和 `0` 调用 <a>create
                                        NDEF message</a> 的结果。若抛出异常，则以该异常拒绝 |p| 并中止这些步骤。
                                </li>
                                <li>
                                    尝试 <a>abort a pending write operation</a>。
                                    <p class="note">
                                        一次写入会替换所有先前配置的写入操作。
                                    </p>
                                </li>
                                <li>
                                    将 `this`.<a>[[\WriteOptions]]</a> 设为 |options|。
                                </li>
                                <li>
                                    将 `this`.<a>[[\WriteMessage]]</a> 设为 |output|。
                                </li>
                                <li>
                                    将 <a>pending write tuple</a> 设为 (`this`, |p|)。
                                </li>
                                <li>
                                    每当有 <a>NFC tag</a> |device| 进入通信范围时，运行 <a>start the NFC write</a> 步骤。
                                    <p class="note">
                                        若 <a>NFC is suspended</a>，继续等待，直到用户中止 promise 或某个 <a>NFC tag</a> 进入通信范围。
                                    </p>
                                </li>
                            </ol>
                        </li>
                        </li>
                    </ol>
                </div>

                <div id="steps-start-nfc-write">
                    要<dfn>start the NFC write</dfn>，执行以下步骤：
                    <ol class=algorithm>
                        <li>
                            令 |p:Promise| 为 <a>pending write tuple</a> 的 promise。
                        </li>
                        <li>
                            令 |writer| 为 <a>pending write tuple</a> 的 writer。
                        </li>
                        <li>
                            令 |options:NDEFWriteOptions| 为 |writer|.<a>[[\WriteOptions]]</a>。
                        </li>
                        <li>
                            若近距离范围内的 <a>NFC tag</a> 不支持用于格式化或写入的 <a>NDEF</a> 技术，则以 {{"NotSupportedError"}} 拒绝 |p| 并返回
                            |p|。
                        </li>
                        <li>
                            校验<a href="#nfc-is-suspended">NFC 未被暂停</a>。
                        </li>
                        <li>
                            若成功，则执行以下步骤：
                            <ol>
                                <li>
                                    若 |device| 为 <a>NFC tag</a> 且 |options| 的 overwrite 为 false，则读取该标签以检查是否已有
                                    <a>NDEF</a> 记录。若有，则以 {{"NotAllowedError"}} 拒绝 |p| 并返回 |p|。
                                </li>
                                <li>
                                    令 |output:NDEFMessage| 为 |writer|.<a>[[\WriteMessage]]</a>。
                                </li>
                                <li>
                                    使用与 |device| 处于通信范围内的 <a>NFC adapter</a>，以 |output| 作为缓冲区，启动向 |device| 的数据传输。
                                    <p class="note">
                                        若近距离范围内的 <a>NFC tag</a> 未格式化且可进行 <a>NDEF</a> 格式化，则先格式化并将 |output| 作为缓冲区写入。
                                    </p>
                                    <p class="note">
                                        多个适配器应由用户依次使用。几乎不太可能在两个或多个不同且已连接的 <a>NFC adapter</a>
                                        上同时轻触。若确实发生，用户可能需要重复轻触，最好一次一个设备。此处的错误表明需要重试，否则用户可能认为操作在所有连接的 <a>NFC adapter</a>
                                        上都成功了。
                                    </p>
                                </li>
                                <li>
                                    若传输失败，以 {{"NetworkError"}} 拒绝 |p| 并中止这些步骤。
                                </li>
                                <li>
                                    当传输完成时，resolve |p|。
                                </li>
                            </ol>
                        </li>
                    </ol>
                </div>
            </section>
        </section> <!-- Writing content -->

        <section>
            <h3>创建 NDEF message</h3>
            <div>
                给定 |source:NDEFMessageSource|、|context:string| 和 |recordsDepth:unsigned short|，要<dfn>create NDEF
                    message</dfn>，执行以下步骤：
                <ol class=algorithm id="create-web-nfc-message" data-link-for="NDEFMessageSource">
                    <li>根据 |source:NDEFMessageSource| 的类型分支：
                        <dl>
                            <dt>{{DOMString}}</dt>
                            <ul>
                                <li>
                                    令 |textRecord| 为一个 <a>NDEFRecord</a>，其初始化时 |recordType| 设为 "`text`"，|data| 设为
                                    |source|。
                                </li>
                                <li>
                                    令 |records| 为列表 « |textRecord| »。
                                </li>
                                <li>
                                    将 |source| 的 records 设为 |records|。
                                </li>
                            </ul>
                            <dt>{{BufferSource}}</dt>
                            <ul>
                                <li>
                                    令 |mimeRecord| 为一个 <a>NDEFRecord</a>，其初始化时 |recordType| 设为 "`mime`"，|data| 设为
                                    |source|，且 |mediaType| 设为 "`application/octet-stream`"。
                                </li>
                                <li>
                                    令 |records| 为列表 « |mimeRecord| »。
                                </li>
                                <li>
                                    将 |source| 的 records 设为 |records|。
                                </li>
                            </ul>
                            <dt>{{NDEFMessageInit}}</dt>
                            <ul>
                                <li>
                                    若 |source| 的 records [= list/is empty =]，则[= exception/throw =] 一个 {{TypeError}}。
                                </li>
                                <li>
                                    将 |recordsDepth| 加一。
                                </li>
                                <li>
                                    若 |recordsDepth| > `32`，则[= exception/throw =] 一个 {{TypeError}}。
                                    <aside class="note">
                                        出于实际目的，NDEF 消息的存储空间有限，因此本规范对嵌套消息的深度设置了一个限制，开发者不太可能达到。参见 <a
                                            href="https://github.com/w3c/web-nfc/issues/620">issue #620</a>。
                                    </aside>
                                </li>
                            </ul>
                            <dt>unmatched type</dt>
                            <ul>
                                <li>
                                    [= exception/throw =] 一个 {{TypeError}}。
                                </li>
                            </ul>
                        </dl>
                    </li>
                    <li>
                        令 |output| 表示 UA 按这些步骤创建的 <a>NDEF message</a>。
                    </li>
                    <li>
                        [= list/For each =] |record:NDEFRecordInit| 属于<a>list</a> |source| 的 records，运行如下步骤：
                        <ol>
                            <li>
                                令 |ndef| 为运行 <a>create NDEF record</a>（给定 |record:NDEFRecordInit|、|context| 和
                                |recordsDepth|）的结果，或确保底层平台为 |ndef| 提供等效值。若算法抛出异常 |e|，则以 |e| 拒绝 |promise| 并中止这些步骤。
                            </li>
                            <li>
                                将 |ndef| 添加到 |output|。
                            </li>
                        </ol>
                    </li>
                    <li>
                        若运行 <a>check created records</a>（给定 |output| 和 |context|）抛出 |error: Error|，则以 |error| 拒绝
                        |promise| 并中止这些步骤。
                    </li>
                    <li>
                        返回 |output|。
                    </li>
                </ol>
            </div>

            <section>
                <h3>检查已创建记录</h3>
                <div>
                    给定 |records: NDEFRecord sequence| 和 |context: string|，要<dfn>check created records</dfn>，执行以下步骤：
                    <ol class=algorithm>
                        <li>
                            若 |context| 为 `"smart-poster"` 且 |records| 不包含且仅包含一个 <a>URI record</a>，或其包含多于一个的 <a>type
                                record</a>、<a>size record</a> 或 <a>action record</a>，则[= exception/throw =] 一个
                            {{TypeError}}。
                        </li>
                        <li>
                            若 |context| 为 `"smart-poster"`，将 <a>URI record</a> 移动到 |records| 的开头。
                        </li>
                    </ol>
                    <p class="note">
                        Web NFC 当前允许在 <a>smart poster</a> 中写入 <a>external type</a> 和 <a>local type</a> 记录。同时，也允许
                        <a>empty records</a>。应用可以忽略 <a>smart poster</a> 内的任何额外记录。
                    </p>
                    <p class="note">
                        图标记录的媒体类型可以被限制为 `"image/"` 或 `"video/"`，但 [[NDEF-SMARTPOSTER]] 规范实际上允许在 <a>smart poster</a>
                        中使用其他媒体类型记录，这些可以由应用特定方式处理，例如使用其关联的某种
                        <a href="https://www.iana.org/assignments/media-types/media-types.xhtml">MIME types</a> 的 vCard
                        名片。
                    </p>
                </div>
            </section>

            <section>
                <h3>创建 NDEF record</h3>
                <div>
                    给定 |record:NDEFRecordInit|、|context:string| 和 |recordsDepth:unsigned short|，要<dfn>create NDEF
                        record</dfn>，执行以下步骤：
                    <ol data-link-for="NDEFRecordInit">
                        <li>
                            令 |ndef| 为 UA 将要创建的一个 <a>NDEF record</a> 的表示。
                        </li>
                        <li>
                            若 |record| 的 <a>id</a> 不为 undefined：
                            <ul>
                                <li>
                                    令 |identifier| 为 |record| 的 <a>id</a>。
                                </li>
                                <li>
                                    将 |ndef| 的 <a>IL field</a> 设为 `1`。
                                </li>
                                <li>
                                    将 |ndef| 的 <a>ID LENGTH field</a> 设为 |identifier| 的长度。
                                </li>
                                <li>
                                    将 |ndef| 的 <a>ID field</a> 设为 |identifier|。
                                </li>
                            </ul>
                        </li>
                        <li>
                            按 |record| 的 <a>recordType</a> 分支，使用 |record|、|ndef|、|context| 和 |recordsDepth|
                            调用下面指定的算法并返回结果。若抛出异常 |e|，则以 |e| 拒绝 |promise| 并中止这些步骤。
                            <dl>
                                <dt>"`empty`"</dt>
                                <ul>
                                    <li>
                                        <a>map empty record to NDEF</a>。
                                    </li>
                                </ul>
                                <dt>"`text`"</dt>
                                <ul>
                                    <li>
                                        <a>map text to NDEF</a>。
                                    </li>
                                </ul>
                                <dt>"`url`"</dt>
                                <ul>
                                    <li>
                                        <a>map a URL to NDEF</a>。
                                    </li>
                                </ul>
                                <dt>"`mime`"</dt>
                                <ul>
                                    <li>
                                        <a>map binary data to NDEF</a>。
                                    </li>
                                </ul>
                                <dt>"`smart-poster`"</dt>
                                <ul>
                                    <li>
                                        <a>map smart poster to NDEF</a>。
                                    </li>
                                </ul>
                                <dt>"`absolute-url`"</dt>
                                <ul>
                                    <li>
                                        <a>map absolute-URL to NDEF</a>。
                                    </li>
                                </ul>
                            </dl>
                        </li>
                        <li>
                            若 |record| 的 <a>recordType</a> 以冒号 `U+003A` (`:`) 开头：
                            <ul>
                                <li>
                                    若 |context| 为 `""`（即 |record| 不是另一个 <a>NDEF record</a> 的有效载荷），则以 {{TypeError}} 拒绝
                                    |promise| 并中止这些步骤。
                                </li>
                                <li>
                                    若对 |record| 的 <a>recordType</a> 运行 <a>validate local type</a> 步骤返回 false，则以
                                    {{TypeError}} 拒绝 |promise| 并中止这些步骤。
                                </li>
                                <li>
                                    返回运行 <a>map local type to NDEF</a>（给定 |record|、|ndef|、|context| 和
                                    |recordsDepth|）的结果。若抛出异常 |e|，则以 |e| 拒绝 |promise| 并中止这些步骤。
                                </li>
                            </ul>
                        </li>
                        <li>
                            若对 |record| 的 <a>recordType</a> 运行 <a>validate external type</a> 返回 true，则返回 <a>map external
                                data to NDEF</a>（给定 |record|、|ndef|、|context| 和 |recordsDepth|）的结果。若抛出异常 |e|，则以 |e| 拒绝
                            |promise| 并中止这些步骤。
                        </li>
                        <li>
                            否则，[= exception/throw =] 一个 {{TypeError}} 并中止这些步骤。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>校验 external type</h3>
                <div>
                    [[NFC-RTD]] 规定 external types 必须包含发布组织的 [=domain=] 名、一个冒号 `U+003A` (`:`)，以及至少一个字符长的类型名，例如
                    "`w3.org:member`"，全部以 ASCII 字符存储。
                </div>
                <p>
                    [[NFC-RTD]] 也规定了 URN 前缀 “`urn:nfc:ext:`”，但它不会存储在 <a>NDEF record</a> 中，因此 Web NFC 应用在创建 <a>external
                        type records</a> 时不应（SHOULD NOT）指定该 URN 前缀。
                </p>
                <p class="note">
                    [[NFC-RTD]] 要求 external type 名在表示时带有 URN 前缀 “`urn:nfc:ext:`”，例如在读取 <a>NDEF messages</a> 时。然而，由于
                    <a>external type records</a> 通过 <a>TNF FIELD</a> 被设为 `0x04` 来区分，类型名冲突的风险很低。此外，<a
                        href="https://www.w3.org/2001/tag/doc/URNsAndRegistries-50.html">W3C TAG</a> 也建议在 Web 上避免使用
                    URN。因此，Web NFC 在读取或写入 <a>NDEF messages</a> 时都不使用该 URN 前缀。
                </p>
                <p>
                    给定 |input:USVString|，要<dfn>split external type</dfn>，执行以下步骤：
                </p>
                <ol class=algorithm id="split-external-type">
                    <li>
                        若 |input| 中未找到 `U+003A` (`:`)，则返回 failure。
                    </li>
                    <li>
                        令 |domain| 为 |input| 起始到首次出现 `U+003A` (`:`) 之前的部分。
                    </li>
                    <li>
                        令 |type| 为 |input| 首次出现 `U+003A` (`:`) 之后到末尾的部分（若有）。
                    </li>
                    <li>
                        返回 |domain| 与 |type| 的二元组。
                    </li>
                </ol>
                <p>
                    给定 |input:USVString|，要<dfn>validate external type</dfn>，执行以下步骤：
                </p>
                <ol class=algorithm id="validate-external-type">
                    <li>
                        令 |domain| 与 |type| 为运行 [=split external type=] 的结果；若失败则返回 false。
                    </li>
                    <li>
                        若 |domain| 不是一个 [=valid domain string=]，返回 false。
                    </li>
                    <li>
                        若 |type| 包含非 [=ASCII alphanumeric=] 的 [=code points=]，或包含 `U+0024` (`$`)、`U+0027` (`'`)、`U+0028`
                        `LEFT PARENTHESIS` (`(`)、`U+0029` `RIGHT PARENTHESIS` (`)`)、`U+002A` (`*`)、`U+002B`
                        (`+`)、`U+002C` (`,`)、`U+002D` (`-`)、`U+002E` (`.`)、`U+003B` (`;`)、`U+003D` (`=`)、`U+0040`
                        (`@`)、`U+005F` (`_`)，返回 false。
                    </li>
                    <li>
                        返回 true。
                    </li>
                </ol>
            </section>

            <section>
                <h3>校验 local type</h3>
                <p>
                    给定 |input:USVString|，要<dfn>validate local type</dfn>，执行以下步骤：
                </p>
                <ol class=algorithm id="validate-local-type">
                    <li>
                        令 |localTypeName| 为 |input| 第一次出现 `U+003A` (`:`) 之后至末尾的部分。
                    </li>
                    <li>
                        若 |localTypeName| 不是 {{USVString}} 或其字节长度超过 255，返回 false。
                    </li>
                    <li>
                        若 |localTypeName| 未以小写字母或数字开头，返回 false。
                    </li>
                    <li>
                        若 |input| 等于其所包含的 <a>NDEF message</a> 中任何 <a>NDEF record</a> 的 <a>record type</a>，返回 false。
                    </li>
                    <li>
                        返回 true。
                    </li>
                </ol>
            </section>

            <section>
                <h3>将空记录映射到 NDEF</h3>
                <div>
                    给定 |record:NDEFRecordInit|、|ndef|，要<dfn>map empty record to NDEF</dfn>，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecordInit">
                        <!--
          <li>
            If |context| is `"smart-poster"`,
            [= exception/throw =] a {{TypeError}}.
          </li>
          -->
                        <li>
                            若 |record| 的 <a>mediaType</a> 不为 undefined，[= exception/throw =] 一个 {{TypeError}}。
                        </li>
                        <li>
                            若 |record| 的 <a>id</a> 不为 undefined，[= exception/throw =] 一个 {{TypeError}}。
                        </li>
                        <li>将
                            |ndef| 的 <a>TNF field</a> 设为 `0`（<a>empty record</a>）。
                        </li>
                        <li>将
                            |ndef| 的 <a>IL field</a> 设为 `0`。
                        </li>
                        <li>将
                            |ndef| 的 <a>TYPE LENGTH field</a> 和 <a>PAYLOAD LENGTH field</a> 设为 `0`，并省略 <a>TYPE field</a>
                            与 <a>PAYLOAD field</a>。
                        </li>
                        <li>
                            返回 |ndef|。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>将字符串映射到 NDEF</h3>
                <div>
                    给定 |record:NDEFRecordInit| 和 |ndef|，要<dfn>map text to NDEF</dfn>，执行以下步骤：
                    <p class="note">
                        当客户端特别希望以 [=well-known type record=] 写入文本时这很有用。其他选项包括使用 "`mime`" 值并显式指定文本类 <a>MIME
                            type</a>，这有助于更好地区分，例如使用 "`text/xml`" 或 "`text/vcard`"。
                    </p>
                    <ol class=algorithm data-link-for="NDEFRecordInit">
                        <li>
                            若 |record| 的 <a>mediaType</a> 不为 undefined，[= exception/throw =] 一个 {{TypeError}}。
                        </li>
                        <li>
                            若 |record| 的 <a>data</a> 类型不是 {{DOMString}} 或 {{BufferSource}}，[= exception/throw =] 一个
                            {{TypeError}} 并中止这些步骤。
                        </li>
                        <li>
                            令 |documentLanguage:string| 为[=document element=] 的 <a>lang</a> 属性。
                        </li>
                        <li>
                            若 |documentLanguage| 为空字符串，将其设为 "`en`"。
                        </li>
                        <li>
                            令 |language:string| 为 |record| 的 <a>lang</a>（若其 [= map/exists =]），否则设为 |documentLanguage|。
                        </li>
                        <li>根据 |record| 的 <a>data</a> 类型分支：
                            <dl>
                                <dt>{{DOMString}}</dt>
                                <ol>
                                    <li>
                                        若 |record| 的 <a>encoding</a> 既非 undefined 亦非 "`utf-8`"，则[= exception/throw =] 一个
                                        {{TypeError}} 并中止这些步骤。
                                    </li>
                                    <li>
                                        令 |encoding label:string| 为 "`utf-8`"。
                                    </li>
                                </ol>
                                <dt>{{BufferSource}}</dt>
                                <ol>
                                    <li>
                                        令 |encoding label:string| 为 |record| 的 <a>encoding</a>（若其 [= map/exists =]），否则为
                                        "`utf-8`"。
                                    </li>
                                    <li>
                                        若 |encoding label| 不等于 "`utf-8`"、"`utf-16`"、"`utf-16le`" 或 "`utf-16be`"，则[=
                                        exception/throw =] 一个 {{TypeError}}。
                                    </li>
                                </ol>
                            </dl>
                        </li>
                        <li>
                            令 |encoding name| 为从 |encoding label| <a
                                data-cite="encoding#concept-encoding-get">obtained</a> 的 [=encoding/name|name=]。
                        </li>
                        <li>
                            令 |header:byte| 为如下构造的一个 <a>byte</a>：
                            <ol>
                                <li>
                                    若 |encoding name| 等于 UTF-8，则将位 `7` 设为 `0`；否则设为 `1`。
                                </li>
                                <li>
                                    将位 `6` 设为 `0`（保留）。
                                </li>
                                <li>
                                    令 |languageLength:octet| 为 |language| <a>string</a> 的长度。
                                </li>
                                <li>
                                    若 |languageLength| 不能存储于 6 位（|languageLength| > 63），则[= exception/throw =] 一个
                                    {{SyntaxError}}。
                                </li>
                                <li>
                                    将位 `5` 至位 `0` 设为 |languageLength|。
                                </li>
                            </ol>
                        </li>
                        <li>
                            令 |data:byte sequence| 为空的 [= byte sequence =]。
                            <ol>
                                <li>
                                    将 |data| 的第一个 <a>byte</a>（位置 0）设为 |header|。
                                </li>
                                <li>
                                    将位置 1（第二个 <a>byte</a>）到位置 |languageLength| 的 |data| 设为 |language|。
                                </li>
                                <li>根据 |record| 的 <a>data</a> 类型分支：
                                    <dl>
                                        <dt>{{DOMString}}</dt>
                                        <ol>
                                            <li>
                                                令 |stream:byte stream| 为对 |record| 的 <a>data</a> 运行 <a>UTF-8 encode</a>
                                                的结果 <a data-cite="encoding#concept-stream">byte stream</a>。
                                            </li>
                                            <li>
                                                从 |stream| <a data-cite="encoding#concept-stream-read">Read</a> 字节到
                                                |data|（自位置 |languageLength| + 1 起），直到 <a
                                                    data-cite="encoding#concept-stream-read">read</a> 返回 <a
                                                    data-cite="encoding#end-of-stream">end-of-stream</a>。
                                            </li>
                                        </ol>
                                        <dt>{{BufferSource}}</dt>
                                        <ol>
                                            <li>
                                                将 |record| 的 <a>data</a> 中的字节写入 |data|（自位置 |languageLength| + 1 起）。
                                            </li>
                                        </ol>
                                    </dl>
                                </li>
                            </ol>
                        </li>
                        <li>
                            将 |length:unsigned long| 设为 |data| 的 [=byte sequence/length=]。
                        </li>
                        <li>
                            <ol>
                                <li>
                                    将 |ndef| 的 <a>TNF field</a> 设为 `1`（[=well-known type record=]）。
                                </li>
                                <li>
                                    将 |ndef| 的 <a>TYPE field</a> 设为 "`T`"（`0x54`）。
                                </li>
                                <li>
                                    将 |ndef| 的 <a>PAYLOAD LENGTH field</a> 设为 |length|。
                                </li>
                                <li>
                                    若 |length| > `0`，将 |ndef| 的 <a>PAYLOAD field</a> 设为 |data|。
                                </li>
                            </ol>
                        </li>
                        <li>
                            返回 |ndef|。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>将 URL 映射到 NDEF</h3>
                <div>
                    给定 |record:NDEFRecordInit| 和 |ndef|，要<dfn>map a URL to NDEF</dfn>，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecordInit">
                        <li>
                            若 |record| 的 <a>mediaType</a> 不为 undefined，[= exception/throw =] 一个 {{TypeError}}。
                        </li>
                        <li>
                            若 |record| 的 <a>data</a> 不是 {{DOMString}}，则[= exception/throw =] 一个 {{TypeError}}。
                        </li>
                        <li>
                            令 |url:URL| 为对 |record| 的 <a>data</a> 进行 <a data-lt="url parser">parsing</a> 的结果。
                        </li>
                        <li>
                            若 |url| 为 failure，[= exception/throw =] 一个 {{SyntaxError}}。
                        </li>
                        <li>
                            令 |serializedURL:string| 为对 |url| 的 <a
                                data-cite="url#concept-url-serializer">serialization</a>。
                        </li>
                        <li>
                            将 [[[NFC-STANDARDS]]] 的 URI Record Type Definition 的第 3.2.2 节所定义的 URI 前缀与 |serializedURL|
                            进行匹配。
                        </li>
                        <li>
                            令 |prefixString:string| 为匹配到的前缀，否则为<a href="#dfn-empty">empty</a> <a>string</a>。
                        </li>
                        <li>
                            令 |prefixByte:byte| 为对应的前缀编号，否则为 `0`。
                        </li>
                        <li>
                            令 |shortenedURL:string| 为自 |serializedURL| 起始处移除 |prefixString| 后的 <a>string</a>。
                        </li>
                        <li>
                            令 |data:byte sequence| 为空的 [= byte sequence =]。
                            <ol>
                                <li>
                                    将 |data| 的第一个 <a>byte</a> 设为 |prefixByte|。
                                </li>
                                <li>
                                    令 |stream:byte stream| 为对 |shortenedURL| 运行 <a>UTF-8 encode</a> 的结果 <a
                                        data-cite="encoding#concept-stream">byte stream</a>。
                                </li>
                                <li>
                                    从 |stream| <a data-cite="encoding#concept-stream-read">Read</a> 字节到 |data|（自位置 1
                                    起），直到 <a data-cite="encoding#concept-stream-read">read</a> 返回 <a
                                        data-cite="encoding#end-of-stream">end-of-stream</a>。
                                </li>
                            </ol>
                        </li>
                        <li>
                            将 |length:unsigned long| 设为 |data| 的 [=byte sequence/length=]。
                        </li>
                        <li>
                            将 |ndef| 的 <a>TNF field</a> 设为 `1`（[=well-known type record=]）。
                        </li>
                        <li>
                            将 |ndef| 的 <a>TYPE field</a> 设为 "`U`"（`0x55`）。
                        </li>
                        <li>
                            将 |ndef| 的 <a>PAYLOAD LENGTH field</a> 设为 |length|。
                        </li>
                        <li>
                            若 |length| > `0`，将 |ndef| 的 <a>PAYLOAD field</a> 设为 |data|。
                        </li>
                        <li>
                            返回 |ndef|。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>将二进制数据映射到 NDEF</h3>
                <div>
                    给定 |record:NDEFRecordInit| 和 |ndef|，要<dfn>map binary data to NDEF</dfn>，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            若 |record| 的 <a>data</a> 类型不是 {{BufferSource}}，[= exception/throw =] 一个 {{TypeError}}。
                        </li>
                        <li>
                            令 |mimeType| 为对 |record| 的 <a>mediaType</a> 运行 <a>parse a MIME type</a> 返回的 <a>MIME
                                type</a>。
                        </li>
                        <li>
                            若 |mimeType| 为 failure，令 |mimeTypeRecord| 为一个新的 <a>MIME type record</a>，其 type 为
                            "`application`"，subtype 为 "`octet-stream`"。
                        </li>
                        <!--
          <li>
            If |context| is `"smart-poster"` and |mimeType| does not
            start with `"image/"` or `"video/"`, [= exception/throw =] a {{TypeError}}.
          </li>
          -->
                        <li>
                            将 |arrayBuffer| 设为 |record| 的 <a>data</a>。
                        </li>
                        <li>
                            将 |length:unsigned long| 设为 |arrayBuffer|.[[\ArrayBufferByteLength]]。
                        </li>
                        <li>
                            将 |data:byte sequence| 设为 |arrayBuffer|.[[\ArrayBufferData]]。
                        </li>
                        <li>
                            将 |ndef| 的 <a>TNF field</a> 设为 `2`（<a>MIME type</a>）。
                        </li>
                        <li>
                            将 |ndef| 的 <a>TYPE field</a> 设为以 |mimeType| 为输入 <a>serialize a MIME type</a> 的结果。
                        </li>
                        <li>
                            将 |ndef| 的 <a>PAYLOAD LENGTH field</a> 设为 |length|。
                        </li>
                        <li>
                            若 |length| > `0`，将 |ndef| 的 <a>PAYLOAD field</a> 设为 |data|。
                        </li>
                        <li>
                            返回 |ndef|。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>将 external 数据映射到 NDEF</h3>
                <div>
                    给定 |record:NDEFRecordInit|、|ndef| 和 |recordsDepth:unsigned short|，要<dfn>map external data to
                        NDEF</dfn>，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecordInit">
                        <!--
          <li>
            If |context| is `"smart-poster"`,
            [= exception/throw =] a {{TypeError}}.
          </li>
          -->
                        <li>
                            若 |record| 的 <a>mediaType</a> 不为 undefined，[= exception/throw =] 一个 {{TypeError}}。
                        </li>
                        <li>
                            令 |domain| 和 |type| 为对 |record| 的 <a>recordType</a> 运行 [=split external type=] 的结果。
                        </li>
                        <aside class="note">
                            上述步骤总能成功，因为之前已经对 external type 做过校验。
                        </aside>
                        <li>
                            令 |domain| 为对 |domain| 和 true 运行 <a
                                href="https://url.spec.whatwg.org/#concept-domain-to-ascii">
                                domain to ASCII</a> 的结果。
                        </li>
                        <aside class="note">
                            记录的 <a>recordType</a> 由用户设置并使用 UTF-8 编码，允许在自定义类型中包含国际化域名，如 "håndværker.dk:abc"。将该值写入 NDEF
                            记录时必须转换为 ASCII 字节，转换后表示为 "xn--hndvrker-9zan.dk:abc"。
                        </aside>
                        <li>
                            令 |customTypeName| 为 |domain|、"`:`" 与 |type| 连接后的结果。
                        </li>
                        <li>
                            若 |customTypeName| 不是 {{USVString}} 或其字节长度超过 255，[= exception/throw =] 一个 {{TypeError}}。
                        </li>
                        <li>
                            将 |ndef| 的 <a>TYPE field</a> 设为 |customTypeName|。
                        </li>
                        <li>
                            若 |record| 的 <a>data</a> 类型不是 {{BufferSource}} 或 {{NDEFMessageInit}}，[= exception/throw =]
                            一个 {{TypeError}}。
                        </li>
                        <li>
                            将 |ndef| 的 <a>TNF field</a> 设为 `4`（<a>external type record</a>）。
                        </li>
                        <li>
                            若 |record| 的 <a>data</a> 类型为 {{BufferSource}}，
                            <ol>
                                <li>
                                    将 |arrayBuffer| 设为 |record| 的 <a>data</a>。
                                </li>
                                <li>
                                    将 |length:unsigned long| 设为 |arrayBuffer|.[[\ArrayBufferByteLength]]。
                                </li>
                                <li>
                                    将 |data:byte sequence| 设为 |arrayBuffer|.[[\ArrayBufferData]]。
                                </li>
                                <li>
                                    将 |ndef| 的 <a>PAYLOAD LENGTH field</a> 设为 |length|。
                                </li>
                                <li>
                                    若 |length| > `0`，将 |ndef| 的 <a>PAYLOAD field</a> 设为 |data|。
                                </li>
                            </ol>
                        </li>
                        <li>
                            若 |record| 的 <a>data</a> 类型为 {{NDEFMessageInit}}，
                            <ol>
                                <li>
                                    将 |ndef| 的 <a>PAYLOAD field</a> 设为运行 <a>create NDEF message</a>（给定 |record| 的
                                    <a>data</a>、`"external"` 和 |recordsDepth|）的结果。
                                </li>
                                <li>
                                    将 |ndef| 的 <a>PAYLOAD LENGTH field</a> 设为其 <a>PAYLOAD field</a> 的长度。
                                </li>
                            </ol>
                        </li>
                        <li>
                            返回 |ndef|。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>将 local type 映射到 NDEF</h3>
                <div>
                    给定 |record:NDEFRecordInit|、|ndef|、|context:string| 和 |recordsDepth:unsigned short|，要<dfn>map local
                        type to NDEF</dfn>，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecordInit">
                        <li>
                            若 |record| 的 <a>mediaType</a> 不为 undefined，[= exception/throw =] 一个 {{TypeError}}。
                        </li>
                        <li>
                            若 |record| 的 <a>data</a> 类型不是 {{BufferSource}} 或 {{NDEFMessageInit}}，[= exception/throw =]
                            一个 {{TypeError}}。
                        </li>
                        <li>
                            将 |ndef| 的 <a>TNF field</a> 设为 `1`（[=well-known type record=]）。
                        </li>
                        <li>
                            令 |localTypeName| 为 |record| 的 <a>recordType</a> 中第一次出现 `U+003A` (`:`) 之后至末尾的部分。
                        </li>
                        <li>
                            将 |ndef| 的 <a>TYPE field</a> 设为 |localTypeName|，表示该<a>local type name</a>。
                        </li>
                        <li>
                            若 |context| 为 `"smart-poster"`，|localTypeName| 为 <strong>"`s`"（`0x73`）</strong>，且 |record| 的
                            <a>data</a> 类型不是 {{BufferSource}} 或其字节长度大于 4，[= exception/throw =] 一个 {{TypeError}}。
                        </li>
                        <li>
                            若 |context| 为 `"smart-poster"`，|localTypeName| 为 <strong>"`act`"（`0x61` `0x63`
                                `0x74`）</strong>，且 |record| 的 <a>data</a> 类型不是 {{BufferSource}} 或其字节长度不等于 1，[=
                            exception/throw =] 一个 {{TypeError}} 并中止这些步骤。
                        </li>
                        <li>
                            若 |record| 的 <a>data</a> 类型为 {{BufferSource}}，
                            <ol>
                                <li>
                                    将 |arrayBuffer| 设为 |record| 的 <a>data</a>。
                                </li>
                                <li>
                                    将 |length:unsigned long| 设为 |arrayBuffer|.[[\ArrayBufferByteLength]]。
                                </li>
                                <li>
                                    将 |data:byte sequence| 设为 |arrayBuffer|.[[\ArrayBufferData]]。
                                </li>
                                <li>
                                    将 |ndef| 的 <a>PAYLOAD LENGTH field</a> 设为 |length|。
                                </li>
                                <li>
                                    若 |length| > `0`，将 |ndef| 的 <a>PAYLOAD field</a> 设为 |data|。
                                </li>
                            </ol>
                        </li>
                        <li>
                            若 |record| 的 <a>data</a> 类型为 {{NDEFMessageInit}}，
                            <ol>
                                <li>
                                    将 |ndef| 的 <a>PAYLOAD field</a> 设为运行 <a>create NDEF message</a>（给定 |record| 的
                                    <a>data</a>、`"local"` 和 |recordsDepth|）的结果。
                                </li>
                                <li>
                                    将 |ndef| 的 <a>PAYLOAD LENGTH field</a> 设为其 <a>PAYLOAD field</a> 的长度。
                                </li>
                            </ol>
                        </li>
                        <li>
                            返回 |ndef|。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>将 smart poster 映射到 NDEF</h3>
                <div>
                    给定 |record:NDEFRecordInit|、|ndef| 和 |recordsDepth:unsigned short|，要<dfn>map smart poster to
                        NDEF</dfn>，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecordInit">
                        <li>
                            若 |record| 的 <a>mediaType</a> 不为 undefined，[= exception/throw =] 一个 {{TypeError}}。
                        </li>
                        <li>
                            若 |record| 的 <a>data</a> 类型不是 {{NDEFMessageInit}}，[= exception/throw =] 一个 {{TypeError}}。
                        </li>
                        <li>
                            将 |ndef| 的 <a>TNF field</a> 设为 `1`（[=well-known type record=]）。
                        </li>
                        <li>
                            将 |ndef| 的 <a>TYPE field</a> 设为 "`Sp`"（`0x53` `0x70`）。
                        </li>
                        <li>
                            将 |ndef| 的 <a>PAYLOAD field</a> 设为运行 <a>create NDEF message</a>（给定 |record| 的
                            <a>data</a>、`"smart-poster"` 和 |recordsDepth|）的结果。
                        </li>
                        <li>
                            将 |ndef| 的 <a>PAYLOAD LENGTH field</a> 设为其 <a>PAYLOAD field</a> 的长度。
                        </li>
                        <li>
                            返回 |ndef|。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>将 absolute-URL 映射到 NDEF</h3>
                <div>
                    给定 |record:NDEFRecordInit|、|ndef| 和 |context:string|，要<dfn>map absolute-URL to NDEF</dfn>，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            若 |context| 为 `"smart-poster"`，[= exception/throw =] 一个 {{TypeError}}。
                            <p class="note">
                                [[NDEF-SMARTPOSTER]] 规范只允许在一个 <a>smart poster</a> 中包含一个 URL，且该 URL 必须是单个 <a>URI
                                    record</a>。
                            </p>
                        </li>
                        <li>
                            若 |record| 的 <a>mediaType</a> 不为 undefined，[= exception/throw =] 一个 {{TypeError}}。
                        </li>
                        <li>
                            若 |record| 的 <a>data</a> 不是 {{DOMString}}，[= exception/throw =] 一个 {{TypeError}}。
                        </li>
                        <li>
                            若对 |record| 的 <a>data</a> 进行 <a data-lt="url parser">parsing</a> 的结果为 failure，[=
                            exception/throw =] 一个 {{SyntaxError}}。
                        </li>
                        <li>
                            将 |arrayBuffer| 设为 |record| 的 <a>data</a>。
                        </li>
                        <li>
                            将 |data:byte sequence| 设为 |arrayBuffer|.[[\ArrayBufferData]]。
                        </li>
                        <li>
                            将 |ndef| 的 <a>TNF field</a> 设为 `3`（[=absolute-URL record=]）。
                        </li>
                        <li>
                            将 |ndef| 的 <a>TYPE field</a> 设为 |data|。
                        </li>
                        <li>
                            将 |ndef| 的 <a>PAYLOAD LENGTH field</a> 设为 `0`，并省略 <a>PAYLOAD field</a>。
                        </li>
                        <li>
                            返回 |ndef|。
                        </li>
                    </ol>
                </div>
            </section>
        </section>

        <section id="making-content-read-only">
            <h3><dfn>Making content read-only</dfn></h3>
            <p>
                本节描述当某个 <a>NFC tag</a> 在近距离范围内时，如何将其永久设为只读。任一时刻，对于一个 <a>origin</a> 最多只能有一个请求，直到该 <a>NFC tag</a>
                被永久设为只读或操作被中止。
            </p>
            <section>
                <h3><strong>makeReadOnly()</strong> 方法</h3>
                <div id="steps-make-read-only">
                    当调用
                    <dfn>NDEFReader.makeReadOnly</dfn> 方法时，必须运行 <dfn>make an NFC tag permanently read-only</dfn> 算法：
                    <ol class=algorithm>
                        <li>
                            令 |p:Promise| 为一个新的 {{Promise}} 对象。
                        </li>
                        <li>
                            如果当前未在当前激活的 <a>top-level browsing context</a> 中执行，则以 {{"InvalidStateError"}} 拒绝 |p| 并返回 |p|。
                        </li>
                        <li>
                            令 |options:NDEFMakeReadOnlyOptions| 为第二个参数。
                        </li>
                        <li>
                            令 |signal:AbortSignal| 为 |options| 中同名字典成员（若存在），否则为 null。
                        </li>
                        <li>
                            若 |signal| 已被 [= AbortSignal/aborted =]，则以 |signal| 的 [=AbortSignal/abort reason=] 拒绝 |p|
                            并返回 |p|。
                        </li>
                        <li>
                            若 |signal| 非 null，则<a data-cite="dom#abortsignal-abort-algorithms">向 |signal| 添加以下中止步骤</a>：
                            <ol>
                                <li>
                                    在<a>environment settings object</a> 上运行 <a>abort a pending make read-only
                                        operation</a>。
                                </li>
                            </ol>
                        </li>
                        <li>
                            [=promise/React=] 至 |p|：
                            <ol>
                                <li>
                                    若 |p| 已 settle（履行或拒绝），则清除（若存在的）<a>pending write tuple</a>。
                                </li>
                            </ol>
                        </li>
                        <li>
                            返回 |p| 并<a>in parallel</a> 运行以下步骤：
                            <ol>
                                <li>
                                    若 <a>obtain permission</a> 步骤返回 false，则以 {{"NotAllowedError"}} 拒绝 |p| 并中止这些步骤。
                                </li>
                                <li>
                                    若不存在底层 <a>NFC Adapter</a>，或无法建立连接，则以 {{"NotSupportedError"}} 拒绝 |p| 并中止这些步骤。
                                </li>
                                <li>
                                    若 UA 不允许访问底层 <a>NFC Adapter</a>（例如用户偏好），则以 {{"NotReadableError"}} 拒绝 |p| 并中止这些步骤。
                                </li>
                                <li>
                                    实现可以（MAY）以 {{"NotSupportedError"}} 拒绝 |p| 并中止这些步骤。
                                    <p class="note">
                                        UA 可能在此时中止。终止的原因属于实现细节。例如，实现可能无法支持请求的操作。
                                    </p>
                                </li>
                                <li>
                                    尝试 <a>abort a pending make read-only operation</a>。
                                    <p class="note">
                                        一次只读化操作会替换所有先前配置的只读化操作。
                                    </p>
                                </li>
                                <li>
                                    将 <a>pending makeReadOnly tuple</a> 设为 (`this`, |p|)。
                                </li>
                                <li>
                                    每当有 <a>NFC tag</a> |device| 进入通信范围时，运行 <a>start the NFC make read-only</a> 步骤。
                                    <p class="note">
                                        若 <a>NFC is suspended</a>，继续等待，直到用户中止 promise 或某个 <a>NFC tag</a> 进入通信范围。
                                    </p>
                                </li>
                            </ol>
                        </li>
                        </li>
                    </ol>
                </div>

                <div id="steps-start-nfc-make-read-only">
                    要<dfn>start the NFC make read-only</dfn>，执行以下步骤：
                    <ol class=algorithm>
                        <li>
                            令 |p:Promise| 为 <a>pending makeReadOnly tuple</a> 的 promise。
                        </li>
                        <li>
                            若近距离范围内的 <a>NFC tag</a> 不支持用于格式化的 <a>NDEF</a> 技术，则以 {{"NotSupportedError"}} 拒绝 |p| 并返回 |p|。
                        </li>
                        <li>
                            校验<a href="#nfc-is-suspended">NFC 未被暂停</a>。
                        </li>
                        <li>
                            若成功，则执行以下步骤：
                            <ol>
                                <li>
                                    使用与 |device| 处于通信范围内的 <a>NFC adapter</a>，将 |device| 永久设为只读。
                                </li <li>
                                若操作失败，以 {{"NetworkError"}} 拒绝 |p| 并中止这些步骤。
                        </li>
                        <li>
                            当操作完成时，resolve |p|。
                        </li>
                        <p class="note">
                            此操作不可逆。一旦某个 NFC 标签被设为只读，就无法再写入。
                        </p>
                    </ol>
                    </li>
                    </ol>
                </div>
            </section>
        </section> <!-- making-content-read-only content -->

        <section>
            <h3>监听内容</h3>
            <p>
                要监听 <a>NFC content</a>，客户端必须通过调用 <a>NDEFReader.scan()</a> 激活一个 {{NDEFReader}} 实例。当在其上附加 "`reading`"
                事件的监听器时，客户端即可访问 <a>NFC content</a>。
            </p>
            <p>
                若在 <a>activated reader objects</a> 中存在任意 {{NDEFReader}} 实例，则 <a>UA</a> 必须在所有已连接的 NFC 适配器上监听 <a>NDEF
                    message</a>。
            </p>

            <section>
                <h3><strong>scan()</strong> 方法</h3>
                <p>
                    传入的 <a>NFC content</a> 会通过 {{NDEFReader}} 实例进行匹配。
                </p>
                <div>
                    当调用 <dfn>NDEFReader.scan</dfn> 方法时，UA 必须运行以下 <dfn id="steps-listen">NFC listen algorithm</dfn>：
                    <ol class=algorithm>
                        <li>
                            令 |p:Promise| 为一个新的 {{Promise}} 对象。
                        </li>
                        <li>
                            如果当前未在当前激活的 <a>top-level browsing context</a> 中执行，则以 {{"InvalidStateError"}} 拒绝 |p| 并返回 |p|。
                        </li>
                        <li>
                            令 |reader:NDEFReader| 为该 {{NDEFReader}} 实例。
                        </li>
                        <li>
                            令 |options| 为第一个参数。
                        </li>
                        <li>
                            令 |signal:AbortSignal| 为 |options| 中同名字典成员（若存在），否则为 null。
                        </li>
                        <li>
                            若 |signal| 已被 [= AbortSignal/aborted =]，则以 |signal| 的 [=AbortSignal/abort reason=] 拒绝 |p|
                            并返回 |p|。
                        </li>
                        <li>
                            若 |signal| 非 null，则<a data-cite="dom#abortsignal-abort-algorithms">向 |signal| 添加以下
                                <dfn>clean up the pending scan</dfn> 步骤</a>：
                            <ol>
                                <li>
                                    将 |reader| 自 <a>activated reader objects</a> 中移除。
                                </li>
                                <li>
                                    若 <a>activated reader objects</a> [= list/is empty =]，则请求停止在所有 <a>NFC adapter</a>
                                    上监听 <a>NDEF message</a>。
                                </li>
                            </ol>
                        </li>
                        <li>
                            返回 |p| 并<a>in parallel</a> 运行以下步骤：
                            <ol>
                                <li>
                                    若 <a>obtain permission</a> 步骤返回 false，则以 {{"NotAllowedError"}} 拒绝 |p| 并中止这些步骤。
                                </li>
                                <li>
                                    若不存在底层 <a>NFC Adapter</a>，或无法建立连接，则以 {{"NotSupportedError"}} 拒绝 |p| 并中止这些步骤。
                                </li>
                                <li>
                                    若 UA 不允许访问底层 <a>NFC Adapter</a>（例如用户偏好），则以 {{"NotReadableError"}} 拒绝 |p| 并中止这些步骤。
                                </li>
                                <li>
                                    若 |reader| 已在 <a>activated reader objects</a> 中，则以 {{"InvalidStateError"}} 拒绝 |p|
                                    并中止这些步骤。
                                </li>
                                <li>
                                    将 |reader| 添加到 <a>activated reader objects</a>。
                                </li>
                                <li>
                                    resolve |p|。
                                </li>
                                <li>
                                    每当 <a>UA</a> 检测到 NFC 技术时，运行 <a>NFC reading algorithm</a>。
                                </li>
                            </ol>
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>NFC 读取算法</h3>
                要接收 <a>NDEF</a> 内容，运行 <dfn>NFC reading algorithm</dfn>：
                <ol class=algorithm id="parse-ndef">
                    <li>
                        若 <a>NFC is suspended</a>，则中止这些步骤。
                    </li>
                    <li>
                        若近距离范围内的 <a>NFC tag</a> 不支持用于读取或格式化的 <a>NDEF</a> 技术，运行以下子步骤：
                        <ol>
                            <li>[= list/For each =]
                                {{NDEFReader}} 实例 |reader:NDEFReader| 属于 <a>activated reader objects</a>，运行以下子步骤：
                                <ol>
                                    <li>
                                        在 |reader| 上 <a>Fire an event</a> 名为 "`readingerror`"。
                                    </li>
                                </ol>
                            </li>
                            <li>
                                中止这些步骤。
                            </li>
                        </ol>
                    </li>
                    <li>
                        令 |serialNumber:serialNumber| 为设备标识符（由一系列数字组成），若不可用则为 null。
                    </li>
                    <li>
                        若 |serialNumber| 非 null，将其设为将每个数字以 <a>ASCII hex digit</a> 表示并以 U+003A（`:`）连接的<a>string</a>，顺序不变。
                    </li>
                    <li>
                        令 |message:NDEFMessage| 为一个新的 <a>NDEFMessage</a> 对象，且将 |message| 的 records 设为空<a>list</a>。
                    </li>
                    <li>
                        若近距离范围内的 <a>NFC tag</a> 未格式化但可进行 NDEF 格式化，令 |input| 为 null。否则，令 |input| 为已接收到的 <a>NDEF
                            message</a> 的表示。
                        <p class="note">
                            UA 应（SHOULD）将未格式化的 <a>NFC tag</a> 表示为一个不包含 <a>NDEF record</a> 的 <a>NDEF message</a>，即其
                            {{NDEFMessage/records}} 属性为一个空数组。
                        </p>
                    </li>
                    <li>
                        [= list/For each =] 属于 |input| 的 <a>NDEF record</a>，运行以下子步骤：
                        <ol>
                            <li>
                                令 |ndef| 为当前 <a>NDEF record</a> 的表示，其中 |typeNameField:number| 对应 <a>TNF
                                    field</a>，|payload:byte sequence| 对应 <a>PAYLOAD field</a> 数据。
                            </li>
                            <li>
                                令 |record:NDEFRecord| 为对 |ndef| 和 `""` 运行 <a>parse an NDEF record</a> 的结果。
                            </li>
                            <li>
                                若 |record| 非 null，则将 |record| <a>append</a> 到 |message| 的 records。
                            </li>
                        </ol>
                    </li>
                    <li>
                        运行 <a>dispatch NFC content</a> 步骤，给定 |serialNumber| 和 |message|。
                    </li>
                </ol>
            </section>

            <section data-link-for="NDEFReadingEvent">
                <h3>分发 NFC 内容</h3>
                <p>
                    给定类型为 <a>serialNumber</a> 的 |serialNumber:serialNumber| 和类型为 <a>NDEFMessage</a> 的
                    |message:NDEFMessage|，要<dfn>dispatch NFC content</dfn>，执行以下步骤：
                </p>
                <ol class=algorithm>
                    <li>
                        [= list/For each =] {{NDEFReader}} 实例 |reader:NDEFReader| 属于 <a>activated reader objects</a>，
                        <ol>
                            <li>
                                在 |reader| 上 <a>fire an event</a> 名为 "`reading`"，使用 <a>NDEFReadingEvent</a>，其
                                <a>serialNumber</a> 属性初始化为 |serialNumber|，<a>message</a> 属性初始化为 |message|。
                            </li>
                        </ol>
                    </li>
                </ol>
            </section>
        </section>

        <section id="steps-receiving">
            <h3>解析内容</h3>

            <section>
                <h3>从字节解析记录</h3>
                给定 |bytes:byte sequence| 和 |context: string|，要<dfn>parse records from bytes</dfn>，执行以下步骤：
                <ol class=algorithm>
                    <li>
                        若 |bytes| 的长度为 `0`，返回 null。
                    </li>
                    <li>
                        令 |records| 为空列表。
                    </li>
                    <li>
                        当 |bytes| 仍有未读字节时，运行以下子步骤：
                        <ol>
                            <li>
                                若 |bytes| 的剩余长度小于 `3`，返回 null。
                            </li>
                            <li>
                                若以下任一步骤需要读取超出 |bytes| 剩余长度的字节，返回 null。
                            </li>
                            <li>
                                令 |ndef| 为当前 <a>NDEF record</a> 的表示。
                            </li>
                            <li>
                                令 |header:byte| 为 |bytes| 的下一个字节。
                                <ol>
                                    <li>
                                        令 |messageBegin:boolean|（<a>MB field</a>）为 |header| 的最高位（位 7）。
                                    </li>
                                    <li>
                                        若这是这些子步骤的首次迭代且 |messageBegin| 为 false，返回 null。
                                    </li>
                                    <li>
                                        令 |messageEnd:boolean|（<a>ME field</a>）为 |header| 的位 6。
                                    </li>
                                    <p class=note>
                                        由于分片记录不允许作为子记录，忽略位 5（<a>CF field</a>）。
                                    </p>
                                    <li>
                                        令 |shortRecord:boolean|（<a>SR field</a>）为 |header| 的位 4。
                                    </li>
                                    <li>
                                        令 |hasIdLength:boolean|（<a>IL field</a>）为 |header| 的位 3。
                                    </li>
                                    <li>
                                        令 |ndef| 的 |typeNameField:number|（<a>TNF field</a>）为 |header| 的位 2-0 的整数值。
                                    </li>
                                </ol>
                            </li>
                            <li>
                                令 |typeLength:number| 为 |bytes| 下一个字节（<a>TYPE LENGTH field</a>）的整数值。
                            </li>
                            <li>
                                若 |shortRecord| 为 true，令 |payloadLength:number| 为 |bytes| 下一个字节（<a>PAYLOAD LENGTH
                                    field</a>）的整数值。
                            </li>
                            <li>
                                否则，令 |payloadLength| 为 |bytes| 下一个 4 个字节的整数值。
                            </li>
                            <li>
                                若 |hasIdLength| 为 true，令 |idLength:number| 为 |bytes| 下一个字节（<a>ID LENGTH
                                    field</a>）的整数值；否则令其为 `0`。
                            </li>
                            <li>
                                若 |typeLength| > 0，令 |ndef| 的 |type:string| 为对接下来的 |typeLength|（<a>TYPE field</a>）字节运行
                                <a>UTF-8 decode</a> 的结果；否则令 |type| 为空字符串。
                            </li>
                            <li>
                                若 |idLength| > 0，令 |ndef| 的 |id:string| 为对接下来的 |idLength|（<a>ID field</a>）字节运行 <a>UTF-8
                                    decode</a> 的结果；否则令 |ndef| 的 |id| 为空字符串。
                            </li>
                            <li>
                                令 |ndef| 的 |payload| 为最后 |payloadLength|（<a>PAYLOAD field</a>）字节的 <a>byte
                                    sequence</a>，该值可以为 `0` 字节。
                            </li>
                            <li>
                                令 |record:NDEFRecord| 为对 |ndef| 和 |context| 运行 <a>parse an NDEF record</a> 的结果。
                            </li>
                            <li>
                                若 |record| 非 null，将其 <a>append</a> 到 |records|。
                            </li>
                            <li>
                                若 |messageEnd| 为 true，
                                <ol>
                                    <li>
                                        若对 |records| 和 |context| 运行 <a>check parsed records</a> 抛出 |error|，则以 |error| 拒绝
                                        |promise| 并中止这些步骤。
                                    </li>
                                    <li>
                                        否则中止这些子步骤（终止循环）。
                                    </li>
                                </ol>
                            </li>
                        </ol>
                    </li>
                    <li>
                        返回 |records|。
                    </li>
                </ol>
            </section>

            <section>
                <h3>检查已解析记录</h3>
                给定 |records: NDEFRecord sequence| 和 |context: string|，要<dfn>check parsed records</dfn>，执行以下步骤：
                <ol class=algorithm>
                    <li>
                        若 |context| 为 `"smart-poster"` 且 |records| 不包含且仅包含一个 <a>URI record</a>，或其包含多于一个的 <a>type
                            record</a>、<a>size record</a> 或 <a>action record</a>，则[= exception/throw =] 一个
                        {{TypeError}}。
                    </li>
                    <!--
      <li>
        If |context| is `"smart-poster"` and |records| contain
        [=absolute-URL records=], remove them from |records|.
        <p class="note">
          In other words, remove [=absolute-URL records=] from <a>smart poster</a>,
          as required by the [[NDEF-SMARTPOSTER]] specification.
        </p>
      </li>
      <li>
        If any record in |records| is a <a>smart poster</a>, then remove
        all <a>URI records</a> and [=absolute-URL records=] from |records|.
        <p class="note">
          In other words, remove [=absolute-URL records=] and <a>URI records</a>
          from <a>NDEF messages</a> that contain a <a>smart poster</a> record,
          as required by the [[NDEF-SMARTPOSTER]] specification.
        </p>
      </li>
      -->
                    <li>
                        否则返回 true。
                    </li>
                </ol>
            </section>

            <section>
                <h3>解析 NDEF 记录</h3>
                <div>
                    给定 |ndef| 和 |context:string|，要将其解析为 |record:NDEFRecord| 的 <dfn>parse an NDEF record</dfn>，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            将 |record| 的 <a>id</a> 设为 |ndef| 的 |id:string|。
                        </li>
                        <li>
                            将 |record| 的 <a>lang</a> 设为 null。
                        </li>
                        <li>
                            将 |record| 的 <a>encoding</a> 设为 null。
                        </li>
                        <li>
                            若 |ndef| 的 |typeNameField:number|（<a>TNF field</a>）为 `0`（<a>empty record</a>）：
                            <ol>
                                <li>
                                    将 |record| 的 <a>id</a> 设为 null。
                                </li>
                                <li>
                                    将 |record| 的 <a>recordType</a> 设为 "`empty`"。
                                </li>
                                <li>
                                    将 |record| 的 <a>mediaType</a> 设为 null。
                                </li>
                                <li>
                                    将 |record| 的 <a>data</a> 设为 null。
                                </li>
                            </ol>
                        </li>
                        <li>
                            若 |ndef| 的 |typeNameField| 为 `1`（[=well-known type record=]），则
                            <ol>
                                <li>
                                    若 |ndef| 的 |type:string| 为 <strong>"`T`"（`0x54`）</strong>，将 |record| 设为对 |ndef| 运行
                                    <a>parse an NDEF text record</a> 的结果。
                                </li>
                                <li>
                                    若 |ndef| 的 |type:string| 为 <strong>"`U`"（`0x55`）</strong>，将 |record| 设为对 |ndef| 运行
                                    <a>parse an NDEF URL record</a> 的结果。
                                </li>
                                <li>
                                    若 |ndef| 的 |type:string| 为 <strong>"`Sp`"（`0x53` `0x70`）</strong>，将 |record| 设为对
                                    |ndef| 运行 <a>parse an NDEF smart-poster record</a> 的结果。
                                </li>
                                <li>
                                    若 |ndef| 的 |type:string| 为 <strong>"`s`"（`0x73`）</strong> 且 |context| 等于
                                    `"smart-poster"`，将 |record| 设为对 |ndef| 运行 <a>parse a smart-poster size record</a>
                                    的结果。
                                </li>
                                <li>
                                    若 |ndef| 的 |type:string| 为 <strong>"`t`"（`0x74`）</strong> 且 |context| 等于
                                    `"smart-poster"`，将 |record| 设为对 |ndef| 运行 <a>parse a smart-poster type record</a>
                                    的结果。
                                </li>
                                <li>
                                    若 |ndef| 的 |type:string| 为 <strong>"`act`"（`0x61` `0x63` `0x74`）</strong> 且
                                    |context| 等于 `"smart-poster"`，将 |record| 设为对 |ndef| 运行 <a>parse a smart-poster
                                        action record</a> 的结果。
                                </li>
                                <li>
                                    若对 |ndef| 的 |type:string| 运行 <a>validate local type</a> 步骤返回 true，
                                    <ol>
                                        <li>
                                            若 |context| 不是 `"external"` 或 `"smart-poster"`，[= exception/throw =] 一个
                                            {{TypeError}}。
                                        </li>
                                        <li>
                                            将 |record| 设为对 |ndef| 运行 <a>parse a local type record</a> 的结果。
                                        </li>
                                    </ol>
                                </li>
                                <li>
                                    否则 [= exception/throw =] 一个 {{TypeError}}。
                                </li>
                            </ol>
                        </li>
                        <li>
                            若 |ndef| 的 |typeNameField| 为 `2`（<a>MIME type record</a>），则将 |record| 设为对 |ndef| 运行 <a>parse
                                an NDEF MIME type record</a> 的结果，或确保底层平台为 |record| 对象的属性提供等效的值。
                        </li>
                        <li>
                            若 |ndef| 的 |typeNameField| 为 `3`（<a>absolute-URL record</a>），则将 |record| 设为对 |ndef| 运行
                            <a>parse an NDEF absolute-URL record</a> 的结果。
                        </li>
                        <li>
                            若 |ndef| 的 |typeNameField| 为 `4`（<a>external type record</a>），则将 |record| 设为对 |ndef| 运行
                            <a>parse an NDEF external type record</a> 的结果，或确保底层平台为 |record| 对象的属性提供等效的值。
                        </li>
                        <li>
                            若 |ndef| 的 |typeNameField| 为 `5`（<a>unknown record</a>），则将 |record| 设为对 |ndef| 运行 <a>parse
                                an NDEF unknown record</a> 的结果，或确保底层平台为 |record| 对象的属性提供等效的值。
                        </li>
                        <li>
                            否则 [= exception/throw =] 一个 {{TypeError}}。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>解析 NDEF well-known `T` 记录</h3>
                <div>
                    给定 |ndefRecord|，要<dfn>parse an NDEF text record</dfn> 将其解析为 |record:NDEFRecord|，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            将 |record| 的 <a>recordType</a> 设为 "`text`"。
                        </li>
                        <li>
                            将 |record| 的 <a>mediaType</a> 设为 null。
                        </li>
                        <li>
                            若 |ndefRecord| 的 <a>PAYLOAD field</a> 不存在，将 |record| 的 <a>data</a> 设为 null 并返回 |record|。
                        </li>
                        <li>
                            令 |header:byte| 为 |ndefRecord| 的 <a>PAYLOAD field</a> 的第一个 <a>byte</a>。
                        </li>
                        <li>
                            令 |languageLength:octet| 为 |header| 的位 `5` 至位 `0` 的值。
                        </li>
                        <li>
                            令 |language:string| 为对第二个 <a>byte</a> 至第 |languageLength| + `1` 个字节（含）运行 <a>ASCII decode</a>
                            的结果。
                        </li>
                        <li>
                            令 |buffer:byte sequence| 为 |ndefRecords| 的 <a>PAYLOAD field</a> 其余部分（不含 |header| 与
                            |languageLength| 数量的字节）的 <a>byte sequence</a>。
                        </li>
                        <li>
                            将 |record| 的 <a>lang</a> 设为 |language|。
                        </li>
                        <li>
                            若 |header| 的位 `7` 为 `0`，将 |record| 的 <a>encoding</a> 设为 "`utf-8`"，否则设为 "`utf-16be`"。
                        </li>
                        <li>
                            将 |record| 的 <a>data</a> 设为 |buffer|。
                        </li>
                        <li>
                            返回 |record|。
                        </li>
                    </ol> <!-- parsing NDEF text record -->
                </div>
                <aside class="note" data-link-for="NDEFRecord">
                    <p>
                        Unicode 标准定义了多种编码，如 UTF-8、UTF-16 和 UTF-32。UTF-8 是 Web 上的首选编码，它的优点是与端序无关，因为 [=code points=]
                        以单个字节表示。
                    </p>
                    <p>
                        NDEF 文本记录允许文本以 UTF-8 或 UTF-16 编码。一般而言，Web 上更推荐使用 UTF-8，但与现有系统集成时可能需要 UTF-16。
                    </p>
                    <p>
                        数据传输顺序以及 NDEF 的字节顺序在 [[[NFC-NDEF]]] 中定义为大端（BE），这意味着所有内容都以大端字节序读回。
                    </p>
                    <p>
                        对于 UTF-16，字节序很重要，因为每个 [=code point=] 占用两个字节，在读写之间可能不同。因此，UTF-16 编码的文本通常包含一个字节序标记（BOM），写作
                        `0xFEFF`。这意味着如果主机与 NDEF 的字节序不同，则将读回为 `0xFFFE`，表明应交换字节序。[[[ENCODING]]] 根据字节序区分 UTF-16 为
                        UTF-16BE（大端）和 UTF-16LE（小端）。
                    </p>
                    <p>
                        若不存在字节序标记，则应假定为 UTF-16BE 编码。
                    </p>
                    <p>
                        使用<a data-cite="encoding#decoder">decoder</a> 且 `encoding` 设为 `utf-16`
                        时，若存在字节序标记将自动检测是否需要交换字节。在没有字节序标记时可使用 `utf-16be` 按大端读取。
                    </p>
                    <p>
                        使用<a data-cite="encoding#encoder">encoder</a> 只能编码为 UTF-8，因此若需要 UTF-16，必须手动或使用库进行编码。
                    </p>
                </aside>
            </section>

            <section>
                <h3>解析 NDEF well-known `U` 记录</h3>
                <div>
                    给定 |ndefRecord|，要<dfn>parse an NDEF URL record</dfn> 将其解析为 |record:NDEFRecord|，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            将 |record| 的 <a>recordType</a> 设为 "`url`"。
                        </li>
                        <li>
                            将 |record| 的 <a>mediaType</a> 设为 null。
                        </li>
                        <li>
                            若 |ndefRecord| 的 <a>PAYLOAD field</a> 不存在，将 |record| 的 <a>data</a> 设为 null 并返回 |record|。
                        </li>
                        <li>
                            令 |buffer:byte sequence| 为 |ndefRecords| 的 <a>PAYLOAD field</a> 的 <a>byte sequence</a>。
                        </li>
                        <li>
                            令 |prefixByte:byte| 为 |buffer| 的第一个 <a>byte</a> 的值。
                        </li>
                        <li>
                            若 |prefixByte| 的值匹配 [[[NFC-STANDARDS]]] URI Record Type Definition 第 3.2.2 节 表 3 中的 URL
                            扩展代码，
                            <ol>
                                <li>
                                    令 |prefixString:string| 为与 |prefixByte| 值对应的 <a>byte sequence</a> 值。
                                </li>
                                <li>
                                    将 |record| 的 <a>data</a> 设为 |prefixString| 与 |buffer| 连接后的结果。
                                </li>
                            </ol>
                        </li>
                        <li>
                            否则，若 |prefixByte| 无匹配，则将 |record| 的 <a>data</a> 设为 |buffer|。
                        </li>
                        <li>
                            返回 |record|。
                        </li>
                    </ol> <!-- parsing NDEF URL record -->
                </div>
            </section>

            <section>
                <h3>解析 NDEF well-known `Sp` 记录</h3>
                <div>
                    给定 |ndefRecord|，要<dfn>parse an NDEF smart-poster record</dfn> 将其解析为 |record:NDEFRecord|，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            将 |record| 的 <a>recordType</a> 设为 "`smart-poster`"。
                        </li>
                        <li>
                            将 |record| 的 <a>mediaType</a> 设为 null。
                        </li>
                        <li>
                            若 |ndefRecord| 的 <a>PAYLOAD field</a> 不存在，将 |record| 的 <a>data</a> 设为 null 并返回 |record|。
                        </li>
                        <li>
                            令 |buffer:byte sequence| 为 |ndefRecords| 的 <a>PAYLOAD field</a> 的 <a>byte sequence</a>。
                        </li>
                        <li>
                            将 |record| 的 <a>data</a> 设为 |buffer|。
                        </li>
                        <li>
                            返回 |record|。
                            <p class="note">
                                应用可以对 <a>data</a> 调用 <code>toRecords()</code> 将其解析为 <a>NDEF records</a>，或自行解析。
                            </p>
                        </li>
                    </ol> <!-- parsing NDEF smart-poster record -->
                </div>
                <div>
                    给定 |ndefRecord|，要<dfn>parse a smart-poster size record</dfn> 将其解析为 |record:NDEFRecord|，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            将 |record| 的 <a>recordType</a> 设为 "`:s`"。
                        </li>
                        <li>
                            将 |record| 的 <a>mediaType</a> 设为 null。
                        </li>
                        <li>
                            若 |ndefRecord| 的 <a>PAYLOAD field</a> 不为恰好 4 字节，[= exception/throw =] 一个 {{TypeError}}。
                        </li>
                        <li>
                            令 |buffer:byte sequence| 为 |ndefRecords| 的 <a>PAYLOAD field</a> 的 <a>byte sequence</a>。
                        </li>
                        <li>
                            将 |record| 的 <a>data</a> 设为 |buffer|。
                            <p class="note">
                                应用可以将该值解析为一个 32 位无符号整数，表示 <a>smart-poster</a> 中 URI 记录所引用对象的大小。
                            </p>
                        </li>
                        <li>
                            返回 |record|。
                        </li>
                    </ol>
                </div>
                <div>
                    给定 |ndefRecord|，要<dfn>parse a smart-poster type record</dfn> 将其解析为 |record:NDEFRecord|，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            将 |record| 的 <a>recordType</a> 设为 "`:t`"。
                        </li>
                        <li>
                            将 |record| 的 <a>mediaType</a> 设为 null。
                        </li>
                        <li>
                            令 |buffer:byte sequence| 为 |ndefRecords| 的 <a>PAYLOAD field</a> 的 <a>byte sequence</a>。
                            <p class="note">
                                应用可以将该值解析为一个字符串，包含 [[RFC2048]] 媒体类型，表示 <a>smart-poster</a> 中 URI 记录所引用对象的媒体类型。
                            </p>
                        </li>
                        <li>
                            将 |record| 的 <a>data</a> 设为 |buffer|。
                        </li>
                        <li>
                            返回 |record|。
                        </li>
                    </ol>
                </div>
                <div>
                    给定 |ndefRecord|，要<dfn>parse a smart-poster action record</dfn> 将其解析为 |record:NDEFRecord|，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            将 |record| 的 <a>recordType</a> 设为 "`:act`"。
                        </li>
                        <li>
                            将 |record| 的 <a>mediaType</a> 设为 null。
                        </li>
                        <li>
                            若 |ndefRecord| 的 <a>PAYLOAD field</a> 不为恰好 1 字节，[= exception/throw =] 一个 {{TypeError}}。
                        </li>
                        <li>
                            令 |buffer:byte sequence| 为 |ndefRecords| 的 <a>PAYLOAD field</a> 的 <a>byte sequence</a>。
                        </li>
                        <li>
                            将 |record| 的 <a>data</a> 设为 |buffer|。
                            <p class="note">
                                应用可以将该值解析为一个 8 位无符号整数，其取值定义见<a href="#dfn-action-record">此处</a>。
                            </p>
                        </li>
                        <li>
                            返回 |record|。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>解析 local type 记录</h3>
                <div>
                    给定 |ndef|，要<dfn>parse a local type record</dfn> 将其解析为 |record:NDEFRecord|，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            将 |record| 的 <a>recordType</a> 设为 "`:`"（`U+003A`）与 |ndef| 的 |type:string| 连接后的结果。
                        </li>
                        <li>
                            将 |record| 的 <a>mediaType</a> 设为 null。
                        </li>
                        <li>
                            令 |buffer:byte sequence| 为 |ndefRecords| 的 <a>PAYLOAD field</a> 的 <a>byte sequence</a>。
                        </li>
                        <li>
                            将 |record| 的 <a>data</a> 设为 |buffer|。
                        </li>
                        <li>
                            返回 |record|。
                        </li>
                    </ol>
                </div>
            </section>

            <section>
                <h3>解析 NDEF MIME type 记录</h3>
                <div>
                    给定 |ndefRecord|，要<dfn>parse an NDEF MIME type record</dfn> 将其解析为 |record:NDEFRecord|，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            将 |record| 的 <a>recordType</a> 设为 "`mime`"。
                        </li>
                        <li>
                            将 |record| 的 <a>mediaType</a> 设为以 |mimeType| 为输入 <a>serialize a MIME type</a> 的结果。
                        </li>
                        <li>
                            令 |buffer:byte sequence| 为 |ndefRecords| 的 <a>PAYLOAD field</a> 的 <a>byte
                                sequence</a>（若存在），否则为 null。
                        </li>
                        <li>
                            将 |record| 的 <a>data</a> 设为 |buffer|。
                        </li>
                        <li>
                            返回 |record|。
                        </li>
                    </ol> <!-- parsing NDEF MIME type record -->
                </div>
            </section>

            <section>
                <h3>解析 NDEF absolute-URL 记录</h3>
                <div>
                    给定 |ndefRecord|，要<dfn>parse an NDEF absolute-URL record</dfn> 将其解析为 |record:NDEFRecord|，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            将 |record| 的 <a>recordType</a> 设为 "`absolute-url`"。
                        </li>
                        <li>
                            将 |record| 的 <a>mediaType</a> 设为 null。
                        </li>
                        <li>
                            令 |buffer:byte sequence| 为 |ndefRecords| 的 <a>TYPE field</a> 的 <a>byte sequence</a>。
                        </li>
                        <li>
                            将 |record| 的 <a>data</a> 设为 |buffer|。
                        </li>
                        <li>
                            返回 |record|。
                        </li>
                    </ol> <!-- parsing NDEF absolute URI record -->
                </div>
            </section>

            <section>
                <h3>解析 NDEF external type 记录</h3>
                <div>
                    给定 |ndefRecord|，要<dfn>parse an NDEF external type record</dfn> 将其解析为 |record:NDEFRecord|，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            若对记录的 |ndefRecord| 的 <a>TYPE field</a> 运行 [=validate external type=] 返回 false，返回 null。
                        </li>
                        <li>
                            令 |domain| 和 |type| 为以 |ndefRecord| 的 <a>TYPE field</a> 的值运行 [=split external type=] 的结果。
                        </li>
                        <li>
                            令 |domain| 为运行 <a href="https://www.unicode.org/reports/tr46/#ToUnicode">Unicode
                                ToUnicode</a> 的结果，参数为
                            |domain_name|=|domain|、|CheckHyphens|=false、|CheckBidi|=true、|CheckJoiners|=true、|UseSTD3ASCIIRules|=true、|Transitional_Processing|=false。若结果包含任何错误，返回
                            null。
                        </li>
                        <aside class="note">
                            <a>TYPE field</a> 包含以 ASCII 存储的域名部分，例如 "xn--hndvrker-9zan.dk:abc" 经过上述转换后会呈现为
                            "håndværker.dk:abc"。
                        </aside>
                        <li>
                            将 |record| 的 <a>recordType</a> 设为 |domain|、"`:`" 与 |type| 连接后的结果。
                        </li>
                        <li>
                            将 |record| 的 <a>mediaType</a> 设为 null。
                        </li>
                        <li>
                            令 |buffer:byte sequence| 为 |ndefRecords| 的 <a>PAYLOAD field</a> 的 <a>byte
                                sequence</a>（若存在），否则为 null。
                        </li>
                        <li>
                            将 |record| 的 <a>data</a> 设为 |buffer|。
                        </li>
                        <li>
                            返回 |record|。
                        </li>
                    </ol> <!-- parsing NDEF external type record -->
                </div>
            </section>

            <section>
                <h3>解析 NDEF unknown type 记录</h3>
                <div>
                    给定 |ndefRecord|，要<dfn>parse an NDEF unknown record</dfn> 将其解析为 |record:NDEFRecord|，执行以下步骤：
                    <ol class=algorithm data-link-for="NDEFRecord">
                        <li>
                            将 |record| 的 <a>recordType</a> 设为 "`unknown`"。
                        </li>
                        <li>
                            将 |record| 的 <a>mediaType</a> 设为 null。
                        </li>
                        <li>
                            令 |buffer:byte sequence| 为 |ndefRecords| 的 <a>PAYLOAD field</a> 的 <a>byte
                                sequence</a>（若存在），否则为 null。
                        </li>
                        <li>
                            将 |record| 的 <a>data</a> 设为 |buffer|。
                        </li>
                        <li>
                            返回 |record|。
                        </li>
                    </ol> <!-- parsing NDEF unknown record -->
                </div>
            </section>
        </section>
    </section>

    <!-- - - - - - - - - - - - - - - The Blocklist - - - - - - - - - - - - - - - -->
    <section>
        <h2 id="blocklist">阻止列表</h2>
        <p>
            本规范依赖一个阻止列表文件来限制网站可访问的 NFC 设备集合。
        </p>
        <p>
            在 |url:URL| 处<dfn>解析阻止列表</dfn>的结果是一个历史字节十六进制值的列表，由以下算法生成：
        <ol class=algorithm>
            <li>
                获取 |url:URL|，并令 |contents:string| 为其主体，按 UTF-8 解码。
            </li>
            <li>
                令 |lines:array| 为将 |contents| 按 `"\n"` 分割得到的结果。
            </li>
            <li>
                令 |result:list| 为一个空的<a>list</a>。
            </li>
            <li>
                [= list/For each =] |line:string| in |lines|，执行以下子步骤：
                <ol>
                    <li>
                        若 |line| 为空，继续处理下一行。
                    </li>
                    <li>
                        若 |line| 以 `"#"` 开头，继续处理下一行。
                    </li>
                    <li>
                        若 |line| 包含无效的十六进制值，继续处理下一行。
                    </li>
                    <li>
                        <a>Append</a> |line| 到 |result|。
                    </li>
            </li>
        </ol>
        </li>
        <li>
            返回 |result|。
        </li>
        </ol> <!-- parsing the blocklist -->
        </p>
        <p>
            <dfn>blocklist</dfn> 是在
            <a
                href="https://github.com/w3c/web-nfc/blob/gh-pages/blocklist.txt">https://github.com/w3c/web-nfc/blob/gh-pages/blocklist.txt</a>
            处<a>parsing the blocklist</a> 的结果。UA 应定期重新获取阻止列表，但获取频率未作规定。
        </p>
        <p>
            若 <a>blocklist</a> 的值包含某设备的 <a>historical bytes</a> 十六进制值，则该 <a>NFC device</a> 被视为 <dfn>blocklisted</dfn>。在
            ISO 14443-4 术语中，<dfn>historical bytes</dfn> 是 RATS（Request for Answer To Select）响应的一个子集。
        </p>
    </section>

    <!-- - - - - - - - - - - - - Security and Privacy - - - - - - - - - - - - - -->
    <section>
        <h2 id="security">安全与隐私</h2>
        <section>
            <h3>信任链</h3>
            <p>
                实现需要确保当用户授权 Web NFC API 的某个方法时，只执行该操作且无任何副作用。
            </p>
            <p>
                默认情况下，NDEF 并不提供使内容被信任的机制，除了允许在写入数据后将标签永久设为只读。这甚至可以在工厂设置中完成。
            </p>
            <p>
                通过此 API 写入的数据不会自动签名或加密，这与现有原生 NFC API 一致。为保护 NDEF 消息的完整性与真实性，NFC 论坛引入了 [[NDEF-SIGNATURE]]。使用 <a>NDEF
                    signature</a> 和密钥管理由应用自行负责。
            </p>
            <p>
                若要信任通过 NFC 交换的数据的<strong>机密性</strong>，应用可以使用加密的 <a>NFC content</a>。
            </p>
            <p>
                若要信任通过 NFC 交换的数据的<strong>完整性</strong>，应用可以使用 <a>NDEF signature</a>，并基于公钥基础设施（PKI）进行密钥管理。
            </p>
            <p>
                关于 MIME 类型的一般安全注意事项见 [[RFC2048]] 和 [[RFC2046]]。
            </p>
        </section>
        <section>
            <h3>隐私影响与实现考量</h3>
            <p>
                与条形码或二维码的比较是恰当的，因为 NFC 标签是另一种非人可读的数据交换方式，共享它们可能带来意想不到的隐私与安全影响。网站读取二维码时，必须使用打断式
                UI（相机）来拍摄图像，使用户清楚该图像（包括二维码）的内容将可供网页使用，从而明确告知用户正在进行扫描。
            </p>
            <p>
                使用 NFC 扫描标签需要用户将扫描设备（如手机）置于 NFC 标签的近距离范围内——通常为 5-10 厘米（2-4 英寸）。
            </p>
            <p>
                当未激活 Web NFC 扫描时扫描标签，会触发主机操作系统处理。因此，从 NFC 标签扫描并启动 URL 或应用并非由 Web NFC 自身处理或支持。
            </p>
            <p>
                此外，Web NFC 的扫描需要由用户交互触发，且当网站不在焦点或设备屏幕熄灭（即设备未解锁）时，扫描会被暂停。这样设计是为了降低偶发扫描的可能性。
            </p>
            <p>
                Web NFC 还建议实现从用户体验角度（UX）清晰告知：当把扫描设备靠近 NFC 标签时会进行数据扫描——基本上模仿扫描二维码的 UX 流程。
            </p>
            <p>
                可采用多种方式实现，例如播放提示音，或在扫描可能发生时显示持续的 UI，比如带有随时可取消能力的模态对话框。
            </p>
            <img class="illustration" src="https://w3c.github.io/web-nfc/images/scan.jpg">
            <p>
                实现还可以显示即将上传的数据，推迟数据分享直到用户确认，甚至显示允许用户选择要分享的记录的 UI。
            </p>
            <img class="illustration" src="https://w3c.github.io/web-nfc/images/approve.jpg">
            <section>
                <h4>扫描期间的读写</h4>
                <p>
                    当用户扫描标签时，网页应用可读取标签上的数据；若其不是只读，也可以向标签写入数据。面向私人使用的消费者贴纸（例如创客社区）通常是未上锁的（可读+可写），而商业部署的 NFC 通常是只读的。
                </p>
                <p class="note">
                    旧协议 SNEP（Simple NDEF Exchange Protocol）允许有源设备（如手机）从另一有源设备接收 NDEF 数据，但 Web NFC 不支持它，且在受支持的原生平台上也在被弃用。
                </p>
                <p class="note">
                    新协议 TNEP（Tag NDEF Exchange Protocol）允许扫描设备（如手机）与主动供电的设备（如 IoT 设备）进行双向通信。Web NFC
                    目前不支持它，且该协议对可接受的输入有限制，IoT 设备必须确保所接受的记录有效。
                </p>
                <p>
                    如果标签包含隐私敏感数据，则该数据会被分享给站点。如果 UX 要求用户在执行前确认数据交换，则可能不会立即分享。
                </p>
                <p>
                    某些情况下，标签/设备包含隐私敏感数据是显而易见的，例如配备 NFC 的会议胸牌和名片。又如配备 NFC 的血糖仪，可能表明你或近亲为糖尿病患者。
                </p>
                <p>
                    其他情况下，这一点可能不明显，但用户可能曾使用应用或网站向标签写入数据，而该数据在用户不知情的情况下编码了用户 ID 等信息，之后任何其他站点都可能读取到。
                </p>
                <p>
                    私密和意外的数据也可能存储在文件中（例如文字处理文档、PDF 或相机图像），并通过文件上传 API 上传。与文件上传相比，Web NFC API 所采用的缓解措施更强，且数据更不可能与个人直接关联。
                </p>
            </section>
            <section>
                <h4>扫描期间的读写</h4>
                <p>
                    对标签的扫描还可能暴露用户位置——若网站能够识别标签并知道该标签在现实世界中的位置（例如安装在博物馆内部）。也可能通过某些线索推断位置，例如 FeliCa NFC 标签多用于日本，但 Web NFC
                    并不会透露所用的标签技术。
                </p>
                <p>
                    这并不会把网络广告与跟踪模型带入现实世界，因为这需要用户的操作，且不能在后台触发；通过良好的 UX 应清楚地表明扫描处于激活状态。
                </p>
            </section>
            <section>
                <h4>覆盖现有数据</h4>
                <p>
                    还存在担忧：向 NFC 标签写入可能损坏或“变砖”。由于 NFC 标签被设计为可由多个用户应用读取，NDEF 标签提供了便捷方式可将设备永久设为只读，甚至可在工厂中配置为只读。
                </p>
                <p>
                    NDEF 是用于读写数据的简单交换格式，而非双向通信。NFC 支持多种基于更低层技术的通信格式（因此不像 NDEF 那样被锁定为只读），且这些格式均不受 Web NFC 支持。
                </p>
            </section>
        </section>

        <section>
            <h3>使用 NFC 时应告知用户的事项</h3>
            <p>
                本节列出用户在使用 NFC 时应当了解的一些事项。建议实现方在执行相关 NFC 操作之前或期间，帮助用户了解这些事实。
            </p>
            <h4>读取的数据会与站点共享</h4>
            <p>
                当站点有权读取 NFC 内容时，被扫描标签的数据将与该站点共享，类似上传文件和图片。与任何站点一样，是否信任站点以适当、预期的方式处理这些数据取决于用户。
            </p>
            <h4>站点可能修改并覆盖未设为只读的标签数据</h4>
            <p>
                已部署的 NFC 方案（例如商店中的标签）应始终设为只读，以确保不会因错误或恶意行为而被修改。
            </p>
            <p>
                私人标签和贴纸往往出厂即未上锁（可写），用户应意识到此类标签在被扫描时可能被覆盖/修改。
            </p>
            <h4>读取固定（例如已安装）标签可能暴露读取位置</h4>
            <p>
                固定标签可能在数据中编码其 ID 或位置，这意味着读取该标签会将此信息暴露给知道该标签物理位置的站点，从而推断读取发生的位置。这与登录某项服务相结合，可能将你的位置信息分享给该站点。
            </p>
            <p>
                写入的数据可被其他具有读取权限的应用和站点读取。任何标签上的 NDEF 数据都可被具有相应访问权限的任何应用或网站读取，因此若不希望如此，数据应以安全方式加密，使仅有被授权者能够读取。
            </p>
            <h4>读取场内可能同时存在多个标签</h4>
            <p>
                NFC 一次只能读取一个标签，但可以检测到多个标签，并可在其中选择一个进行通信。
            </p>
            <p>
                这类用例包括：钱包中有多张智能卡（基于 NFC），但不想把卡取出。
            </p>
            <p>
                这主要适用于由外部硬件读取的支付卡和交通卡，因此不是 Web NFC 的用例。对于 Web NFC，当存在多个可用标签时我们不允许读取，以防以下攻击向量。
            </p>
            <p>
                存在一种攻击向量：有人将另一个恶意 NFC 标签/贴纸覆盖在合法标签上，以加载错误的应用/站点，或向正确的应用/站点注入错误数据。他们可以通过克隆原标签数据并加以修改来实现——要么将 URL
                改为加载恶意应用/站点，要么更改数据以向正确的应用/站点注入恶意数据。示例：标签本应带你访问 <code>https://example.com</code> 却被修改为
                <code>https://exаmple.com</code>（其中包含西里尔字母 а）——看起来很像真的，你可能会向恶意站点提供敏感数据。
            </p>
            <p>
                从标签加载网站不在 Web NFC 的范围内，但建议用户代理在存在多个标签时不要自动加载 URL，以避免上述攻击向量。
            </p>
            <p>
                通过在存在多个标签时禁止读取，Web NFC 能较好地防止向站点注入错误/恶意数据，因为屏蔽现有 NFC 标签相当困难，需要铁氧体屏蔽且较为明显。金属会干扰磁场，使标签不可读。
            </p>
        </section>

        <section class="informative">
            <h2>资产</h2>
            <div>
                需要保护的资产包括：
                <ul>
                    <li>
                        <strong>NDEF message</strong> 作为整体，尤其是其中的 <strong>NDEF records</strong>（包括载荷与头部），无论在传输中还是在存储中，在被
                        Web NFC 触发的操作覆盖时，都需要防止数据泄露与数据修改。这也包括对使用 NFC 标签部署的方案的拒绝服务攻击（例如恶意行为者破坏与方案关联的标签）。
                    </li>
                    <li>
                        可由使用 Web NFC 的 <a>NFC content</a>
                        创建者或网站直接或间接确定的<strong>用户身份或其他隐私敏感属性</strong>。这些数据可能被直接使用或泄露给第三方。例如用户位置、设备标识符和用户标识符。
                    </li>
                    <li>
                        暴露给使用 Web NFC 的网页的<strong>用户数据</strong>。尽管网页可能通过 Web NFC 以外的方式收集用户数据，但也可能将这些数据嵌入 NDEF 记录并通过 Web
                        NFC 共享。
                    </li>
                    <li>
                        <strong>用户设备的完整性</strong>。对 NFC 标签的读取可能导致用户设备被攻陷，进而导致丢失其他 Web NFC 或平台资产。
                    </li>
                </ul>
            </div>
        </section>

        <section class="informative">
            <h2>攻击者模型</h2>
            <p>
                已考虑以下攻击者模式：
            <ul>
                <li>
                    <strong>恶意网页创建者</strong>：钓取用户数据、身份或其他隐私敏感属性，破坏或修改 NFC 标签，以虚假身份与攻击向量造成进一步危害。
                </li>
                <li>
                    <strong>恶意 NFC 标签创建者</strong>：与上述相同，但还可能在本地创建、删除或修改 NFC
                    标签。其结果可能破坏用户设备完整性、导致数据注入、重定向至恶意网页、钓取用户位置，触发安装应用等附带操作、触发自动分发或其他行为。
                </li>
                <li>
                    <strong>设备或用户代理被攻陷：中间人（MITM）攻击</strong>：在 Web NFC 实现与用户设备中的 <a>NFC adapter</a> 之间的任何 MITM
                    式攻击，包括通过展示被修改或重放的 NDEF 记录来尝试与使用 Web NFC 的网站交互。
                </li>
            </ul>
            </p>
        </section>

        <section class="informative">
            <h3>威胁</h3>
            <p>
                NFC 安全简介见<a
                    href="https://resources.infosecinstitute.com/near-field-communication-nfc-technology-vulnerabilities-and-principal-attack-schema/">此处</a>。Web
                NFC 的潜在威胁如下。
            </p>

            <section>
                <h4>指纹识别与数据收集</h4>
                <dl>
                    <dt><strong>威胁描述</strong></dt>
                    <dd>
                        恶意网页在未经用户同意的情况下收集用户数据、身份或其他隐私敏感属性（如位置），并将其暴露给第三方（将其写入 NFC 标签）。
                    </dd>
                    <dt><strong>受影响资产</strong></dt>
                    <dd>
                        用户数据、用户身份或其他隐私敏感属性
                    </dd>
                    <dt><strong>参与者</strong></dt>
                    <dd>
                        使用 Web NFC 的恶意网页所有者、恶意标签所有者。
                    </dd>
                    <dt><strong>缓解措施与说明</strong></dt>
                    <dd>
                        应（SHOULD）使用户能够了解该网页可通过 NFC 分享哪些数据。使用权限与用户提示来访问个人数据，最小化暴露给 NFC 的用户数据。NFC 标签不应（SHOULD
                        NOT）在未经许可的情况下触发用户设备导航至网站，除非该站点已经在前台或被带到前台并已获授权。用户代理应（SHOULD）参考
                        <a href="http://dev.w3.org/geo/api/spec-source.html#security">
                            地理定位 API</a> 中列出的安全与隐私措施。
                    </dd>
                </dl>
            </section>

            <section>
                <h4>NFC 标签被修改</h4>
                <dl>
                    <dt><strong>威胁描述</strong></dt>
                    <dd>
                        NFC 标签在未经用户同意的情况下被修改，甚至通过设为只读而不可逆。这可能使后续攻击成为可能（使用恶意标签），或成为拒绝服务攻击使一个或多个标签不可用。
                    </dd>
                    <dt><strong>受影响资产</strong></dt>
                    <dd>
                        存储中的 NDEF 消息记录，包括载荷与头部。
                    </dd>
                    <dt><strong>参与者</strong></dt>
                    <dd>
                        恶意网页创建者、恶意用户。
                    </dd>
                    <dt><strong>缓解措施与说明</strong></dt>
                    <dd>
                        写入标签与将其设为只读应当要求权限与用户确认。或者，限制某网页可写入的标签，例如仅允许写入可与其 <a>origin</a>
                        关联的标签。又或者，允许覆盖，因为不应被写入的标签可通过设为只读进行保护。使用 <a>NDEF signature</a> 来检测 NFC 标签的修改。
                    </dd>
                </dl>
            </section>

            <section>
                <h4>传输中的 NDEF 记录被修改</h4>
                <dl>
                    <dt><strong>威胁描述</strong></dt>
                    <dd>
                        在 Web NFC 与 <a>NFC adapter</a> 和用户设备之间传输的 <a>NDEF record</a>
                        被修改，用以实施多种中间人攻击或拒绝服务（DoS）攻击。同时，<a>NDEF signature</a> 记录也可能被移除或替换，并配合修改的内容。
                    </dd>
                    <dt><strong>受影响资产</strong></dt>
                    <dd>
                        传输中的 <a>NDEF record</a>。
                    </dd>
                    <dt><strong>参与者</strong></dt>
                    <dd>
                        恶意中间人用户。
                    </dd>
                    <dt><strong>缓解措施与说明</strong></dt>
                    <dd>
                        此威胁超出 Web NFC 实现的范围。应用可以使用 <a>NDEF signature</a> 与适当的工具（签名算法、证书、安全策略）来保护 <a>NFC
                            content</a>。此外，加固平台栈。
                    </dd>
                </dl>
            </section>

            <section>
                <h4>NDEF 记录载荷泄露</h4>
                <dl>
                    <dt><strong>威胁描述</strong></dt>
                    <dd>
                        存储在 NFC 标签上的或在 Web NFC 与 <a>NFC adapter</a> 之间传输的 <a>NDEF record</a> 机密载荷被未授权方读取。
                    </dd>
                    <dt><strong>受影响资产</strong></dt>
                    <dd>
                        传输与存储中的机密 NDEF 消息载荷。
                    </dd>
                    <dt><strong>参与者</strong></dt>
                    <dd>
                        恶意中间人用户、恶意网页创建者。
                    </dd>
                    <dt><strong>缓解措施与说明</strong></dt>
                    <dd>
                        为确保机密性，应使用载荷加密与安全通信来进行数据交换、认证与授权（在 Web NFC 与 <a>NFC adapter</a> 之间）。
                    </dd>
                </dl>
            </section>

            <section>
                <h4>通过恶意 NFC 标签的主动攻击</h4>
                <dl>
                    <dt><strong>威胁描述</strong></dt>
                    <dd>
                        恶意标签可能被设备非自愿或自愿地读取，读取的数据可能构成对用户代理的攻击向量。例如，它可能尝试在设备上触发某个操作（这可能有风险），如打开恶意网站，或打开为攻击设备而准备的图片。
                    </dd>
                    <dt><strong>受影响资产</strong></dt>
                    <dd>
                        用户设备的完整性及所有其他 Web NFC 资产。
                    </dd>
                    <dt><strong>参与者</strong></dt>
                    <dd>
                        恶意标签创建者。
                    </dd>
                    <dt><strong>缓解措施与说明</strong></dt>
                    <dd>
                        这是所有现有 NFC
                        标签的通用问题。数据被视为应用特定。实现需要进行安全加固。由于近距离与读取需特定角度，且需焦点要求，非自愿触碰的概率很低。不应允许针对智能海报和其他标签的自动操作。必须让用户知情，并赋予其控制
                        NFC 通信期间发生事件的能力。例如，从 <a>smart poster</a> 打开内容、通过 <a>NFC handover</a> 自动连接（可能是恶意的）WiFi
                        等。不允许来自不受信任的 NFC 标签的操作；可通过 <a>NDEF signature</a> 检查建立信任。
                    </dd>
                </dl>
            </section>
        </section>

        <section class="informative">
            <h2>实现的安全机制</h2>
            <section>
                <h3><dfn>Obtaining permission</dfn></h3>
                <p>
                    实现应（SHOULD）使用一种机制来 <a>obtain permission</a>，例如由用户显式授予的权限。建议 UA 使用 [[[PERMISSIONS]]] API 来实现与 NFC
                    相关的权限。
                </p>
                <p>
                    实现可（MAY）使用按会话/临时权限。
                </p>
            </section>
            <section>
                <h3><dfn>Warning user during NFC operations</dfn></h3>
                <p>
                    实现可（MAY）在网页正在访问 NFC 适配器（例如存在进行中的扫描）时显示覆盖式对话框，以提醒用户。
                </p>
            </section>
        </section>
        <section class="informative">
            <h2>应用的安全机制</h2>
            <section>
                <h3>加密 <a>NFC content</a></h3>
                <p>
                    为信任通过 NFC 交换的数据的机密性，应用可以使用基于公钥基础设施（PKI）进行密钥管理的加密 <a>NFC content</a>。密钥管理不在 Web NFC 的范围内。
                </p>
            </section>

            <section>
                <h3>为 NDEF 记录签名</h3>
                <p>
                    为信任通过 NFC 交换的数据的完整性，用户代理可（MAY）使用基于公钥基础设施的 <a>NDEF signature</a> 进行密钥管理。
                </p>
                <p>
                    对于使用 <a>NDEF signature</a> 1.0 版本（[[NFC-SECURITY]]）签名的标签，其签名仅覆盖 <a>TYPE field</a>、<a>ID field</a> 与
                    <a>PAYLOAD field</a>，未覆盖 NDEF 头部的第一个字节，从而留下攻击面。[[NFC-SECURITY]] 的 2.0 版本将标签硬件属性纳入签名并允许使用更短的证书。
                </p>
                <p>
                    一个 <a>NDEF signature</a> 覆盖其之前的记录，直到遇到另一个 <a>NDEF signature</a> 或消息起始（<a>NDEF message</a> 的开头）。
                </p>
                <p>
                    为缓解 <a
                        href="https://www.researchgate.net/publication/224227216_Security_Vulnerabilities_of_the_NDEF_Signature_Record_Type">
                        已知漏洞</a>，建议应用始终使用单个 <a>NDEF signature</a> 为整个 <a>NDEF message</a> 签名，并使用正确的工具链与安全策略来创建与验证签名。
                </p>
            </section>

        </section>

        <section>
            <h3>安全策略</h3>
            <p>
                本节列出实现的规范性安全策略。
            </p>

            <section>
                <h4>安全上下文</h4>
                <p>
                    只有<a>secure contexts</a>才允许访问 <a>NFC content</a>。浏览器可（MAY）仅为开发目的而忽略此规则。
                </p>
            </section>

            <section>
                <h4>可见文档</h4>
                <p>
                    Web NFC 功能仅允许用于 <a>top-level browsing context</a> 的 {{Document}}，且其 {{Document/visibilityState}} 为
                    `"visible"`。
                </p>
                <p>
                    这也意味着，当显示关闭或设备锁定时，UA 应阻止对 NFC 射频的访问。对于在后台的网页，接收与写入 <a>NFC content</a> 必须被<a
                        id="#nfc-suspended">suspended</a>。
                </p>
            </section>

            <section>
                <h4>权限控制</h4>
                <p>
                    将 <a>NFC tag</a> 永久设为只读必须（MUST）<a>obtain permission</a>，否则失败。见 [[[#making-content-read-only]]] 一节。
                </p>
                <p>
                    设置用于读取 <a>NFC content</a> 的监听器应当（SHOULD）<a>obtain permission</a>。
                </p>
                <p>
                    将 <a>NFC content</a> 写入 <a>NFC tag</a> 必须（MUST）<a>obtain permission</a>。见 [[[#writing-content]]] 一节。
                </p>
                <p>
                    所有超出当前浏览会话而被保留的权限必须（MUST）可被撤销。
                </p>
            </section>

            <section>
                <h4>阻止列表</h4>
                <p>
                    Web NFC 包含一个 <a>blocklist</a>，用于阻止存在漏洞的 NFC 设备被网站利用。
                </p>
            </section>

            <section>
                <h4>警示物理位置泄露风险</h4>
                <p>
                    在监听与写入 <a>NFC content</a> 时，UA 可（MAY）警示用户：给定的 <a>origin</a> 可能能够推断物理位置。
                </p>
            </section>

            <section>
                <h4>限制自动处理</h4>
                <p>
                    当 <a>NFC content</a> 的载荷数据不受信任时，UA 不得（MUST NOT）使用其自动处理内容，例如自动打开 <a>NFC tag</a> 中发现的 URL
                    所指向的网页、安装应用或执行其他操作，除非用户批准。
                </p>
            </section>

            <section>
                <h4>对 <a>NFC content</a> 进行签名</h4>
                <div>
                    建议应用实现以下策略：
                    <ul>
                        <li>
                            仅当 <a>smart poster</a> 使用同一发行方的单个 <a>NDEF signature</a> 记录签名，且它是消息中的第一条记录，或它之前有另一条 <a>NDEF
                                signature</a> 时，才可被信任（MAY）。
                        </li>
                        <li>
                            仅当 <a>NDEF message</a> 使用同一发行方的单个 <a>NDEF signature</a> 记录签名时，才可被信任（MAY）。
                        </li>
                        <li>
                            用户代理在不验证的情况下暴露 <a>NDEF signature</a> 记录。验证签名与对 <a>NFC content</a> 进行签名是应用的责任。
                        </li>
                        <li>
                            应（SHOULD）使用适当的签名算法、证书与安全策略来创建与验证 <a>NDEF signature</a>。同时考虑对 <a>NDEF signature</a>
                            的已知攻击，例如移除 <a>NDEF signature</a>、连同修改 <a>NFC content</a> 一并替换 <a>NDEF signature</a>、通过改变记录的
                            <a>PAYLOAD LENGTH field</a> 来重排记录等。
                        </li>
                    </ul>
                </div>
            </section>
            <!-- TODO: add later
    <p class="note">
      For Bluetooth and WiFi handover (supported in later versions),
      the user should have to grant access to the secondary API and must be
      able to properly understand what they are granting.
    </p>
    -->
        </section> <!-- Policies -->
    </section> <!-- Security and Privacy  -->

    <section id="idl-index" class="appendix">
        <!-- All the Web IDL will magically appear here -->
    </section>

    <!-- - - - - - - - - - - - - - - Acknowledgments - - - - - - - - - - - - - -->
    <section>
        <h2>致谢</h2>
        <p>
            编辑谨此感谢 Jeffrey Yasskin、Anne van Kesteren、Anssi Kostiainen、Domenic Denicola、Daniel Ehrenberg、Jonas
            Sicking、Don Coleman、Salvatore Iovene、Rijubrata Bhaumik、Wanming Lin、Han Leon、Ryan Sleevi、Balázs
            Engedy、Theodore Olsauskas-Warren、Reilly Grant、Diego González 和 Daniel Appelquist 对本文档的贡献。
        </p>
        <p>
            特别感谢 Luc Yriarte 和 Samuel Ortiz 在将 NFC 暴露给 Web 平台方面的初期<a
                href="https://github.com/w3c/nfc">work</a>，以及他们对当前方法的支持。同时，特别感谢 Elena Reshetova 对“安全与隐私”章节的贡献。
        </p>
    </section>

</body>

</html>