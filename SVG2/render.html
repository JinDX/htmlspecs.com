<!DOCTYPE html>

<!--
  Scalable Vector Graphics (SVG) 2
  Chapter 3: Rendering Model

  Note: This document is generated from ../master/render.html.
  Run "make" from the root of the repository to regenerate it.
  -->

<html lang="zh-hans" xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta charset="UTF-8">
    <title>渲染模型 — SVG 2</title>

    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <!-- Style sheets for local dev. Will be standardized in processing.
  Add attribute data-keep="" to any extra stylesheet link you do not want removed
  (or use <style>), and include it before here. -->


    <link rel="stylesheet" title="Default" href="https://www.w3.org/TR/SVG2/style/svg.css" type="text/css"
        media="screen">
    <link rel="alternate stylesheet" title="Only annotations for publication"
        href="https://www.w3.org/TR/SVG2/style/default_no_maturity.css" type="text/css" media="screen">
    <link rel="alternate stylesheet" title="No issues/annotations"
        href="https://www.w3.org/TR/SVG2/style/default_no_issues.css" type="text/css" media="screen">
    <link rel="stylesheet" href="//www.w3.org/StyleSheets/TR/2016/W3C-ED" type="text/css" media="screen">
    <script src="https://www.w3.org/TR/SVG2/style/link-fixup.js"></script>
</head>

<body class="chapter-render">

    <h1>第3章：渲染模型</h1>
    <nav id="toc">
        <div class="header top"><a href="Overview.html">概述</a> . <a href="conform.html">上一页</a> . <a
                href="types.html">下一页</a> . <a href="eltindex.html">元素</a> . <a href="attindex.html">属性</a> . <a
                href="propidx.html">特性</a></div>
        <h2 id="Contents" class="contents">目录</h2>
        <ol class="toc">
            <li>
                <ol class="toc">
                    <li><a href="render.html#Introduction"><span class="secno">3.1.</span> 引言</a></li>
                    <li><a href="render.html#RenderingTree"><span class="secno">3.2.</span> 渲染树</a>
                        <ol class="toc">
                            <li><a href="render.html#Definitions"><span class="secno">3.2.1.</span> 定义</a></li>
                            <li><a href="render.html#Rendered-vs-NonRendered"><span class="secno">3.2.2.</span>
                                    渲染元素与非渲染元素</a></li>
                            <li><a href="render.html#VisibilityControl"><span class="secno">3.2.3.</span> 控制可见性：‘<span
                                        class="property">display</span>’和‘<span
                                        class="property">visibility</span>’属性的影响</a></li>
                            <li><a href="render.html#ReusedGraphics"><span class="secno">3.2.4.</span> 重用图形</a></li>
                        </ol>
                    </li>
                    <li><a href="render.html#PaintersModel"><span class="secno">3.3.</span> 画家模型</a></li>
                    <li><a href="render.html#RenderingOrder"><span class="secno">3.4.</span> 渲染顺序</a>
                        <ol class="toc">
                            <li><a href="render.html#EstablishingStackingContex"><span class="secno">3.4.1.</span>
                                    在SVG中建立堆叠上下文</a></li>
                        </ol>
                    </li>
                    <li><a href="render.html#Elements"><span class="secno">3.5.</span> 元素的渲染方式</a>
                    </li>
                    <li><a href="render.html#Grouping"><span class="secno">3.6.</span> 组的渲染方式</a>
                        <ol class="toc">
                            <li><a href="render.html#ObjectAndGroupOpacityProperties"><span class="secno">3.6.1.</span>
                                    对象和组不透明度：‘<span class="property">opacity</span>’属性的影响</a></li>
                        </ol>
                    </li>
                    <li><a href="render.html#TypesOfGraphicsElements"><span class="secno">3.7.</span> 图形元素的类型</a>
                        <ol class="toc">
                            <li><a href="render.html#PaintingShapesAndText"><span class="secno">3.7.1.</span>
                                    绘制形状和文本</a></li>
                            <li><a href="render.html#PaintingRasterImages"><span class="secno">3.7.2.</span> 绘制光栅图像</a>
                            </li>
                        </ol>
                    </li>
                    <li><a href="render.html#FilteringPaintRegions"><span class="secno">3.8.</span> 过滤绘制区域</a></li>
                    <li><a href="render.html#ClippingAndMasking"><span class="secno">3.9.</span> 裁剪和遮罩</a></li>
                    <li><a href="render.html#ParentCompositing"><span class="secno">3.10.</span> 父级合成</a></li>
                    <li><a href="render.html#OverflowAndClipProperties"><span class="secno">3.11.</span> ‘<span
                                class="property">overflow</span>’属性的影响</a></li>
                </ol>
            </li>
        </ol>
    </nav>

    <div class="annotation">
        <p>
            SVG 2 渲染模型将遵循<a href="https://www.w3.org/TR/compositing/">合成与混合规范</a>定义的规则。
        </p>
        <p>
            会议记录：<a href="https://www.w3.org/2012/07/24-svg-minutes.html#item09">2012年西雅图/巴黎面对面会议第3天</a>。
        </p>
        <p>
            负责人：Nikos（行动项3332）。
        </p>
        <p>
            状态：完成。
        </p>
    </div>

    <h2 id="Introduction" class="heading">3.1. 引言<a class="self-link" href="#Introduction"></a></h2>
    <p>
        SVG的实现必须按照本章所述的渲染模型进行实现，并根据<a href="conform.html">符合性要求</a>附录中的说明进行修改，该附录描述了实现可能偏离的情况。
        在实践中，由于输出设备的限制（例如，可能只支持有限范围的颜色），以及在实现精确数学模型方面的实际限制（例如，现实性能的曲线用直线近似，近似值只需足够精确以满足符合性要求），允许一定的可变性。
    </p>

    <p>关于<a href="conform.html">符合性要求</a>的附录描述了实际实现可能偏离该描述的程度。在实践中，实际实现<span
            class="ready-for-wider-review">可能</span>会因为输出设备的限制（例如，可能只支持有限范围的颜色）以及在实现精确数学模型方面的实际限制而略有偏离（例如，现实性能的曲线用直线近似，近似值只需足够精确以满足符合性要求）。
    </p>

    <div class="ready-for-wider-review">
        <h2 id="RenderingTree" class="heading">3.2. 渲染树<a class="self-link" href="#RenderingTree"></a>
        </h2>

        <p> SVG文档最终渲染表示的组件与文档模型中的基本元素之间并没有一对一的关系。
            图形的外观反映了一种平行结构——渲染树，
            其中某些元素被排除，另一些元素被重复。
        </p>

        <p> SVG命名空间中的许多元素并不直接代表图形文档的一个组件。
            相反，它们定义图形效果、元数据、
            用于表示其他元素的内容，
            或在特定条件下显示的替代内容。
            在动态文档中，图形的某些组件
            可能会根据交互或动画进行渲染或不渲染。
            这些未渲染的元素不会直接包含在<a href="render.html#RenderingTree">渲染树</a>中。
        </p>
        <p>
            由于SVG支持图形子组件的重用，
            某些元素会被多次渲染。
            每个单独的渲染可能具有上下文相关的样式，
            并可能以不同的比例或变换进行光栅化。
        </p>

        <h3 id="Definitions" class="heading">3.2.1. 定义<a class="self-link" href="#Definitions"></a></h3>

        <dl class="definitions">
            <dt><dfn id="TermRenderingTree" data-dfn-type="dfn" data-export="">渲染树</dfn></dt>
            <dd>
                <p>
                    渲染树是一个在<a href="struct.html#TermSVGDocumentFragment">SVG文档片段</a>中被渲染的元素集合。
                    它是从文档树生成的，
                    通过排除<a href="render.html#TermNonRenderedElement">未渲染元素</a>
                    并插入用于<a href="render.html#TermReusedGraphics">重用图形</a>的额外片段。
                    图形按照渲染树的顺序进行绘制和合成，
                    受<a class="property" href="painting.html#PaintOrderProperty">绘制顺序</a>属性的重新排序影响。
                    注意，尽管没有视觉效果的元素仍可能存在于渲染树中。
                </p>
            </dd>
            <dt><dfn id="TermRenderedElement" data-dfn-type="dfn" data-export="">已渲染元素</dfn></dt>
            <dd>
                <p>
                    在当前文档的<a href="render.html#RenderingTree">渲染树</a>中具有直接表示的元素。
                    包括在<a href="struct.html#TermElementInstance">元素</a>的<a
                        href="struct.html#TermUseElementShadowTree">使用元素阴影树</a>中的已渲染实例。
                    不包括影响渲染的元素，
                    作为重用图形的源定义，
                    但自身并不直接被渲染。
                    参见<a href="#Rendered-vs-NonRendered">已渲染与未渲染元素</a>。
                </p>
            </dd>
            <dt><dfn id="TermNonRenderedElement" data-dfn-type="dfn" data-export="">未渲染元素</dfn></dt>
            <dd>
                <p>
                    在当前文档的<a href="render.html#RenderingTree">渲染树</a>中没有直接表示的元素。
                    它仍可能通过重用图形或图形效果影响渲染树。
                    参见<a href="#Rendered-vs-NonRendered">已渲染与未渲染元素</a>。
                </p>
            </dd>
            <dt><dfn id="TermReusedGraphics" data-dfn-type="dfn" data-export="">重用图形</dfn></dt>
            <dd>
                <p>
                    包含在渲染树中的图形组件，
                    但在文档模型中没有单一直接等价元素。
                    它们可能通过阴影DOM元素表示
                    （如重用的图形使用<span class="element-name">‘<a
                            href="struct.html#UseElement"><span>use</span></a>’</span>元素），
                    或作为图形效果生成的图像片段
                    （如模式或遮罩）。
                </p>
            </dd>

            <dt><dfn id="TermNeverRenderedElement" data-dfn-type="dfn" data-export="">从不渲染元素</dfn></dt>
            <dd>
                <p>
                    任何类型的元素是<em>从不直接渲染</em>的，
                    无论上下文或<a class="property" href="render.html#VisibilityControl">显示</a>样式值。
                    它包括以下元素：
                    <span class="element-name">‘<a
                            href="https://drafts.fxtf.org/css-masking-1/#ClipPathElement"><span>clipPath</span></a>’</span>，
                    <span class="element-name">‘<a href="struct.html#DefsElement"><span>defs</span></a>’</span>， <span
                        class="element-name">‘<a href="struct.html#DescElement"><span>desc</span></a>’</span>， <span
                        class="element-name">‘<a
                            href="pservers.html#LinearGradientElement"><span>linearGradient</span></a>’</span>， <span
                        class="element-name">‘<a href="painting.html#MarkerElement"><span>marker</span></a>’</span>，
                    <span class="element-name">‘<a
                            href="https://drafts.fxtf.org/css-masking-1/#MaskElement"><span>mask</span></a>’</span>，
                    <span class="element-name">‘<a href="struct.html#MetadataElement"><span>metadata</span></a>’</span>，
                    <span class="element-name">‘<a href="pservers.html#PatternElement"><span>pattern</span></a>’</span>，
                    <span class="element-name">‘<a
                            href="pservers.html#RadialGradientElement"><span>radialGradient</span></a>’</span>， <span
                        class="element-name">‘<a href="interact.html#ScriptElement"><span>script</span></a>’</span>，
                    <span class="element-name">‘<a href="styling.html#StyleElement"><span>style</span></a>’</span> 和
                    <span class="element-name">‘<a href="struct.html#TitleElement"><span>title</span></a>’</span>；
                    它还包括一个<span class="element-name">‘<a
                            href="struct.html#SymbolElement"><span>symbol</span></a>’</span>元素，该元素不是
                    <a href="struct.html#TermInstanceRoot">实例根</a>的<a
                        href="struct.html#TermUseElementShadowTree">使用元素阴影树</a>。
                </p>
            </dd>
            <dt><dfn id="TermRenderableElement" data-dfn-type="dfn" data-export="">可渲染元素</dfn></dt>
            <dd>
                <p>
                    任何类型的元素<em>可以</em>在<a href="render.html#RenderingTree">渲染树</a>中具有直接表示，
                    作为图形、容器、文本、音频或动画。
                    它包括以下元素：
                    <span class="element-name">‘<a href="linking.html#AElement"><span>a</span></a>’</span>， <span
                        class="element-name">‘<a href="embedded.html#HTMLElements"><span>audio</span></a>’</span>， <span
                        class="element-name">‘<a href="embedded.html#HTMLElements"><span>canvas</span></a>’</span>，
                    <span class="element-name">‘<a href="shapes.html#CircleElement"><span>circle</span></a>’</span>，
                    <span class="element-name">‘<a href="shapes.html#EllipseElement"><span>ellipse</span></a>’</span>，
                    <span class="element-name">‘<a
                            href="embedded.html#ForeignObjectElement"><span>foreignObject</span></a>’</span>， <span
                        class="element-name">‘<a href="struct.html#GElement"><span>g</span></a>’</span>， <span
                        class="element-name">‘<a href="embedded.html#HTMLElements"><span>iframe</span></a>’</span>，
                    <span class="element-name">‘<a href="embedded.html#ImageElement"><span>image</span></a>’</span>，
                    <span class="element-name">‘<a href="shapes.html#LineElement"><span>line</span></a>’</span>， <span
                        class="element-name">‘<a href="paths.html#PathElement"><span>path</span></a>’</span>， <span
                        class="element-name">‘<a href="shapes.html#PolygonElement"><span>polygon</span></a>’</span>，
                    <span class="element-name">‘<a href="shapes.html#PolylineElement"><span>polyline</span></a>’</span>，
                    <span class="element-name">‘<a href="shapes.html#RectElement"><span>rect</span></a>’</span>， <span
                        class="element-name">‘<a href="struct.html#SVGElement"><span>svg</span></a>’</span>， <span
                        class="element-name">‘<a href="struct.html#SwitchElement"><span>switch</span></a>’</span>， <span
                        class="element-name">‘<a href="text.html#TextElement"><span>text</span></a>’</span>， <span
                        class="element-name">‘<a href="text.html#TextPathElement"><span>textPath</span></a>’</span>，
                    <span class="element-name">‘<a href="text.html#TextElement"><span>tspan</span></a>’</span>， <span
                        class="element-name">‘<a href="struct.html#UnknownElement"><span>unknown</span></a>’</span>，
                    <span class="element-name">‘<a href="struct.html#UseElement"><span>use</span></a>’</span> 和 <span
                        class="element-name">‘<a href="embedded.html#HTMLElements"><span>video</span></a>’</span>；
                    它还包括一个<span class="element-name">‘<a
                            href="struct.html#SymbolElement"><span>symbol</span></a>’</span>元素，该元素<em>是</em>
                    <a href="struct.html#TermInstanceRoot">实例根</a>的<a
                        href="struct.html#TermUseElementShadowTree">使用元素阴影树</a>。
                </p>
                <p> 可渲染元素在特定文档或时间点可能会被渲染，也可能不会被渲染。
                </p>
            </dd>

        </dl>

        <h3 id="Rendered-vs-NonRendered" class="heading">3.2.2. 渲染与非渲染元素<a class="self-link"
                href="#Rendered-vs-NonRendered"></a></h3>

        <p> 在任何给定时间，每个 SVG 元素
            （或<a href="struct.html#TermElementInstance">元素实例</a>在<a
                href="struct.html#TermUseElementShadowTree">使用元素阴影树</a>中）
            要么是渲染的，要么是非渲染的。
            元素当前是否被渲染不仅影响其视觉显示，还影响
            交互性和几何计算。
        </p>

        <p>
            元素在以下四种情况下<em>未被渲染</em>：
        </p>
        <ul>
            <li><a href="render.html#TermNeverRenderedElement">从未渲染元素</a>类型</li>
            <li>因<a href="struct.html#TermConditionalProcessingAttribute">条件处理属性</a>
                或<span class="element-name">‘<a href="struct.html#SwitchElement"><span>switch</span></a>’</span>
                结构而被排除的元素
            </li>
            <li>对于<a class="property" href="render.html#VisibilityControl">display</a>属性
                的计算样式值为<code>none</code>的元素
            </li>
            <li>其他非渲染元素的后代元素
            </li>
        </ul>

        <p> 非渲染元素：
        </p>
        <ul>
            <li>对图形没有视觉影响，
                除非它们在渲染另一个引用它们的元素时被使用。</li>

            <li>不对<a href="https://drafts.fxtf.org/css-masking-1/#clipping-path">剪切路径</a>或<a
                    href="https://drafts.fxtf.org/css-masking-1/#masking">遮罩</a>
                的净几何贡献
                当它们是
                <span class="element-name">‘<a
                        href="https://drafts.fxtf.org/css-masking-1/#ClipPathElement"><span>clipPath</span></a>’</span>
                或<span class="element-name">‘<a
                        href="https://drafts.fxtf.org/css-masking-1/#MaskElement"><span>mask</span></a>’</span>
                的后代时
            </li>

            <li>对<a href="interact.html#UIEvents">指针事件</a>不敏感</li>

            <li>不能接收<a href="interact.html#Focus">焦点</a></li>

            <li>不对<a href="coords.html#ObjectBoundingBox">边界框计算</a>做出贡献</li>

            <li>在执行<a href="text.html#TextLayout">文本布局</a>时不被考虑</li>
        </ul>

        <p> 非渲染元素在文档可访问性树中不被表示。
            尽管如此，它们仍然是文档模型的一部分，
            并参与<a href="styling.html">样式继承和级联</a>。
        </p>


        <h3 id="VisibilityControl" class="heading">3.2.3. 控制可见性：‘<span class="property">display</span>’和‘<span
                class="property">visibility</span>’属性的影响<a class="self-link" href="#VisibilityControl"></a></h3>

        <p>
            SVG 使用两个属性来切换通常渲染元素的可见显示：
            <a class="property" href="render.html#VisibilityControl">display</a> 和 <a class="property"
                href="render.html#VisibilityControl">visibility</a>。
            尽管它们在静态文档中具有相似的可见效果，
            但在概念上是不同的。
        </p>

        <p class="note">有关<a class="property" href="render.html#VisibilityControl">display</a>和<a class="property"
                href="render.html#VisibilityControl">visibility</a>的定义，请参见 CSS 2.1 规范。
            [<a href="refs.html#ref-css2">CSS2</a>]</p>

        <p>
            将<a class="property" href="render.html#VisibilityControl">display</a>设置为<span class="prop-value">none</span>
            会导致元素未被渲染。
            当应用于
            <a href="struct.html#TermGraphicsElement">图形元素</a>、
            <a href="text.html#TermTextContentElement">文本内容元素</a>和<a
                href="struct.html#TermContainerElement">容器元素</a>时，设置<a class="property"
                href="render.html#VisibilityControl">display</a>为<span class="prop-value">none</span>
            会导致该元素（及其所有后代）不成为<a href="render.html#RenderingTree">渲染树</a>的一部分。
            请注意，<a class="property" href="render.html#VisibilityControl">display</a>不是一个继承属性。
        </p>
        <p>
            具有任何其他<a class="property" href="render.html#VisibilityControl">display</a>值的元素
            除<span class="prop-value">none</span>外，都会正常渲染。
        </p>
        <p>
            <a class="property" href="render.html#VisibilityControl">display</a>属性仅适用于<a
                href="render.html#TermRenderableElement">可渲染元素</a>。
            在一个<a href="render.html#TermNeverRenderedElement">从未直接渲染</a>
            或基于条件处理而<a href="render.html#Rendered-vs-NonRendered">未渲染</a>的元素上设置<code>display: none</code>没有效果。
        </p>

        <p>
            <a class="property" href="render.html#VisibilityControl">display</a>属性影响给定元素的直接处理，
            但不阻止它被其他元素引用。
            例如，在<span class="element-name">‘<a href="paths.html#PathElement"><span>path</span></a>’</span>元素上设置
            <span class="prop-value">display: none</span>会阻止该元素直接渲染到画布上，
            但<span class="element-name">‘<a href="paths.html#PathElement"><span>path</span></a>’</span>
            元素仍然可以被<span class="element-name">‘<a
                    href="text.html#TextPathElement"><span>textPath</span></a>’</span>元素引用，
            并且其几何形状将在路径文本处理时被使用。
        </p>

        <p>
            当应用于<a href="struct.html#TermGraphicsElement">图形元素</a>或<span class="element-name">‘<a
                    href="struct.html#UseElement"><span>use</span></a>’</span>元素时，
            将<a class="property" href="render.html#VisibilityControl">visibility</a>设置为<span
                class="prop-value">hidden</span>
            或<span class="prop-value">collapse</span>
            会导致该元素未被绘制。
            但它仍然是<a href="render.html#RenderingTree">渲染树</a>的一部分。
            它可能对指针事件敏感
            （取决于<a class="property" href="interact.html#PointerEventsProperty">pointer-events</a>的值），
            可能会接收焦点（取决于<span class="attr-name">‘<a
                    href="struct.html#SVGElementTabindexAttribute"><span>tabindex</span></a>’</span>的值），
            参与边界框计算和剪切路径，
            并影响文本布局。
        </p>

        <p>
            <a class="property" href="render.html#VisibilityControl">visibility</a>属性仅直接影响
            <a href="struct.html#TermGraphicsElement">图形元素</a>、<a
                href="text.html#TermTextContentElement">文本内容元素</a>和当它是<a
                href="text.html#TermTextContentElement">文本内容元素</a>的子元素时的
            <span class="element-name">‘<a href="linking.html#AElement"><span>a</span></a>’</span>元素。
            由于<a class="property" href="render.html#VisibilityControl">visibility</a>是一个继承属性，
            因此，
            虽然它对<span class="element-name">‘<a href="struct.html#UseElement"><span>use</span></a>’</span>元素或<a
                href="struct.html#TermContainerElement">容器元素</a>本身没有影响，
            其继承值可以影响后代元素。
        </p>

        <h3 id="ReusedGraphics" class="heading">3.2.4. 重用图形<a class="self-link" href="#ReusedGraphics"></a>
        </h3>

        <p> 在文档的一个部分（或在另一个文档）定义的图形内容
            可以用于渲染其他元素。
            从渲染的角度来看，有两种类型的重用图形：
        </p>
        <ul>
            <li>
                阴影 DOM 元素，
                例如由<span class="element-name">‘<a href="struct.html#UseElement"><span>use</span></a>’</span>元素生成的元素
                或通过画布服务器之间的交叉引用生成的元素；
            </li>
            <li>
                作为图形效果的一部分重用的内容，
                包括<a href="painting.html#Markers">标记</a>的子内容、<a href="painting.html#TermPaintServerElement">画布服务器
                    元素</a>、
                <span class="element-name">‘<a
                        href="https://drafts.fxtf.org/css-masking-1/#ClipPathElement"><span>clipPath</span></a>’</span>，
                和<span class="element-name">‘<a
                        href="https://drafts.fxtf.org/css-masking-1/#MaskElement"><span>mask</span></a>’</span>。
            </li>
        </ul>

        <p>
            阴影 DOM 元素的渲染方式与普通元素相同，
            就像宿主元素（例如<span class="element-name">‘<a href="struct.html#UseElement"><span>use</span></a>’</span>元素）
            是一个容器，阴影内容是其后代一样。
            阴影 DOM 元素上的样式和几何属性
            与其在源文档中的<a href="struct.html#TermCorrespondingElement">对应元素</a>
            独立解析。
            <a class="property" href="render.html#VisibilityControl">display</a>属性对
            阴影元素具有正常效果，
            除了适用于<span class="element-name">‘<a href="struct.html#SymbolElement"><span>symbol</span></a>’</span>元素的特殊规则。
        </p>
        <p>
            出于混合目的，<span class="element-name">‘<a href="struct.html#UseElement"><span>use</span></a>’</span>元素形成了一个<a
                href="https://www.w3.org/TR/2015/CR-compositing-1-20150113/#isolatedgroups">非孤立组</a>。
        </p>

        <p>
            相比之下，
            图形效果元素生成一个自包含的 SVG 片段，
            独立渲染为<a href="render.html#TermStackingContext">堆叠上下文</a>
            和一个<a href="https://www.w3.org/TR/2015/CR-compositing-1-20150113/#isolatedgroups">孤立组</a>。
            该片段的画布是缩放的。

            图形效果元素的子内容
            在该画布中渲染和合成。
            整个平面画布在与其他绘画层混合时
            被视为矢量图像。
        </p>
        <p>
            图形效果元素任何子内容上的<a class="property" href="render.html#VisibilityControl">display</a>属性
            在设置为<code>none</code>时具有正常效果，
            排除该子树用于渲染。
            然而，图形效果并不会因图形效果元素或祖先上的<code>display: none</code>值而改变。
        </p>
    </div>

    <div class="ready-for-wider-review">

        <h2 id="PaintersModel" class="heading">3.3. 绘图模型<a class="self-link" href="#PaintersModel"></a>
        </h2>

        <p>SVG 使用“绘图模型”进行渲染。<a href="painting.html#TermPaint">绘制</a>
            通过连续的操作应用于输出设备，使得每个操作都在输出设备的某个区域上绘制，
            可能会遮盖之前已经涂抹的部分。

            每绘制一个对象或组后，它就成为下一个绘制操作的背景的一部分。

            SVG 2 支持先进的混合模式和合成操作，以控制每个绘制操作如何与背景交互。
            这些绘制操作的规则在
            <a href="https://www.w3.org/TR/compositing/">合成与混合规范</a>中概述。
        </p>

        <h2 id="RenderingOrder" class="heading">3.4. 渲染顺序<a class="self-link" href="#RenderingOrder"></a>
        </h2>
        <p>SVG 中的元素在三维空间中定位。除了它们在<a href="coords.html#TermSVGViewport">SVG 视口</a>的 x 和 y 轴上的位置外，SVG 元素还
            在 z 轴上定位。z 轴的位置定义了它们的绘制顺序。</p>

        <p>沿 z 轴，元素被分组为<dfn id="TermStackingContext" data-dfn-type="dfn" data-export="">堆叠上下文</dfn>。</p>
    </div>

    <h3 id="EstablishingStackingContex" class="heading">3.4.1. 在 SVG 中建立堆叠上下文<a class="self-link"
            href="#EstablishingStackingContex"></a></h3>
    <p>如果满足以下条件，必须在 SVG 元素上为其后代建立新的堆叠上下文：</p>

    <ul>
        <li>它是根元素</li>

        <li>该元素是<a href="struct.html#TermOutermostSVGElement">最外层 svg 元素</a>，或是<span class="element-name">‘<a
                    href="embedded.html#ForeignObjectElement"><span>foreignObject</span></a>’</span>，
            <span class="element-name">‘<a href="embedded.html#ImageElement"><span>image</span></a>’</span>，<span
                class="element-name">‘<a href="painting.html#MarkerElement"><span>marker</span></a>’</span>，<span
                class="element-name">‘<a
                    href="https://drafts.fxtf.org/css-masking-1/#MaskElement"><span>mask</span></a>’</span>，<span
                class="element-name">‘<a href="pservers.html#PatternElement"><span>pattern</span></a>’</span>，
            <span class="element-name">‘<a href="struct.html#SymbolElement"><span>symbol</span></a>’</span> 或<span
                class="element-name">‘<a href="struct.html#UseElement"><span>use</span></a>’</span>元素
        </li>

        <li>该元素是内部的<span class="element-name">‘<a href="struct.html#SVGElement"><span>svg</span></a>’</span>元素，并且其<a
                class="property" href="render.html#OverflowAndClipProperties">overflow</a>属性的计算值为其他值
            而不是<span class="prop-value">visible</span>
        </li>

        <li>该元素受限于显式剪裁：
            <ul>
                <li><a class="property" href="https://drafts.fxtf.org/css-masking-1/#propdef-clip">clip</a>属性
                    适用于该元素，并且它的计算值不是<span class="prop-value">auto</span></li>

                <li><a class="property" href="https://drafts.fxtf.org/css-masking-1/#the-clip-path">clip-path</a>
                    属性适用于该元素，并且它的计算值不是<span class="prop-value">none</span></li>
            </ul>
        </li>

        <li><a class="property" href="render.html#ObjectAndGroupOpacityProperties">opacity</a>属性适用于
            该元素，并且它的计算值不是<span class="prop-value">1</span></li>

        <li><a class="property" href="https://drafts.fxtf.org/css-masking-1/#propdef-mask">mask</a>属性适用于
            该元素，并且它的计算值不是<span class="prop-value">none</span></li>

        <li><a class="property" href="https://drafts.fxtf.org/filter-effects/#FilterProperty">filter</a>属性
            适用于该元素，并且它的计算值不是<span class="prop-value">none</span></li>

        <li class="ready-for-wider-review">应用于元素的其他规范中定义的属性，并且该属性被定义为在 SVG 中建立堆叠上下文</li>
    </ul>

    <p>堆叠上下文是用于描述在文档渲染时，元素一个个绘制在其他元素上面的顺序的概念工具，且用于确定在指针事件中哪个元素最高。堆叠上下文
        不影响元素在 DOM 树中的位置，其存在或缺失不会影响元素在画布的 X-Y 平面上的位置、大小或方向——仅影响其绘制的顺序。</p>

    <p>堆叠上下文可以包含进一步的堆叠上下文。从其父堆叠上下文的角度来看，堆叠上下文是原子的；祖先堆叠上下文中的元素不能介入其任何元素之间。</p>

    <p>每个元素属于一个堆叠上下文。堆叠上下文中的元素必须按照文档顺序进行堆叠。</p>

    <p>除了<span class="element-name">‘<a
                href="embedded.html#ForeignObjectElement"><span>foreignObject</span></a>’</span>元素外，SVG 元素创建的堆叠上下文的从后到前
        的堆叠顺序为：</p>

    <ol>
        <li>形成堆叠上下文的元素的背景和边框（如果有）</li>

        <li>后代，按树的顺序</li>
    </ol>

    <p>由于<span class="element-name">‘<a
                href="embedded.html#ForeignObjectElement"><span>foreignObject</span></a>’</span>元素在 CSS 术语中创建一个
        “固定位置的包含块”，因此由<span class="element-name">‘<a
                href="embedded.html#ForeignObjectElement"><span>foreignObject</span></a>’</span>元素创建的堆叠上下文的堆叠顺序规范规则为
        CSS 2.1 附录 E 中的规则。</p>

    <h2 id="Elements" class="heading">3.5. 元素如何渲染<a class="self-link" href="#Elements"></a></h2>
    <div class="ready-for-wider-review">
        <p>
            单个<a href="struct.html#TermGraphicsElement">图形元素</a>被视为一个<a
                href="https://www.w3.org/TR/2015/CR-compositing-1-20150113/#isolatedgroups">非孤立组</a>，
            构成图形元素的组件（填充、描边等）（参见<a href="#PaintingShapesAndText">绘制形状和文本</a>）是
            该组的成员。参见<a href="#Grouping">组如何渲染</a>。
        </p>
    </div>

    <h2 id="Grouping" class="heading">3.6. 组如何渲染<a class="self-link" href="#Grouping"></a></h2>
    <div class="ready-for-wider-review">
    </div>
    <div class="ready-for-wider-review">
        <p>
            像<span class="element-name">‘<a href="struct.html#GElement"><span>g</span></a>’</span>元素（参见<a
                href="struct.html#TermContainerElement">容器元素</a>
            ）创建一个<a href="https://www.w3.org/TR/2015/CR-compositing-1-20150113/#groups">合成组</a>。
            类似地，<span class="element-name">‘<a href="struct.html#UseElement"><span>use</span></a>’</span>
            元素为其阴影内容创建一个合成组。
            <a href="https://www.w3.org/TR/2015/CR-compositing-1-20150113">合成与混合</a>
            规范规范性地描述了如何渲染<a href="https://www.w3.org/TR/2015/CR-compositing-1-20150113/#groups">合成组</a>。
            在 SVG 中，可以对一个组应用效果。例如，透明度、滤镜或蒙版。这些效果在对组应用任何变换之前
            立即应用于组的渲染结果，然后在组与<a
                href="https://www.w3.org/TR/2015/CR-compositing-1-20150113/#groupbackdrop">组背景</a>混合和合成之前应用。
            对组应用任何此类效果会使该组隔离。
            <br><br>
            因此，渲染<a href="https://www.w3.org/TR/2015/CR-compositing-1-20150113/#groups">合成组</a>遵循以下步骤：<br>
            如果该组是隔离的：
        </p>
        <ol>
            <li>将<a href="https://www.w3.org/TR/2015/CR-compositing-1-20150113/#initialbackdrop">初始背景</a>
                设置为使用rgba(0,0,0,0)初始化的新缓冲区</li>
            <li>该组中是<a href="struct.html#TermGraphicsElement">图形元素</a>或
                <span class="element-name">‘<a href="struct.html#GElement"><span>g</span></a>’</span>元素的内容被
                <a href="#RenderingOrder">按顺序</a>渲染到<a
                    href="https://www.w3.org/TR/2015/CR-compositing-1-20150113/#initialbackdrop">初始背景</a>
            </li>
            <li>应用修改组画布的滤镜和其他效果
                <div class="note">
                    <p class="ready-for-wider-review">为了提供高质量的渲染，滤镜
                        原语和其他位图效果必须在<a href="https://drafts.fxtf.org/filter-effects/#operating-coordinate-space">操作
                            坐标空间</a>中应用。
                    </p>
                </div>
            </li>
            <li>应用组变换</li>
            <li>将组画布与<a href="https://www.w3.org/TR/2015/CR-compositing-1-20150113/#groupbackdrop">组背景</a>混合和合成</li>
        </ol>
        else (该组不是隔离的):
        <ol>
            <li>将<a href="https://www.w3.org/TR/2015/CR-compositing-1-20150113/#initialbackdrop">初始背景</a>
                设置为<a href="https://www.w3.org/TR/2015/CR-compositing-1-20150113/#groupbackdrop">组背景</a></li>
            <li>该组中是<a href="struct.html#TermGraphicsElement">图形元素</a>或
                <span class="element-name">‘<a href="struct.html#GElement"><span>g</span></a>’</span>元素的内容被
                <a href="#RenderingOrder">按顺序</a>渲染到<a
                    href="https://www.w3.org/TR/2015/CR-compositing-1-20150113/#initialbackdrop">初始背景</a>。
                组变换在每个元素渲染时应用。
            </li>
        </ol>
    </div>

    <h3 id="ObjectAndGroupOpacityProperties" class="heading">3.6.1. 对象和组的不透明度：‘<span
            class="property">opacity</span>’属性的效果<a class="self-link" href="#ObjectAndGroupOpacityProperties"></a></h3>

    <p class="note">有关<a class="property"
            href="render.html#ObjectAndGroupOpacityProperties">opacity</a>的定义，请参见CSS颜色模块第3版。[<a
            href="refs.html#ref-css-color-3">css-color-3</a>]</p>

    <p>属性<a class="property"
            href="render.html#ObjectAndGroupOpacityProperties">opacity</a>指定给定图形元素或容器元素在绘制到画布时的透明度。当应用于容器元素时，这被称为<em>组透明度</em>；当应用于单个渲染元素时，这被称为<em>对象透明度</em>。然而，这两种操作的原理是相同的。
    </p>

    <p>在SVG中，还有几个与透明度相关的属性：</p>

    <ul>
        <li><a class="property" href="painting.html#FillOpacityProperty">fill-opacity</a>，指定填充操作的透明度；</li>
        <li><a class="property" href="painting.html#StrokeOpacityProperty">stroke-opacity</a>，指定描边操作的透明度；</li>
        <li><a class="property" href="pservers.html#StopOpacityProperty">stop-opacity</a>，指定渐变停止点的透明度。</li>
    </ul>

    <p>这四个透明度属性参与中间渲染操作。然而，对象和组的透明度可以视为后处理操作。概念上，适用<a class="property"
            href="render.html#ObjectAndGroupOpacityProperties">opacity</a>的对象或组被渲染到一个RGBA离屏图像中。整个离屏图像随后以指定的<a
            class="property" href="render.html#ObjectAndGroupOpacityProperties">opacity</a>值统一混合到画布中。
        <span class="ready-for-wider-review">
            因此，<a class="property" href="render.html#ObjectAndGroupOpacityProperties">opacity</a>的存在使得该组变为<a
                href="https://www.w3.org/TR/2015/CR-compositing-1-20150113/#isolatedgroups">孤立</a>的。
        </span>
    </p>

    <p>属性<a class="property" href="render.html#ObjectAndGroupOpacityProperties">opacity</a>适用于以下SVG元素：
        <span class="element-name">‘<a href="struct.html#SVGElement"><span>svg</span></a>’</span>、<span
            class="element-name">‘<a href="struct.html#GElement"><span>g</span></a>’</span>、<span
            class="element-name">‘<a href="struct.html#SymbolElement"><span>symbol</span></a>’</span>、<span
            class="element-name">‘<a href="painting.html#MarkerElement"><span>marker</span></a>’</span>、
        <span class="element-name">‘<a href="linking.html#AElement"><span>a</span></a>’</span>、<span
            class="element-name">‘<a href="struct.html#SwitchElement"><span>switch</span></a>’</span>、<span
            class="element-name">‘<a href="struct.html#UseElement"><span>use</span></a>’</span>、<span
            class="element-name">‘<a href="struct.html#UnknownElement"><span>unknown</span></a>’</span>以及<a
            href="struct.html#TermGraphicsElement">图形元素</a>。
    </p>

    <div class="example">
        <p>以下示例说明了<a class="property" href="render.html#ObjectAndGroupOpacityProperties">opacity</a>属性在对象和组上的各种用法。</p>

        <pre>&lt;svg xmlns="http://www.w3.org/2000/svg"
     width="600" height="175" viewBox="0 0 1200 350">

  &lt;!-- 背景蓝色矩形 -->
  &lt;rect x="100" y="100" width="1000" height="150" fill="blue">

  &lt;!-- 从不透明到几乎透明的红色圆圈 -->
  &lt;circle cx="200" cy="100" r="50" fill="red" opacity="1">
  &lt;circle cx="400" cy="100" r="50" fill="red" opacity=".8">
  &lt;circle cx="600" cy="100" r="50" fill="red" opacity=".6">
  &lt;circle cx="800" cy="100" r="50" fill="red" opacity=".4">
  &lt;circle cx="1000" cy="100" r="50" fill="red" opacity=".2">

  &lt;!-- 不透明组，不透明圆圈 -->
  &lt;g opacity="1">
    &lt;circle cx="182.5" cy="250" r="50" fill="red" opacity="1">
    &lt;circle cx="217.5" cy="250" r="50" fill="green" opacity="1">
  &lt;/g>
  &lt;!-- 组透明度：.5，不透明圆圈 -->
  &lt;g opacity=".5">
    &lt;circle cx="382.5" cy="250" r="50" fill="red" opacity="1">
    &lt;circle cx="417.5" cy="250" r="50" fill="green" opacity="1">
  &lt;/g>
  &lt;!-- 不透明组，半透明绿色在红色上 -->
  &lt;g opacity="1">
    &lt;circle cx="582.5" cy="250" r="50" fill="red" opacity=".5">
    &lt;circle cx="617.5" cy="250" r="50" fill="green" opacity=".5">
  &lt;/g>
  &lt;!-- 不透明组，半透明红色在绿色上 -->
  &lt;g opacity="1">
    &lt;circle cx="817.5" cy="250" r="50" fill="green" opacity=".5">
    &lt;circle cx="782.5" cy="250" r="50" fill="red" opacity=".5">
  &lt;/g>
  &lt;!-- 组透明度.5，半透明绿色在红色上 -->
  &lt;g opacity=".5">
    &lt;circle cx="982.5" cy="250" r="50" fill="red" opacity=".5">
    &lt;circle cx="1017.5" cy="250" r="50" fill="green" opacity=".5">
  &lt;/g>
&lt;/svg></pre>

        <div class="figure">
            <img class="bordered" src="https://www.w3.org/TR/SVG2/images/masking/opacity01.svg" alt="图像显示不同的圆圈组与背景混合。">
            <p class="caption">每组红色和绿色圆圈首先渲染到一个离屏图像中，然后作为整体与背景蓝色矩形混合，使用给定的<a class="property"
                    href="render.html#ObjectAndGroupOpacityProperties">opacity</a>值。</p>
        </div>

        <p>在示例中，顶部圆圈的透明度从1.0到0.2不等。底部行展示了五个<span class="element-name">‘<a
                    href="struct.html#GElement"><span>g</span></a>’</span>元素，每个元素包含重叠的红色和绿色圆圈，如下所示：</p>

        <ul>
            <li>第一组显示了不透明的情况作为参考。该组的透明度为1，圆圈也是如此。</li>

            <li>第二组显示了当组中元素不透明时的组透明度。</li>

            <li>第三和第四组显示了透明度不是交换律的。在第三组（透明度为1）中，半透明绿色圆圈覆盖在半透明红色圆圈上，而在第四组中，半透明红色圆圈覆盖在半透明绿色圆圈上。注意两个圆圈相交的区域显示不同的颜色。第三组的相交区域显示更多绿色，而第四组显示更多红色。
            </li>

            <li>第五组显示了透明度设置的乘法效果。圆圈和组本身的透明度设置均为0.5。结果是，红色圆圈不与绿色圆圈重叠的部分（即红色圆圈的上部/右部）将以累计透明度0.25（即0.5*0.5）混合到蓝色矩形中，这样，混合后的颜色将是25%红色和75%蓝色。
            </li>
        </ul>
    </div>

    <h2 id="TypesOfGraphicsElements" class="heading">3.7. 图形元素的类型<a class="self-link"
            href="#TypesOfGraphicsElements"></a></h2>

    <p>SVG支持三种基本类型的<a href="struct.html#TermGraphicsElement">图形元素</a>
        可渲染到画布上：</p>

    <ul>
        <li><a href="shapes.html#TermShapeElement">形状</a>，表示直线和曲线的组合</li>
        <li>文本，表示字符字形的组合</li>
        <li>光栅图像，表示一组值，指定在矩形网格上的一系列点的绘制颜色和不透明度（通常称为alpha）。(SVG要求支持在<a href="conform.html">符合性要求</a>下指定的光栅图像格式。)</li>
    </ul>

    <h3 id="PaintingShapesAndText" class="heading">3.7.1. 绘制形状和文本<a class="self-link" href="#PaintingShapesAndText"></a>
    </h3>

    <p>形状和文本可以被<a href="painting.html#TermFill">填充</a>（即将油漆应用于形状的内部）和<a
            href="painting.html#TermStroke">描边</a>（即在形状的轮廓上应用油漆）。</p>

    <p>对于某些类型的形状，可以在形状边界上的位置绘制<a
            href="painting.html#Markers">标记符号</a>（它们本身可以由任意组合的形状、文本和图像组成）。每个标记符号都像其图形内容在使用给定标记符号的形状对象之后扩展到SVG文档树一样被绘制。标记符号的图形内容使用与图形元素相同的方法进行渲染。标记符号不适用于文本。
    </p>

    <p>填充、描边和标记的绘制顺序由<a class="property"
            href="painting.html#PaintOrderProperty">paint-order</a>属性决定。默认情况下，首先绘制填充，然后是描边，最后是标记符号。标记符号沿着形状的轮廓按顺序渲染，从形状的起始点到结束点。
    </p>

    <p>填充和描边操作是完全独立的；例如，每个填充或描边操作都有其自己的不透明度设置。</p>

    <p>SVG支持多种内置类型的油漆，可用于填充和描边操作。这些在<a href="pservers.html">油漆服务器</a>中描述。</p>

    <h3 id="PaintingRasterImages" class="heading">3.7.2. 绘制光栅图像<a class="self-link" href="#PaintingRasterImages"></a>
    </h3>

    <p>当光栅图像被渲染时，原始样本使用标准算法进行“重采样”，以在输出设备上产生所需位置的样本。重采样要求在<a href="conform.html">符合性要求</a>中讨论。</p>
    <p class="ready-for-wider-review">
        如同HTML [<a href="refs.html#ref-html">HTML</a>, 10.4.2]，
        所有具有相同绝对URL和相同图像数据的动画图像都应按组同步渲染到同一时间线，时间线从最少最近添加到组的时间开始。
    </p>
    <p class="ready-for-wider-review">
        当用户代理要重新启动显示动画图像的img元素的动画时，期望该img元素节点文档中具有相同绝对URL和相同图像数据的所有动画图像都从头开始重新启动其动画。
    </p>

    <h2 id="FilteringPaintRegions" class="heading">3.8. 过滤绘制区域<a class="self-link" href="#FilteringPaintRegions"></a>
    </h2>
    <p>SVG允许对任何绘制操作进行过滤。（请参见<a href="https://www.w3.org/TR/filter-effects/">滤镜效果</a>。）</p>

    <p>在这种情况下，结果必须好像绘制操作已应用于一个初始化为透明黑色的中间画布，画布的大小由<a
            href="https://www.w3.org/TR/filter-effects/">滤镜效果</a>中给出的规则确定，然后通过<a
            href="https://www.w3.org/TR/filter-effects/">滤镜效果</a>中定义的过程进行过滤。</p>

    <div class="ready-for-wider-review">
        <h2 id="ClippingAndMasking" class="heading">3.9. 裁剪和遮罩<a class="self-link" href="#ClippingAndMasking"></a></h2>

        <p>SVG支持以下裁剪/遮罩功能：</p>

        <ul>
            <li>裁剪路径，使用任意组合的<span class="element-name">‘<a
                        href="paths.html#PathElement"><span>路径</span></a>’</span>、<span class="element-name">‘<a
                        href="text.html#TextElement"><span>文本</span></a>’</span>和
                <a
                    href="shapes.html#TermBasicShapeElement">基本形状</a>，或基本形状作为（在缺少抗锯齿的情况下）1位遮罩的轮廓，其中轮廓“内部”的所有内容都允许显示，而“外部”的所有内容则被遮罩
            </li>

            <li>遮罩，作为<a href="struct.html#TermContainerElement">容器元素</a>
                可以包含<a href="struct.html#TermGraphicsElement">图形元素</a>
                或其他容器元素，定义一组用于作为半透明遮罩的图形，以便将前景对象合成到当前背景中。
            </li>
        </ul>

        <p>裁剪和遮罩均在模块CSS遮罩中指定
            [<a href="refs.html#ref-css-masking-1">css-masking-1</a>].</p>
    </div>

    <h2 id="ParentCompositing" class="heading">3.10. 父级合成<a class="self-link" href="#ParentCompositing"></a></h2>
    <p>SVG文档片段可以是半透明的。</p>
    <p class="ready-for-wider-review">
        根据<a href="https://www.w3.org/TR/2015/CR-compositing-1-20150113">合成与混合</a>规范，
        <span class="element-name">‘<a href="struct.html#SVGElement"><span>svg</span></a>’</span>元素总是
        创建一个<a href="https://www.w3.org/TR/2015/CR-compositing-1-20150113/#isolatedgroups">隔离</a>组。
        当SVG文档是顶级文档时，
        意味着它没有嵌入在其他文档中，
        根<span class="element-name">‘<a href="struct.html#SVGElement"><span>svg</span></a>’</span>元素
        被视为<a href="https://www.w3.org/TR/2015/CR-compositing-1-20150113/#pagebackdrop">页面组</a>
        并与100%不透明的白色背景进行合成。
        在所有其他情况下，SVG文档或文档片段与父文档合成时保留不透明度。
    </p>

    <h2 id="OverflowAndClipProperties" class="heading">3.11. ‘<span class="property">overflow</span>’属性的效果<a
            class="self-link" href="#OverflowAndClipProperties"></a></h2>

    <p class="note">有关<a class="property" href="render.html#OverflowAndClipProperties">overflow</a>的定义，请参阅层叠样式表第2级修订版1
        (CSS 2.1) 规范 [<a href="refs.html#ref-css2">CSS2</a>]。</p>
    <div class="ready-for-wider-review">
        <table class="data compact">
            <caption>SVG中<a class="property" href="render.html#OverflowAndClipProperties">overflow</a>属性行为的总结。</caption>
            <thead>
                <tr>
                    <th>元素</th>
                    <th>初始值</th>
                    <th>用户代理样式表</th>
                    <th>自动</th>
                    <th>可见</th>
                    <th>隐藏</th>
                    <th>滚动</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <th>文档根svg</th>
                    <td>可见</td>
                    <td>不适用</td>
                    <td>可见 | 滚动</td>
                    <td>可见</td>
                    <td>隐藏</td>
                    <td>滚动</td>
                </tr>
                <tr>
                    <th>其他svg</th>
                    <td>可见</td>
                    <td>隐藏</td>
                    <td>可见 | 滚动</td>
                    <td>可见</td>
                    <td>隐藏</td>
                    <td>滚动</td>
                </tr>
                <tr>
                    <th>文本</th>
                    <td>可见</td>
                    <td>隐藏</td>
                    <td>可见</td>
                    <td>可见</td>
                    <td>隐藏</td>
                    <td>隐藏</td>
                </tr>
                <tr>
                    <th>图案</th>
                    <td>可见</td>
                    <td>隐藏</td>
                    <td>可见</td>
                    <td>可见</td>
                    <td>隐藏</td>
                    <td>隐藏</td>
                </tr>
                <tr>
                    <th>标记</th>
                    <td>可见</td>
                    <td>隐藏</td>
                    <td>可见</td>
                    <td>可见</td>
                    <td>隐藏</td>
                    <td>隐藏</td>
                </tr>
                <tr>
                    <th>符号</th>
                    <td>可见</td>
                    <td>隐藏</td>
                    <td>可见</td>
                    <td>可见</td>
                    <td>隐藏</td>
                    <td>隐藏</td>
                </tr>
                <tr>
                    <th>图像</th>
                    <td>可见</td>
                    <td>隐藏</td>
                    <td>可见</td>
                    <td>可见</td>
                    <td>隐藏</td>
                    <td>隐藏</td>
                </tr>
                <tr>
                    <th>iframe</th>
                    <td>可见</td>
                    <td>隐藏</td>
                    <td>可见 | 滚动</td>
                    <td>可见</td>
                    <td>隐藏</td>
                    <td>滚动</td>
                </tr>
                <tr>
                    <th>foreignObject</th>
                    <td>可见</td>
                    <td>隐藏</td>
                    <td>可见 | 滚动</td>
                    <td>可见</td>
                    <td>隐藏</td>
                    <td>滚动</td>
                </tr>
            </tbody>
        </table>

        <p><a class="property" href="render.html#OverflowAndClipProperties">overflow</a>属性具有相同的参数值，并且具有与<a
                href="https://www.w3.org/TR/2011/REC-CSS2-20110607/visufx.html#propdef-overflow">CSS 2.1</a>中定义的相同含义
            ([<a href="refs.html#ref-css2">CSS2</a>]，第11.1.1节)；然而，以下附加要点适用：</p>

        <ul>
            <li>
                如果<a class="property"
                    href="render.html#OverflowAndClipProperties">overflow</a>属性的值为'visible'，则该属性没有效果（即，不会创建裁剪矩形）。
            </li>

            <li>对于<a class="property" href="render.html#OverflowAndClipProperties">overflow</a>属性可以应用的那些元素，如果<a
                    class="property" href="render.html#OverflowAndClipProperties">overflow</a>属性的值为<span
                    class="prop-value">hidden</span>或<span class="prop-value">scroll</span>，则应用裁剪，其确切大小为SVG视口的大小。
            </li>

            <li>
                当在<span class="element-name">‘<a href="struct.html#SVGElement"><span>svg</span></a>’</span>元素上指定<span
                    class="prop-value">scroll</span>时，如果用户代理使用可见的滚动机制（如滚动条或平移器），则该机制应在SVG视口中显示，无论其内容是否被裁剪。
            </li>

            <li>
                在SVG内容中，值<span class="prop-value">auto</span>意味着所有子元素的渲染内容必须是<span
                    class="prop-value">visible</span>，要么通过滚动机制，要么通过不裁剪来渲染。
                对于值为<span class="prop-value">scroll</span>的元素，用户代理使用的滚动机制，则值<span
                    class="prop-value">auto</span>可能被视为<span
                    class="prop-value">scroll</span>。如果用户代理没有滚动机制，则内容不会被裁剪，或者值'scroll'被视为<span
                    class="prop-value">hidden</span>，则值<span class="prop-value">auto</span>必须被视为<span
                    class="prop-value">visible</span>。
            </li>
        </ul>

        <div class="note">
            尽管<a class="property" href="render.html#OverflowAndClipProperties">overflow</a>的初始值为自动。在用户代理样式表中，当<span
                class="element-name">‘<a
                    href="struct.html#SVGElement"><span>svg</span></a>’</span>元素不是独立文档的根元素时，该元素的overflow被覆盖，而<span
                class="element-name">‘<a href="pservers.html#PatternElement"><span>pattern</span></a>’</span>元素和<span
                class="element-name">‘<a href="painting.html#MarkerElement"><span>marker</span></a>’</span>元素的默认值为隐藏。
        </div>
    </div>
    <!-- ready-for-wider-review -->
    <script src="//www.w3.org/scripts/TR/2016/fixup.js"></script>
    <script src="/dropdown.js"></script>
</body>

</html>