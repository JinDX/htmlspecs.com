<!DOCTYPE html>
<html lang=zh-hans>

<head>
    <meta content="text/html; charset=utf-8" http-equiv=Content-Type>
    <title>CSS 作用域模块 第 1 级</title>
    <link href=https://www.w3.org/TR/css-scoping-1/default.css rel=stylesheet type=text/css>
    <link href="https://www.w3.org/StyleSheets/TR/W3C-WD" rel=stylesheet type=text/css>
</head>

<body class=h-entry>
    <div class=head>
        <p><a href="https://www.w3.org/">
                <img alt=W3C height=48 src="https://www.w3.org/Icons/w3c_home" width=72>
            </a>
        </p>
        <h1 class="p-name no-ref" id=title>CSS 作用域模块 第 1 级</h1>
        <h2 class="no-num no-toc no-ref heading settled heading" id=subtitle><span class=content>W3C 首次公开工作草案，
                <span class=dt-updated><span class=value-title title=20140403>2014年4月3日</span></span></span></h2>
        <div data-fill-with=spec-metadata>
            <dl>
                <dt>本版本：
                <dd><a class=u-url
                        href="https://www.w3.org/TR/2014/WD-css-scoping-1-20140403/">http://www.w3.org/TR/2014/WD-css-scoping-1-20140403/</a>
                <dt>最新版本：
                <dd><a href="https://www.w3.org/TR/css-scoping-1/">http://www.w3.org/TR/css-scoping-1/</a>
                <dt>编辑草案：
                <dd><a href=http://dev.w3.org/csswg/css-scoping>http://dev.w3.org/csswg/css-scoping/</a>
                <dt>反馈：</dt>
                <dd><a href="mailto:www-style@w3.org?subject=%5Bcss-scoping%5D%20feedback">www-style@w3.org</a>
                    主题行为
                    “<kbd>[css-scoping] <var>… message topic …</var></kbd>”（<a
                        href=http://lists.w3.org/Archives/Public/www-style/ rel=discussion>存档</a>）
                <dt>测试套件：
                <dd>尚无
                <dt>编辑：
                <dd class="p-author h-card vcard"><a class="p-name fn u-url url" href=http://xanthir.com/contact>Tab
                        Atkins Jr.</a>（<span class="p-org org">Google</span>）
                <dd class="p-author h-card vcard"><a class="p-name fn u-url url"
                        href=http://fantasai.inkedblade.net/contact>Elika J Etemad</a>（<span
                        class="p-org org">特邀专家</span>）
            </dl>
        </div>
        <div data-fill-with=warning></div>
        <p class=copyright data-fill-with=copyright><a
                href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2014 <a
                href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a
                href=http://www.csail.mit.edu><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a
                href=http://www.ercim.eu><abbr
                    title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a
                href=http://www.keio.ac.jp>Keio</a>, <a href=http://ev.buaa.edu.cn>Beihang</a>), All Rights
            Reserved. W3C <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a
                href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a
                href="https://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.
        </p>
        <hr title="Separator for header">
    </div>

    <h2 class="no-num no-toc no-ref heading settled heading" id=abstract><span class=content>摘要</span></h2>
    <p class=p-summary data-fill-with=abstract>本规范定义了 CSS 的各种作用域/封装机制，包括作用域样式和 <a class=css data-link-type=maybe
            href=#at-ruledef-scope title=@scope>@scope</a> 规则、Shadow DOM 选择器，以及基于页面/区域的样式。
        <a href="https://www.w3.org/TR/CSS/">CSS</a> 是一种用于描述结构化文档（如 HTML 和 XML）在屏幕、纸张、语音等上的呈现的语言。
    </p>

    <h2 class="no-num no-toc no-ref heading settled heading" id=status><span class=content>本文档状态</span></h2>
    <div data-fill-with=status>
        <p><em>本节描述了本文档在发布时的状态。其他文档可能会取代本文件。当前 W3C 发布物的列表及本技术报告的最新修订版可在
                <a href="https://www.w3.org/TR/">W3C 技术报告索引 http://www.w3.org/TR/</a> 查阅。</em>

        <p>本文件是 <b>首次公开工作草案</b>。

        <p>作为首次公开工作草案发布，并不意味着 W3C 成员的认可。此为草案文件，可能随时被更新、替换或废弃。除作为进行中的工作外，不应引用本文件。

        <p>（<a href=http://lists.w3.org/Archives/Public/www-style>存档</a>）公共邮件列表 <a
                href=mailto:www-style@w3.org>www-style@w3.org</a>（见
            <a href="https://www.w3.org/Mail/Request">说明</a>）是讨论本规范的首选渠道。发送邮件时，请在主题中注明“css-scoping”，建议格式如下：
            “[css-scoping] <em>…评论摘要…</em>”

        <p>本文件由 <a href="https://www.w3.org/Style/CSS/members">CSS 工作组</a>（隶属于
            <a href="https://www.w3.org/Style/">样式活动</a>）制定。

        <p>本文件由遵循 <a href="https://www.w3.org/Consortium/Patent-Policy-20040205/">2004年2月5日 W3C 专利政策</a> 的工作组制定。W3C 保有
            <a href="https://www.w3.org/2004/01/pp-impl/32061/status"
                rel=disclosure>与本组交付物相关的公开专利披露列表</a>；该页面还包括专利披露说明。知晓某项专利且认为其中包含
            <a href="https://www.w3.org/Consortium/Patent-Policy-20040205/#def-essential">必要权利要求</a> 的个人，须依
            <a href="https://www.w3.org/Consortium/Patent-Policy-20040205/#sec-Disclosure">W3C 专利政策第6节</a> 披露相关信息。
        </p>
    </div>
    <div data-fill-with=at-risk></div>

    <h2 class="no-num no-toc no-ref heading settled heading" id=contents><span class=content>目录</span></h2>
    <div data-fill-with=table-of-contents>
        <ul class=toc>
            <li><a href=#intro><span class=secno>1</span> 引言</a>
            <li><a href=#scope><span class=secno>2</span> 作用域样式</a>
                <ul class=toc>
                    <li><a href=#scoping-mechanisms><span class=secno>2.1</span> 作用域机制</a>
                        <ul class=toc>
                            <li><a href=#scoping-markup><span class=secno>2.1.1</span> 用于作用域的文档标记</a>
                            <li><a href=#scope-atrule><span class=secno>2.1.2</span> CSS 作用域语法：<span class=css
                                        data-link-type=maybe title=@scope>@scope</span> 规则</a>
                        </ul>
                    <li><a href=#scoping-context><span class=secno>2.2</span> 查询作用域上下文</a>
                        <ul class=toc>
                            <li><a href=#scope-pseudo><span class=secno>2.2.1</span> 选择作用域根：<span class=css
                                        data-link-type=maybe title=:scope>:scope</span> 伪类</a>
                            <li><a href=#scope-content-pseudo><span class=secno>2.2.2</span> 选择作用域外部：<span class=css
                                        data-link-type=maybe title=:scope-context()>:scope-context()</span> 伪类</a>
                        </ul>
                </ul>
            <li><a href=#shadow-dom><span class=secno>3</span> Shadow 封装</a>
                <ul class=toc>
                    <li><a href=#selectors-data-model><span class=secno>3.1</span> Shadow DOM 选择模型</a>
                        <ul class=toc>
                            <li><a href=#host-element><span class=secno>3.1.1</span> 影子树中的宿主元素</a>
                        </ul>
                    <li><a href=#selectors><span class=secno>3.2</span> Shadow DOM 选择器</a>
                        <ul class=toc>
                            <li><a href=#host-selector><span class=secno>3.2.1</span> 亮区选择：<span class=css
                                        data-link-type=maybe title=:host>:host</span>、<span class=css
                                        data-link-type=maybe title=:host()>:host()</span> 和 <span class=css
                                        data-link-type=maybe title=:host-context()>:host-context()</span> 伪类</a>
                            <li><a href=#shadow-pseudoelement><span class=secno>3.2.2</span> 选择暗区：<span class=css
                                        data-link-type=maybe title=::shadow>::shadow</span> 伪元素</a>
                            <li><a href=#content-combinator><span class=secno>3.2.3</span> 选择 Shadow 投影内容：<span
                                        class=css data-link-type=maybe title=::content>::content</span> 伪元素</a>
                            <li><a href=#deep-combinator><span class=secno>3.2.4</span> 穿透 Shadow 选择：<span class=css
                                        data-link-type=maybe title=/deep>/deep/</span> 组合器</a>
                        </ul>
                    <li><a href=#shadow-cascading><span class=secno>3.3</span> Shadow 级联与继承</a>
                        <ul class=toc>
                            <li><a href=#cascading><span class=secno>3.3.1</span> 级联</a>
                            <li><a href=#inheritance><span class=secno>3.3.2</span> 继承</a>
                        </ul>
                </ul>
            <li><a href=#fragment-scoping><span class=secno>4</span> 分片样式</a>
                <ul class=toc>
                    <li><a href=#the-region-pseudo-element><span class=secno>4.1</span> 基于区域的样式：<span class=css
                                data-link-type=maybe title=::region>::region</span> 伪元素</a>
                </ul>
            <li><a href=#conformance><span class=secno></span> 符合性</a>
                <ul class=toc>
                    <li><a href=#conventions><span class=secno></span> 文档约定</a>
                    <li><a href=#conformance-classes><span class=secno></span> 符合性类别</a>
                    <li><a href=#partial><span class=secno></span> 部分实现</a>
                    <li><a href=#experimental><span class=secno></span> 实验性实现</a>
                    <li><a href=#testing><span class=secno></span> 非实验性实现</a>
                </ul>
            <li><a href=#references><span class=secno></span> 参考文献</a>
                <ul class=toc>
                    <li><a href=#normative><span class=secno></span> 规范性引用</a>
                    <li><a href=#informative><span class=secno></span> 资料性引用</a>
                </ul>
            <li><a href=#index><span class=secno></span> 索引</a>
            <li><a href=#property-index><span class=secno></span> 属性索引</a>
            <li><a href=#issues-index><span class=secno></span>问题索引</a>
        </ul>
    </div>



    <h2 class="heading settled heading" data-level=1 id=intro><span class=secno>1 </span><span class=content>
            引言</span><a class=self-link href=#intro></a></h2>

    <p> ...


    <h2 class="heading settled heading" data-level=2 id=scope><span class=secno>2 </span><span class=content>
            作用域样式</span><a class=self-link href=#scope></a></h2>

    <p> <a data-link-type=dfn href="https://www.w3.org/TR/css3-cascade/#scoped" title=scoped>作用域</a>样式规则
        仅适用于文档的某个子树，
        而不是匹配整个文档。
        作用域有两个主要影响：
    <ul>
        <li><a data-link-type=dfn href="https://www.w3.org/TR/css3-cascade/#scoped"
                title=scoped>作用域</a>样式规则的选择器被限制为只匹配作用域内的元素。
            参见<a href="https://www.w3.org/TR/selectors4/#scoping">作用域选择器</a>，见<a data-biblio-type=informative
                data-link-type=biblio href=#selectors4 title=selectors4>[SELECTORS4]</a>。
        <li>级联在优先级上会将作用域规则置于非作用域规则之上，无论其具体的优先级如何。
            参见<a href="https://www.w3.org/TR/css-cascade/#cascade-scope">按作用域级联</a>，见<a data-biblio-type=informative
                data-link-type=biblio href=#css3cascade title=css3cascade>[CSS3CASCADE]</a>。
    </ul>

    <h3 class="heading settled heading" data-level=2.1 id=scoping-mechanisms><span class=secno>2.1 </span><span
            class=content>
            作用域机制</span><a class=self-link href=#scoping-mechanisms></a></h3>

    <p> 样式规则可以通过文档语言中定义的结构
        或者通过 CSS 中的<a class=css data-link-type=maybe href=#at-ruledef-scope title=@scope>@scope</a>规则进行作用域限制。

    <h4 class="heading settled heading" data-level=2.1.1 id=scoping-markup><span class=secno>2.1.1 </span><span
            class=content>
            用于作用域的文档标记</span><a class=self-link href=#scoping-markup></a></h4>

    <p> 文档语言可以定义机制，让样式表作用于文档中的某个元素。
        例如，在 HTML 中，
        带有<a data-link-type=element href="https://www.w3.org/TR/html5/document-metadata.html#the-style-element"
            title=style>style</a>元素和<a data-link-for=style data-link-type=element-attr title=scoped>scoped</a>属性
        的样式表会作用于该<a data-link-type=element href="https://www.w3.org/TR/html5/document-metadata.html#the-style-element"
            title=style>style</a>元素的父元素。
        <a data-biblio-type=informative data-link-type=biblio href=#html title=html>[HTML]</a>

    <h4 class="heading settled heading" data-level=2.1.2 id=scope-atrule><span class=secno>2.1.2 </span><span
            class=content>
            CSS 作用域语法：<a class=css data-link-type=maybe href=#at-ruledef-scope title=@scope>@scope</a>规则</span><a
            class=self-link href=#scope-atrule></a></h4>

    <p> <dfn class=css-code data-dfn-type=at-rule data-export="" id=at-ruledef-scope>@scope<a class=self-link
                href=#at-ruledef-scope></a></dfn> 规则允许作者通过 CSS 语法编写作用域样式规则。
        <a class=css data-link-type=maybe href=#at-ruledef-scope title=@scope>@scope</a>规则的语法如下：

    <pre class=prod>@scope <a class="production css-code" data-link-type=type href="https://www.w3.org/TR/selectors4/#ltselector" title="<selector>">&lt;selector&gt;</a> {
  <a class="production css-code" data-link-type=type href="https://www.w3.org/TR/css3-syntax/#typedef-stylesheet" title="<stylesheet>">&lt;stylesheet&gt;</a>
}
</pre>
    <p> 其中，被<a class="production css-code" data-link-type=type href="https://www.w3.org/TR/selectors4/#ltselector"
            title="<selector>">&lt;selector&gt;</a>匹配到的元素
        是<a data-link-type=dfn href=http://dev.w3.org/csswg/selectors-4/#scoping-root title="scoping roots">作用域根</a>，
        用于内部<a class="production css-code" data-link-type=type
            href="https://www.w3.org/TR/css3-syntax/#typedef-stylesheet"
            title="<stylesheet>">&lt;stylesheet&gt;</a>的样式规则。
        被<a class=css data-link-type=maybe href=#at-ruledef-scope title=@scope>@scope</a>作用域限定的样式规则选择器
        被<a data-link-type=dfn href=http://dev.w3.org/csswg/selectors-4/#scope-contained-
            title=scope-contained>约束在其</a><a data-link-type=dfn href=http://dev.w3.org/csswg/selectors-4/#scoping-root
            title="scoping root">作用域根</a>内。

    <p class=issue id=issue-5f568f10><a class=self-link href=#issue-5f568f10></a>
        该规则使作者很容易创建作用域样式表，
        这可能会影响作用域样式实现的优化策略。

    <p> 如果有多个元素匹配<a class="production css-code" data-link-type=type href="https://www.w3.org/TR/selectors4/#ltselector"
            title="<selector>">&lt;selector&gt;</a>，
        <a class="production css-code" data-link-type=type href="https://www.w3.org/TR/css3-syntax/#typedef-stylesheet"
            title="<stylesheet>">&lt;stylesheet&gt;</a>会被有效地复制，
        并且分别独立地应用于每个匹配元素。
        作者应避免使用过于通用的选择器，
        否则可能会与级联产生令人困惑的交互效果。

    <div class=example>
        作用域样式表不仅附加在最外层的作用域元素上，
        还会附加在所有匹配的元素上。
        例如，给定如下样式表
        <pre>@scope div {
  span {
    color: blue;
  }
}
@scope section {
  span {
    color: orange;
  }
}
</pre>
        <p> 以及如下文档片段

        <pre>&lt;div&gt;
  &lt;section&gt;
    &lt;div&gt;
      &lt;span&gt;text&lt;/span&gt;
    &lt;/div&gt;
  &lt;/section&gt;
&lt;/div&gt;
</pre>
        <p> 其中的文本将会是蓝色。
    </div>

    <p> <a class=css data-link-type=maybe href=#at-ruledef-scope title=@scope>@scope</a>规则可以嵌套。
        在这种情况下，与嵌套样式规则类似，
        外层<a class=css data-link-type=maybe href=#at-ruledef-scope title=@scope>@scope</a>的选择器
        作用域包含内层的选择器。

    <p> <a class=css data-link-type=maybe href=#at-ruledef-scope title=@scope>@scope</a>规则内部选择器的优先级是局部计算的：
        用于指定作用域元素的选择器会被忽略。
        但由于作用域内样式会覆盖非作用域样式，
        <a class=css data-link-type=maybe href=#at-ruledef-scope title=@scope>@scope</a>内部的规则会覆盖其外部的规则。

    <div class=example>
        在以下示例中，文本将会是绿色：

        <pre>  @scope aside {
    p { color: green; }
  }
  aside#sidebar p { color: red; }
</pre>
    </div>

    <p class=issue id=issue-5c7571b6><a class=self-link href=#issue-5c7571b6></a>
        如果多个<a class=css data-link-type=maybe href=#at-ruledef-scope title=@scope>@scope</a>规则应用于同一个元素，
        它们是否应该按优先级进行级联？

    <h3 class="heading settled heading" data-level=2.2 id=scoping-context><span class=secno>2.2 </span><span
            class=content>
            查询作用域上下文</span><a class=self-link href=#scoping-context></a></h3>

    <h4 class="heading settled heading" data-level=2.2.1 id=scope-pseudo><span class=secno>2.2.1 </span><span
            class=content>
            选择作用域根：<a class=css data-link-type=maybe href="https://www.w3.org/TR/selectors4/#scope-pseudo"
                title=:scope>:scope</a>伪类</span><a class=self-link href=#scope-pseudo></a></h4>

    <p> 在作用域样式表中，
        <a class=css data-link-type=maybe href="https://www.w3.org/TR/selectors4/#scope-pseudo"
            title=:scope>:scope</a>伪类，
        定义见<a data-biblio-type=informative data-link-type=biblio href=#selectors4 title=selectors4>[SELECTORS4]</a>，
        匹配<a data-link-type=dfn href=http://dev.w3.org/csswg/selectors-4/#scoping-root title="scoping root">作用域根</a>。

    <h4 class="heading settled heading" data-level=2.2.2 id=scope-content-pseudo><span class=secno>2.2.2 </span><span
            class=content>
            选择作用域外部：<span class=css data-link-type=maybe title=:scope-context()>:scope-context()</span>伪类</span><a
            class=self-link href=#scope-content-pseudo></a></h4>

    <div class=issue id=issue-aecbd194><a class=self-link href=#issue-aecbd194></a>
        该机制的定义方式与<a class=css data-link-type=maybe href=#selectordef-host-context
            title=:host-context()>:host-context()</a>类似，
        但匹配的是<a data-link-type=dfn href=http://dev.w3.org/csswg/selectors-4/#scoping-root
            title="scoping root">作用域根</a>的祖先。

        <p> 然而，对于作用域样式表，你可能希望能够对外部树使用复杂选择器进行匹配，
            而非仅仅是单一的复合选择器，
            所以我们或许需要采用一种不会在语法上反转树元素顺序的更通用机制。

        <p> 可能的设想：

        <pre>:scope-context(<a class="production css-code" data-link-type=type href="https://www.w3.org/TR/selectors4/#ltselector" title="<selector>">&lt;selector&gt;</a>) div {...}
scope(<a class="production css-code" data-link-type=type href="https://www.w3.org/TR/selectors4/#ltselector" title="<selector>">&lt;selector&gt;</a>) div {...}
\scope <a class="production css-code" data-link-type=type href="https://www.w3.org/TR/selectors4/#ltselector" title="<selector>">&lt;selector&gt;</a>\ div {...}
<a class="production css-code" data-link-type=type href="https://www.w3.org/TR/selectors4/#ltselector" title="<selector>">&lt;selector&gt;</a> \scope\ div {...}
</pre>
        <p> 该功能将取代<span class=css data-link-type=maybe title=@global>@global</span>，因为@global作为选择器并不理想。
    </div>

    <h2 class="heading settled heading" data-level=3 id=shadow-dom><span class=secno>3 </span><span class=content>
            Shadow 封装</span><a class=self-link href=#shadow-dom></a></h2>

    <p> Shadow DOM 规范为 DOM 增加了若干新概念，
        其中有些与 CSS 相关。

    <p> <dfn data-dfn-type=dfn data-export="" id=shadow-tree>影子树<a class=self-link href=#shadow-tree></a></dfn>是一段文档片段，
        可以附加到 DOM 的任意元素上。
        <a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>的根是<dfn data-dfn-type=dfn data-export=""
            id=shadow-root>影子根<a class=self-link href=#shadow-root></a></dfn>，
        它是一个与<a data-link-type=dfn href=#shadow-host title="shadow host">影子宿主</a>相关联的非元素节点。
        一个元素可以有任意数量的<a data-link-type=dfn href=#shadow-tree title="shadow trees">影子树</a>，
        并按创建时间排序。
        某元素最新创建的<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>
        就是该元素的<dfn data-dfn-type=dfn data-export="" id=active-shadow-tree>活动影子树<a class=self-link
                href=#active-shadow-tree></a></dfn>。

    <p> 带有<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>的元素称为<dfn data-dfn-type=dfn data-export=""
            id=shadow-host>影子宿主<a class=self-link href=#shadow-host></a></dfn>。
        它对于其影子树来说是<dfn data-dfn-type=dfn data-export="" id=host-element0>宿主元素<a class=self-link
                href=#host-element0></a></dfn>。

    <p> <a data-link-type=dfn href=#shadow-host title="shadow host">影子宿主</a>的后代
        不应在格式化树中生成盒子。
        相反，<a data-link-type=dfn href=#active-shadow-tree title="active shadow tree">活动影子树</a>的内容
        会像元素内容一样生成盒子。

    <p> 在 shadow DOM 的某些情况下，
        元素没有元素父节点
        （而是有<a data-link-type=dfn href=#shadow-root title="shadow root">影子根</a>或其他东西作为父节点）。
        没有父节点或父节点不是元素的元素，
        被称为<dfn data-dfn-type=dfn data-export="" id=top-level-element>顶层元素<a class=self-link
                href=#top-level-element></a></dfn>。

    <p> 尽管<a data-link-type=dfn href=#shadow-host title="shadow host">影子宿主</a>的子元素不会正常生成盒子，
        它们可以被显式分配到<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>并强制正常渲染。
        这是通过将元素分配到<dfn data-dfn-type=dfn data-export="" id=distribution-list>分发列表<a class=self-link
                href=#distribution-list></a></dfn>来完成的。
        带有<a data-link-type=dfn href=#distribution-list title="distribution list">分发列表</a>的元素被称为<dfn data-dfn-type=dfn
            data-export="" id=insertion-point>插入点<a class=self-link href=#insertion-point></a></dfn>。

    <p> 本规范不定义如何将元素分配到<a data-link-type=dfn href=#distribution-list title="distribution list">分发列表</a>，
        而是交由 Shadow DOM 规范处理。
        在本规范编写时，
        只有<a data-link-type=element title=content>content</a>元素在<a data-link-type=dfn href=#shadow-tree
            title="shadow tree">影子树</a>中可以拥有<a data-link-type=dfn href=#distribution-list
            title="distribution lists">分发列表</a>。

    <p> <a data-link-type=dfn href=#insertion-point title="insertion point">插入点</a>不能生成任何盒子。
        相反，其<a data-link-type=dfn href=#distribution-list title="distribution list">分发列表</a>中的元素会正常生成盒子，
        就像它们直接替换<a data-link-type=dfn href=#insertion-point title="insertion point">插入点</a>一样。
        <span class=note>（类似于<a class=css data-link-type=propdesc
                href=http://dev.w3.org/csswg/css-display-3/#propdef-display-box title=display-box>display-box:
                contents</a>的行为。）</span>

    <h3 class="heading settled heading" data-level=3.1 id=selectors-data-model><span class=secno>3.1 </span><span
            class=content>
            Shadow DOM 选择模型</span><a class=self-link href=#selectors-data-model></a></h3>

    <p> <a data-link-type=dfn href=http://dev.w3.org/csswg/selectors-4/#element-tree title="element tree">元素树</a>中的元素
        还可以拥有零个或多个<a data-link-type=dfn href=#shadow-tree title="shadow trees">影子树</a>
        以及零个或一个<a data-link-type=dfn href=#distribution-list title="distribution lists">分发列表</a>。

    <p class=note> 注意：元素的“后代”
        是基于元素的子元素，
        不包括元素的<a data-link-type=dfn href=#shadow-tree title="shadow trees">影子树</a>或<a data-link-type=dfn
            href=#distribution-list title="distribution lists">分发列表</a>。

    <p> 当选择器匹配<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>时，
        <a data-link-type=dfn href=http://dev.w3.org/csswg/selectors-4/#initial-selector-match-list
            title="initial selector match list">初始选择器匹配列表</a>
        包括<a data-link-type=dfn href=#shadow-host title="shadow host">影子宿主</a>，
        后面是<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>的所有<a data-link-type=dfn
            href=#top-level-element title="top-level elements">顶层元素</a>
        及其后代，
        按照先序遍历排序。

    <h4 class="heading settled heading" data-level=3.1.1 id=host-element><span class=secno>3.1.1 </span><span
            class=content>
            影子树中的宿主元素</span><a class=self-link href=#host-element></a></h4>

    <p> <a data-link-type=dfn href=#shadow-host title="shadow host">影子宿主</a>处于其所承载的<a data-link-type=dfn
            href=#shadow-tree title="shadow trees">影子树</a>之外，
        但有时需要在<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>上下文中为其设置样式。

    <p> 对于选择器而言，
        <a data-link-type=dfn href=#host-element0 title="host element">宿主元素</a>也会出现在其每一个<a data-link-type=dfn
            href=#shadow-tree title="shadow trees">影子树</a>中，
        此时<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>的内容被视为它的子元素。
        如果一个元素有多个<a data-link-type=dfn href=#shadow-tree title="shadow trees">影子树</a>，
        它会分别在每个<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>的上下文中出现；
        每个<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>只看到<em>自己</em>作为<a data-link-type=dfn
            href=#host-element0 title="host element">宿主元素</a>的内容，
        而看不到其他<a data-link-type=dfn href=#shadow-tree title="shadow trees">影子树</a>。

    <p> <a data-link-type=dfn href=#host-element0 title="host element">宿主元素</a>不能通过<strong>任何方式</strong>
        被选择，
        除了<a class=css data-link-type=maybe href=#selectordef-host0 title=:host>:host</a>和<a class=css
            data-link-type=maybe href=#selectordef-host-context title=:host-context()>:host-context()</a>
        伪类。
        也就是说，在该上下文中<a data-link-type=dfn href=#shadow-host title="shadow host">影子宿主</a>
        没有标签名、ID、类名或属性，
        唯一额外的信息就是<a class=css data-link-type=maybe href=#selectordef-host0 title=:host>:host</a>伪类能够匹配它。
        特别地，<a data-link-type=dfn href=#host-element0 title="host element">宿主元素</a>也不会被<span class=css
            data-link-type=maybe title=*>*</span>选择器匹配。

    </p>
    <details class=why>
        <summary>为什么影子宿主这么特殊？</summary>

        <p> <a data-link-type=dfn href=#shadow-host title="shadow host">影子宿主</a>处于<a data-link-type=dfn
                href=#shadow-tree title="shadow tree">影子树</a>之外，
            其标记由页面作者控制，
            而不是组件作者。

        <p> 如果一个组件在<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>内使用了某个类名，
            页面作者在使用该组件时无意中也用同样的类名给<a data-link-type=dfn href=#host-element0 title="host element">宿主元素</a>添加了该类名，
            就会产生组件作者无法预期、页面作者难以调试的意外样式。

        <p> 但仍有一些合理场景需要让<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>中的样式表
            为<a data-link-type=dfn href=#host-element0 title="host element">宿主元素</a>设定样式。
            因此，为了允许这种情况并避免意外样式，
            <a data-link-type=dfn href=#host-element0 title="host element">宿主元素</a>出现但完全没有特征，
            只能通过<a class=css data-link-type=maybe href=#selectordef-host0 title=:host>:host</a>选择。
    </details>


    <h3 class="heading settled heading" data-level=3.2 id=selectors><span class=secno>3.2 </span><span class=content>
            Shadow DOM 选择器</span><a class=self-link href=#selectors></a></h3>

    <p> Shadow DOM 定义了一些新选择器，
        用于和 Shadow DOM 相关的元素选择。

    <p class=issue id=issue-dea392ae><a class=self-link href=#issue-dea392ae></a>
        本节仍在讨论中，
        欢迎就以下功能的直观语法提出建议和反馈。

    <h4 class="heading settled heading" data-level=3.2.1 id=host-selector><span class=secno>3.2.1 </span><span
            class=content>
            亮区选择：<a class=css data-link-type=maybe href=#selectordef-host0 title=:host>:host</a>、<a class=css
                data-link-type=maybe href=#selectordef-host title=:host()>:host()</a>和<a class=css data-link-type=maybe
                href=#selectordef-host-context title=:host-context()>:host-context()</a>伪类</span><a class=self-link
            href=#host-selector></a></h4>

    <p> <dfn class=css-code data-dfn-type=selector data-export="" id=selectordef-host0>:host<a class=self-link
                href=#selectordef-host0></a></dfn> 伪类，
        在<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>上下文中计算时，
        匹配<a data-link-type=dfn href=#shadow-tree title="shadow tree’s">影子树</a>的<a data-link-type=dfn
            href=#host-element0 title="host element">宿主元素</a>。
        在其他上下文中，
        匹配不到任何元素。

    <p> <dfn class=css-code data-dfn-type=selector data-export="" id=selectordef-host>:host()<a class=self-link
                href=#selectordef-host></a></dfn> 函数伪类
        语法如下：

    <pre>:host( <a class="production css-code" data-link-type=type href="https://www.w3.org/TR/selectors4/#ltcompound-selector" title="<compound-selector>">&lt;compound-selector&gt;</a> )</pre>
    <p> 在<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>上下文中计算时，
        如果<a data-link-type=dfn href=#host-element0 title="host element">宿主元素</a>
        在其普通上下文中匹配该选择器参数，则匹配该元素。
        在其他上下文中，
        匹配不到任何元素。

    <div class=example>
        例如，假设你有一个组件，其<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>如下：

        <pre>  &lt;x-foo class="foo"&gt;
    &lt;"shadow tree"&gt;
      &lt;div class="foo"&gt;...&lt;/div&gt;
    &lt;/&gt;
  &lt;/x-foo&gt;
</pre>
        <p> 对于影子树内部的样式表：

        <p>
        <ul>
            <li><a class=css data-link-type=maybe href=#selectordef-host0 title=:host>:host</a>
                匹配<code>&lt;x-foo&gt;</code>元素。
            <li><span class=css data-link-type=maybe title=x-foo>x-foo</span> 匹配不到任何元素。
            <li><span class=css data-link-type=maybe title=.foo>.foo</span> 只匹配<code>&lt;div&gt;</code>元素。
            <li><span class=css data-link-type=maybe title=.foo:host>.foo:host</span> 匹配不到任何元素
            <li><span class=css data-link-type=maybe title=:host(.foo)>:host(.foo)</span>
                匹配<code>&lt;x-foo&gt;</code>元素。
        </ul>
    </div>

    <p> 通常情况下，<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>内的选择器
        不能看到影子树之外的任何元素。
        但有时，选择影子树上方文档中的某个祖先是有用的。

    <div class=example>
        例如，一组组件可以定义一些它们能够响应的配色主题。
        页面作者可以通过在组件或更高层的文档结构中添加特定类来选择某个主题。
    </div>

    <p> <dfn class=css-code data-dfn-type=selector data-export="" id=selectordef-host-context>:host-context()<a
                class=self-link href=#selectordef-host-context></a></dfn> 函数伪类可测试在影子树外部是否有某个祖先
        匹配给定选择器。
        其语法为：

    <pre>:host-context( <a class="production css-code" data-link-type=type href="https://www.w3.org/TR/selectors4/#ltcompound-selector" title="<compound-selector>">&lt;compound-selector&gt;</a> )</pre>
    <p> 在<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>上下文中计算时，
        <a class=css data-link-type=maybe href=#selectordef-host-context title=:host-context()>:host-context()</a>
        伪类会匹配<a data-link-type=dfn href=#host-element0 title="host element">宿主元素</a>，
        如果<a data-link-type=dfn href=#host-element0 title="host element">宿主元素</a>或其某个祖先匹配参数选择器。
        对于该伪类而言，
        元素的“祖先”定义如下：

    <dl>
        <dt>如果元素被分发到<a data-link-type=dfn href=#distribution-list title="distribution list">分发列表</a>
        <dd>
            即其最终分发到的<a data-link-type=element title=content>content</a>元素。

        <dt>如果元素是影子树的顶层元素
        <dd>
            即<a data-link-type=dfn href=#host-element0 title="host element">宿主元素</a>

        <dt>否则
        <dd>
            即该元素的父节点（如果存在）。
    </dl>

    <p class=note> 注意：这意味着该选择器会穿透 shadow 边界向上查找，
        直到遇到文档根节点为止，查找所有匹配参数的元素。

    <h4 class="heading settled heading" data-level=3.2.2 id=shadow-pseudoelement><span class=secno>3.2.2 </span><span
            class=content>
            选择暗区：<a class=css data-link-type=maybe href=#selectordef-shadow title=::shadow>::shadow</a> 伪元素</span><a
            class=self-link href=#shadow-pseudoelement></a></h4>

    <p> 如果一个元素拥有至少一个<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>，
        <dfn class=css-code data-dfn-type=selector data-export="" id=selectordef-shadow>::shadow<a class=self-link
                href=#selectordef-shadow></a></dfn> 伪元素会匹配<a data-link-type=dfn href=#shadow-root
            title="shadow roots">影子根</a>本身。
        在 HTML 中，<a data-link-type=dfn href=#shadow-root title="shadow root">影子根</a>由 <a class=idl-code
            data-link-type=interface title=shadowroot>ShadowRoot</a> 对象表示。

    <p> <a class=css data-link-type=maybe href=#selectordef-shadow title=::shadow>::shadow</a> 伪元素不能生成盒子，
        除非其他规范另有规定。
        但对于选择器而言，
        <a class=css data-link-type=maybe href=#selectordef-shadow title=::shadow>::shadow</a> 伪元素被视为<a
            data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>的根节点，
        <a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>中的<a data-link-type=dfn
            href=#top-level-element title="top-level elements">顶层元素</a>是 <a class=css data-link-type=maybe
            href=#selectordef-shadow title=::shadow>::shadow</a> 伪元素的直接子元素。

    <div class=example>
        例如，假设你有一个组件，其<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>如下：

        <pre>  &lt;x-foo&gt;
    &lt;"shadow tree"&gt;
      &lt;div&gt;
        &lt;span id="not-top"&gt;...&lt;/span&gt;
      &lt;/div&gt;
      &lt;span id="top"&gt;...&lt;/span&gt;
    &lt;/&gt;
  &lt;/x-foo&gt;
</pre>
        <p> 对于外部文档中的样式表，
            <span class=css data-link-type=maybe title="x-foo::shadow > span">x-foo::shadow &gt; span</span> 匹配
            <span class=css data-link-type=maybe title=#top>#top</span>，
            而不会匹配 <span class=css data-link-type=maybe title=#not-top>#not-top</span>，
            因为它不是<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>中的<a data-link-type=dfn
                href=#top-level-element title="top-level element">顶层元素</a>。

        <p> 如果想要选中 <span class=css data-link-type=maybe title=#not-top>#not-top</span>，
            可以使用 <span class=css data-link-type=maybe title="x-foo::shadow > div > span">x-foo::shadow &gt; div &gt;
                span</span>。
            但这种做法会让样式强依赖于组件的内部结构；
            更多时候，建议使用后代组合器，
            如 <span class=css data-link-type=maybe title="x-foo::shadow span">x-foo::shadow span</span>，
            以选择<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>中所有相应类型的元素。
    </div>

    <div class=example>
        如果某个元素有多个<a data-link-type=dfn href=#shadow-tree title="shadow trees">影子树</a>，
        一个<a class=css data-link-type=maybe href=#selectordef-shadow title=::shadow>::shadow</a>伪元素会选中
        <em>所有</em>对应的<a data-link-type=dfn href=#shadow-root title="shadow roots">影子根</a>。

        <p> 同样，
            在<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>内部，
            使用类似 <span class=css data-link-type=maybe title=":host::shadow div">:host::shadow div</span> 的选择器
            会选中该元素所有<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>内的 <a data-link-type=element
                href="https://www.w3.org/TR/html5/grouping-content.html#the-div-element" title=div>div</a> 元素，
            而不是只选中当前选择器所在的影子树。
    </div>



    <h4 class="heading settled heading" data-level=3.2.3 id=content-combinator><span class=secno>3.2.3 </span><span
            class=content>
            选择 Shadow 投影内容：<a class=css data-link-type=maybe href=#selectordef-content title=::content>::content</a>
            伪元素</span><a class=self-link href=#content-combinator></a></h4>

    <p> <dfn class=css-code data-dfn-type=selector data-export="" id=selectordef-content>::content<a class=self-link
                href=#selectordef-content></a></dfn> 伪元素匹配拥有<a data-link-type=dfn href=#distribution-list
            title="distribution list">分发列表</a>的元素本身。

    <p class=issue id=issue-1b6118ae><a class=self-link href=#issue-1b6118ae></a>
        <a class=css data-link-type=maybe href=#selectordef-content title=::content>::content</a> 作为名称过于宽泛，
        其实它只针对影子树的投影内容。

    <p> <a class=css data-link-type=maybe href=#selectordef-content title=::content>::content</a> 伪元素不能生成盒子，
        除非其他规范另有规定。
        但对于选择器而言，
        <a class=css data-link-type=maybe href=#selectordef-content title=::content>::content</a> 伪元素被视为
        <a data-link-type=dfn href=#distribution-list title="distribution list">分发列表</a>中元素的父节点。

    <div class=example>
        例如，假设你有一个同时拥有子元素和影子树的组件，如下：

        <pre>  &lt;x-foo&gt;
    &lt;div id="one" class="foo"&gt;...&lt;/div&gt;
    &lt;div id="two"&gt;...&lt;/div&gt;
    &lt;div id="three" class="foo"&gt;
      &lt;div id="four"&gt;...&lt;/div&gt;
    &lt;/div&gt;
    &lt;"shadow tree"&gt;
      &lt;div id="five"&gt;...&lt;/div&gt;
      &lt;div id="six"&gt;...&lt;/div&gt;
      &lt;content select=".foo"&gt;&lt;/content&gt;
    &lt;/"shadow tree"&gt;
  &lt;/x-foo&gt;
</pre>
        <p> 对于<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>内的样式表，
            类似 <span class=css data-link-type=maybe title="::content div">::content div</span> 的选择器
            会选中 <span class=css data-link-type=maybe title=#one>#one</span>、<span class=css data-link-type=maybe
                title=#three>#three</span> 和 <span class=css data-link-type=maybe title=#four>#four</span>，
            因为这些元素由唯一的 <a data-link-type=element title=content>content</a> 元素投影而来，
            而 <span class=css data-link-type=maybe title=#two>#two</span> 不会被选中。

        <p> 如果只希望选中 <a data-link-type=element title=content>content</a> 元素投影的<a data-link-type=dfn
                href=#top-level-element title="top-level elements">顶层元素</a>，
            可以使用<a data-link-type=dfn href="https://www.w3.org/TR/selectors4/#child-combinator"
                title="child combinator">子代组合器</a>，
            如 <span class=css data-link-type=maybe title="::content > div">::content &gt; div</span>，
            这样 <span class=css data-link-type=maybe title=#four>#four</span> 就不会被选中，
            因为它不是 <a class=css data-link-type=maybe href=#selectordef-content title=::content>::content</a> 伪元素的子元素。

        <p class=note> 注意：<span class=css data-link-type=maybe title="::content div">::content div</span> 选择器
            等价于 <span class=css data-link-type=maybe title="*::content div">*::content div</span>，
            其中 <span class=css data-link-type=maybe title=*>*</span> 会选中更多元素而不仅仅是 <a data-link-type=element
                title=content>content</a> 元素。
            但实际上只有 <a data-link-type=element title=content>content</a> 元素拥有<a data-link-type=dfn href=#distribution-list
                title="distribution list">分发列表</a>，
            也只有它拥有 <a class=css data-link-type=maybe href=#selectordef-content title=::content>::content</a> 伪元素。
    </div>


    <h4 class="heading settled heading" data-level=3.2.4 id=deep-combinator><span class=secno>3.2.4 </span><span
            class=content>
            穿透 Shadow 选择：<a class=css data-link-type=maybe href=#selectordef-deep title=/deep>/deep/</a> 组合器</span><a
            class=self-link href=#deep-combinator></a></h4>

    <p> 当选择器中遇到 <dfn class=css-code data-dfn-type=selector data-export="" id=selectordef-deep>/deep/<a class=self-link
                href=#selectordef-deep></a></dfn> 组合器时，
        会将 <a data-link-type=dfn href=http://dev.w3.org/csswg/selectors-4/#selector-match-list
            title="selector match list">选择器匹配列表</a>中的每个元素
        替换为从原始元素出发、通过任意数量的子元素列表或影子树遍历可达的所有元素。

    <div class=example>
        例如，假设你有一个组件，其<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>如下：

        <pre>  &lt;x-foo&gt;
    &lt;"shadow tree"&gt;
      &lt;div&gt;
        &lt;span id="not-top"&gt;...&lt;/span&gt;
      &lt;/div&gt;
      &lt;span id="top"&gt;...&lt;/span&gt;
      &lt;x-bar&gt;
        &lt;"shadow tree"&gt;
          &lt;span id="nested"&gt;...&lt;/span&gt;
        &lt;/&gt;
      &lt;/x-bar&gt;
    &lt;/&gt;
  &lt;/x-foo&gt;
</pre>
        <p> 对于外部文档中的样式表，
            选择器 <span class=css data-link-type=maybe title="x-foo /deep/ span">x-foo /deep/ span</span>
            会选中所有三个 <code>&lt;span&gt;</code> 元素：
            <span class=css data-link-type=maybe title=#top>#top</span>、<span class=css data-link-type=maybe
                title=#not-top>#not-top</span>，以及 <em><span class=css data-link-type=maybe
                    title=#nested>#nested</span></em>。
    </div>

    <p class=issue id=issue-250ee37f><a class=self-link href=#issue-250ee37f></a>
        这本质上是超级后代组合器。
        如果后代组合器有专门的符号，
        或许可以直接将其重复两次。
        或许我们可以给后代组合器一个别名 <span class=css data-link-type=maybe title=">>">&gt;&gt;</span>，
        因为它其实是超级子代组合器？
        那么 <a class=css data-link-type=maybe href=#selectordef-deep title=/deep>/deep/</a> 就可以写作 <span class=css
            data-link-type=maybe title=">>>">&gt;&gt;&gt;</span>




    <h3 class="heading settled heading" data-level=3.3 id=shadow-cascading><span class=secno>3.3 </span><span
            class=content>
            Shadow 级联与继承</span><a class=self-link href=#shadow-cascading></a></h3>

    <h4 class="heading settled heading" data-level=3.3.1 id=cascading><span class=secno>3.3.1 </span><span
            class=content>
            级联</span><a class=self-link href=#cascading></a></h4>

    <p> 为了实现针对影子根元素的级联行为，
        本规范扩展了级联规范中定义的 <a href=http://dev.w3.org/csswg/css-cascade/#cascading>级联顺序</a>。<a data-biblio-type=normative
            data-link-type=biblio href=#css3cascade title=css3cascade>[CSS3CASCADE]</a>

    <p> 需要在 Origin 和 Scope 之间增加一个级联判据，
        叫作 Shadow Tree（影子树）。

    <p>
    <ul>
        <li>
            比较两个声明时，
            如果一个在<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>中，
            另一个在包含该<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>的文档中，
            那么对于普通规则，外部文档的声明优先生效，
            对于 important 规则，<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>中的声明优先生效。

            <p class=note> 注意：这与作用域样式的行为<em>相反</em>。

        <li>
            比较两个声明时，
            如果它们都在同一个<a data-link-type=dfn href=#host-element0 title="host element">宿主元素</a>上的不同<a data-link-type=dfn
                href=#shadow-tree title="shadow trees">影子树</a>中，
            那么对于普通规则，最近创建的<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>中的声明优先生效，
            对于 important 规则，较早创建的<a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>中的声明优先生效。
    </ul>

    <p> 计算<a href=http://dev.w3.org/csswg/css-cascade/#cascade-order>出现顺序</a>时，
        使用 Shadow DOM 规范定义的树结构来计算顺序。

    <h4 class="heading settled heading" data-level=3.3.2 id=inheritance><span class=secno>3.3.2 </span><span
            class=content>
            继承</span><a class=self-link href=#inheritance></a></h4>

    <p> <a data-link-type=dfn href=#shadow-tree title="shadow tree">影子树</a>的<a data-link-type=dfn
            href=#top-level-element title="top-level elements">顶层元素</a>
        从其<a data-link-type=dfn href=#host-element0 title="host element">宿主元素</a>继承属性。

    <p> <a data-link-type=dfn href=#distribution-list title="distribution list">分发列表</a>中的元素
        从其最终分发到的<a data-link-type=element title=content>content</a>元素的父元素继承属性，
        而不是从其正常父元素继承。


    <h2 class="heading settled heading" data-level=4 id=fragment-scoping><span class=secno>4 </span><span class=content>
            分片样式</span><a class=self-link href=#fragment-scoping></a></h2>

    <p> 分片内容可以根据其出现的行、列、页面、区域等位置
        被赋予不同的样式。
        这可以通过使用合适的 <dfn data-dfn-type=dfn data-export="" id=fragment-pseudo-element>分片伪元素<a class=self-link
                href=#fragment-pseudo-element></a></dfn> 实现，
        允许只针对元素的特定片段而不是整个元素进行样式定义。

    <div class=example>
        在本示例中，
        设计师希望
        流入 #region1 的文本
        变为深蓝色并加粗。
        该设计可以如下表达：

        <pre>#region1::region p {
  color: #0C3D5F;
  font-weight: bold;
}
</pre>
        <p> 这里 <span class=css data-link-type=maybe title=::region>::region</span> 伪元素后面跟着 <span class=css
                data-link-type=maybe title=p>p</span> 相对选择器。
            color 和 font-weight 声明会应用于
            显示在 <span class=css data-link-type=maybe title=#region1>#region1</span> 的所有段落片段。
            下图展示了
            如果我们为 <span class=css data-link-type=maybe title=#region1>#region1</span> 应用该样式后
            渲染效果的变化。
            可以注意到，在字体加粗后，
            同样的盒子中能容纳的文本变少了。</p>

        <figure>
            <img alt="Illustrate how changing region styling affects the flow of content."
                src=https://www.w3.org/TR/css-scoping-1/images/region-styling.png width=450>

            <figcaption>不同区域样式下的不同渲染效果</figcaption>
        </figure>
    </div>

    <p class=note> 注意：该特性是 <span class=css data-link-type=maybe title=::first-line>::first-line</span> 样式的扩展。

    <h3 class="heading settled heading" data-level=4.1 id=the-region-pseudo-element><span class=secno>4.1 </span><span
            class=content>
            基于区域的样式：<span class=css data-link-type=maybe title=::region>::region</span>
            伪元素</span><a class=self-link href=#the-region-pseudo-element></a></h3>

    <div class=issue id=issue-f778a2c0><a class=self-link href=#issue-f778a2c0></a>
        扩展以指定：
        <ul>
            <li><span class=css data-link-type=maybe
                    title="<region-element-selector>::region">&lt;region-element-selector&gt;::region</span>
            <li><span class=css data-link-type=maybe
                    title="<paginated-element-selector>::page(<page-selector>)">&lt;paginated-element-selector&gt;::page(&lt;page-selector&gt;)</span>
            <li><span class=css data-link-type=maybe
                    title="<multicol-element>::column(<anb>)">&lt;multicol-element&gt;::column(&lt;AnB&gt;)</span>
            <li><span class=css data-link-type=maybe
                    title="<fragmented-element-selector>::nth-fragment(<anb>)">&lt;fragmented-element-selector&gt;::nth-fragment(&lt;AnB&gt;)</span>
            <li><span class=css data-link-type=maybe title=::first-line>::first-line</span>
        </ul>
    </div>

    <p>::region 伪元素表示一个选择器（匹配<span>CSS 区域</span>）与一个相对选择器（匹配某些命名流内容）之间的关系。
        这允许样式声明应用于流入特定区域的命名流内容片段。</p>

    <pre>&lt;region selector&gt;::region &lt;content selector&gt;  {
    ... CSS 样式声明 ...
}
</pre>
    <p>当 ::region 伪元素附加到一个
        匹配一个或多个<span title="CSS Region">CSS 区域</span>的
        <a href="https://www.w3.org/TR/css3-selectors/#selector-syntax">选择器</a>时，
        会创建一个“流片段”选择器。
        流片段选择器指定了
        流中哪些元素范围
        可以被相对选择器匹配。
        相对选择器可以匹配命名流中显示在所选区域（可完全或部分显示，见<a data-biblio-type=normative data-link-type=biblio href=#dom
            title=dom>[DOM]</a>）的元素范围。
    </p>

    <p>完全或部分处于流片段范围的元素都可能被相对选择器匹配。
        但样式声明只应用在显示于相应区域的元素片段上。</p>

    <p>只有有限的属性可以应用于 ::region 伪元素：</p>

    <p class=issue id=issue-9b00b7af><a class=self-link href=#issue-9b00b7af></a>
        这个列表要么应该包含所有具有功能性继承的属性，要么包含所有属性。
        为什么它只是所有属性的一个看似随意的子集，包括盒子属性？

    <ol>
        <li><a href="https://www.w3.org/TR/CSS2/fonts.html">字体属性</a></li>
        <li><a href="https://www.w3.org/TR/CSS2/colors.html">颜色属性</a></li>
        <li><a href="https://www.w3.org/TR/css3-color/#transparency">透明度属性</a></li>
        <li><a href="https://www.w3.org/TR/css3-background/#backgrounds">背景属性</a></li>
        <li><a class=property data-link-type=propdesc href="https://www.w3.org/TR/css3-text/#word-spacing"
                title=word-spacing>word-spacing</a></li>
        <li><a class=property data-link-type=propdesc href="https://www.w3.org/TR/css3-text/#letter-spacing"
                title=letter-spacing>letter-spacing</a></li>
        <li><a class=property data-link-type=propdesc href="https://www.w3.org/TR/css-text-decor-3/#text-decoration"
                title=text-decoration>text-decoration</a></li>
        <li><a class=property data-link-type=propdesc href="https://www.w3.org/TR/css3-text/#text-transform"
                title=text-transform>text-transform</a></li>
        <li><a class=property data-link-type=propdesc
                href="https://www.w3.org/TR/CSS21/visudet.html#propdef-line-height" title=line-height>line-height</a>
        </li>
        <li><a href="https://www.w3.org/TR/css3-text/#justification">对齐和分散属性</a></li>
        <li><a href="https://www.w3.org/TR/css3-background/#borders">边框属性</a></li>
        <li><a href="https://www.w3.org/TR/css3-background/#corners">圆角属性</a></li>
        <li><a href="https://www.w3.org/TR/css3-background/#border-images">边框图像属性</a></li>
        <li><a href="https://www.w3.org/TR/CSS2/box.html#margin-properties">外边距属性</a></li>
        <li><a href="https://www.w3.org/TR/CSS2/box.html#padding-properties">内边距属性</a></li>
        <li><a class=property data-link-type=propdesc href="https://www.w3.org/TR/css-text-decor-3/#text-shadow"
                title=text-shadow>text-shadow</a></li>
        <li><a class=property data-link-type=propdesc href="https://www.w3.org/TR/css3-background/#box-shadow"
                title=box-shadow>box-shadow</a></li>
        <li><a class=property data-link-type=propdesc href="https://www.w3.org/TR/css3-break/#box-decoration-break"
                title=box-decoration-break>box-decoration-break</a></li>
        <li><a class=property data-link-type=propdesc href="https://www.w3.org/TR/CSS21/visudet.html#propdef-width"
                title=width>width</a></li>
    </ol>

    <div class=example id=region-style-example><a class=self-link href=#region-style-example></a>
        <p>在以下示例中，<span>命名流</span> “article-flow” 流入 “region-1” 和 “region-2”。</p>
        <pre>&lt;style&gt;
  #div-1 {
    <strong>flow-into: article-flow;</strong>
  }

  #region-1, #region-2 {
    <strong>flow-from: article-flow;</strong>
  }

  /* 区域样式 */
  <strong>#region-1::region p </strong> {
    margin-right: 5em;
  }
&lt;/style&gt;

&lt;body&gt;
  &lt;div id="div-1"&gt;
      &lt;p id="p-1"&gt;...&lt;/p&gt;
      &lt;p id="p-2"&gt;...&lt;/p&gt;
  &lt;/div&gt;
  &lt;div id="region-1"&gt;&lt;/div&gt;
  &lt;div id="region-2"&gt;&lt;/div&gt;
&lt;/body&gt;
</pre>
        <div id=region_styling_illustration>
            <img alt="展示命名流内容如何填充区域以说明区域样式的示例。" id=region_styling_img_2
                src=https://www.w3.org/TR/css-scoping-1/images/region-styling-2.png>

            <p>
            <ul class=swatch-list>
                <li><span class=swatch style=background:#1C75BC> </span>div div-1</li>

                <li><span class=swatch style=background:crimson> </span>段落 p-1</li>

                <li><span class=swatch style=background:white> </span>段落 p-2</li>

                <li><span class=swatch style=background:#E6E7E8> </span>填充到 region-1 的流片段范围</li>

                <li><span class=swatch style=background:#BCBEC0> </span>填充到 region-2 的流片段范围</li>
            </ul>
        </div>

        <p>该区域样式应用于适配 <span class=css data-link-type=maybe title=region-1>region-1</span> 的流内容。
            相对选择器会匹配 <span class=css data-link-type=maybe title=p-1>p-1</span> 和 <span class=css data-link-type=maybe
                title=p-2>p-2</span>，
            因为这些段落
            流入 <span class=css data-link-type=maybe title=region-1>region-1</span>。
            只有 <span class=css data-link-type=maybe title=p-2>p-2</span> 流入 <span class=css data-link-type=maybe
                title=region-1>region-1</span> 的片段
            会被伪元素样式化。</p>
    </div>

    <p>::region 伪元素中的所有选择器
        都会贡献其<a href="https://www.w3.org/TR/css3-selectors/#specificity">特异性</a>。
        因此上述例子中 ::region 伪元素的特异性
        会把 id 选择器的特异性与类型选择器的特异性相加，
        得到特异性 101。</p>

    <p>匹配指定元素或元素片段（如上所述）的选择器，
        参与 <a href="https://www.w3.org/TR/2011/REC-CSS2-20110607/cascade.html#cascading-order">CSS 级联顺序</a>，
        见<a data-biblio-type=normative data-link-type=biblio href=#css21 title=css21>[CSS21]</a>。</p>

    <div>
        区域样式不适用于嵌套区域。例如，如果区域
        <span class=css data-link-type=maybe title=a>A</span> 从包含区域 <span class=css data-link-type=maybe
            title=b>B</span> 的流中接收内容，则流入 <span class=css data-link-type=maybe title=b>B</span> 的内容不会获得为区域 <span
            class=css data-link-type=maybe title=a>A</span> 指定的区域样式。
    </div>

    <p class=issue id=issue-5bff6297><a class=self-link href=#issue-5bff6297></a>
        我们需要某种方式来查询特定区域中片段的样式。
        <code>getComputedStyle()</code> 不够，
        因为一个元素可以存在于多个区域，每个片段可能有不同样式。

    <h2 class="no-ref no-num heading settled heading" id=conformance><span class=content>
            符合性</span><a class=self-link href=#conformance></a></h2>

    <h3 class="no-ref heading settled heading" id=conventions><span class=content>
            文档约定</span><a class=self-link href=#conventions></a></h3>

    <p>符合性要求采用描述性断言与 RFC 2119 术语结合表达。本规范中规范性部分出现的 "MUST"、“MUST NOT”、“REQUIRED”、“SHALL”、“SHALL NOT”、“SHOULD”、“SHOULD
        NOT”、“RECOMMENDED”、“MAY” 和 “OPTIONAL” 等关键词，按照 RFC 2119 的解释理解。
        但为便于阅读，本规范不会将这些词全部大写。

    <p>除明确标记为非规范性、示例和注释的部分外，本规范的所有内容均为规范性内容。<a data-biblio-type=normative data-link-type=biblio href=#rfc2119
            title=rfc2119>[RFC2119]</a></p>

    <p>本规范中的示例以“例如”开头，或通过 <code>class="example"</code> 与规范性文本区别显示，如下：

    <div class=example>
        <p>这是一个信息性示例。</p>
    </div>

    <p>信息性注释以“注意”开头，并通过 <code>class="note"</code> 与规范性文本区别显示，如下：

    <p class=note>注意，这是一条信息性注释。</p>

    <h3 class="no-ref heading settled heading" id=conformance-classes><span class=content>
            符合性类别</span><a class=self-link href=#conformance-classes></a></h3>

    <p>本规范的符合性
        定义了三类符合性对象：
    <dl>
        <dt>样式表
        <dd>一份 <a href="https://www.w3.org/TR/CSS21/conform.html#style-sheet">CSS
                样式表</a>。
        <dt>渲染器
        <dd>一个 <a href="https://www.w3.org/TR/CSS21/conform.html#user-agent">UA</a>
            解析样式表语义并渲染
            使用这些样式表的文档。
        <dt>创作工具
        <dd>一个 <a href="https://www.w3.org/TR/CSS21/conform.html#user-agent">UA</a>
            用于编写样式表。
    </dl>

    <p>如果样式表中使用了本模块定义的语法，其所有语句均应根据通用 CSS 语法与本模块定义的各特性语法被判定为有效，则该样式表符合本规范。

    <p>渲染器符合本规范指在按相关规范解析样式表的同时，能够正确解析并渲染本规范定义的所有特性。但因设备限制导致 UA 无法正确渲染文档，并不视为不符合规范。（例如，UA 并不要求在单色显示器上渲染颜色。）

    <p>创作工具符合本规范指其输出的样式表在语法上符合通用 CSS 语法和本模块中各特性语法，并满足本模块描述的样式表所有其他符合性要求。

    <h3 class="no-ref heading settled heading" id=partial><span class=content>
            部分实现</span><a class=self-link href=#partial></a></h3>

    <p>为便于作者利用向前兼容的解析规则赋予回退值，CSS 渲染器<strong>必须</strong>将不支持的 at 规则、属性、属性值、关键字及其它语法结构等视为无效并<a
            href="https://www.w3.org/TR/CSS21/conform.html#ignore">适当忽略</a>。尤其是，用户代理<strong>不得</strong>在单个多值属性声明中选择性忽略不支持的组件值而保留支持的值：若某一值无效（不支持的值必须如此），CSS
        要求整个声明被忽略。</p>

    <h3 class="no-ref heading settled heading" id=experimental><span class=content>
            实验性实现</span><a class=self-link href=#experimental></a></h3>

    <p>为避免与未来 CSS 特性冲突，CSS2.1 规范为 CSS 的专有与实验性扩展保留了<a
            href="https://www.w3.org/TR/CSS21/syndata.html#vendor-keywords">带前缀的语法</a>。

    <p>在规范进入 W3C 候选推荐阶段前，所有 CSS 特性的实现都视为实验性实现。CSS 工作组建议实现时采用厂商前缀语法，包括 W3C 工作草案中的特性。这样可避免与未来草案变更产生不兼容。
    </p>

    <h3 class="no-ref heading settled heading" id=testing><span class=content>
            非实验性实现</span><a class=self-link href=#testing></a></h3>

    <p>一旦规范进入候选推荐阶段，即可进行非实验性实现，且实现者应发布任何 CR 级别特性的无前缀实现，只要能证明其正确实现。

    <p>为确保 CSS 在各实现间的互操作性，CSS 工作组要求非实验性 CSS 渲染器在发布任何 CSS 特性的无前缀实现前，向 W3C 提交实现报告（如有必要，还应提交相应的测试用例）。提交给 W3C 的测试用例将由 CSS
        工作组审核和修正。

    <p>有关提交测试用例和实现报告的更多信息，请参见 CSS 工作组网站
        <a href="https://www.w3.org/Style/CSS/Test/">http://www.w3.org/Style/CSS/Test/</a>。
        如有疑问，请发送邮件至
        <a href=http://lists.w3.org/Archives/Public/public-css-testsuite>public-css-testsuite@w3.org</a>
        邮件列表。

    <h2 class="no-num no-ref heading settled heading" id=references><span class=content>
            参考文献</span><a class=self-link href=#references></a></h2>

    <h3 class="no-num no-ref heading settled heading" id=normative><span class=content>
            规范性引用</span><a class=self-link href=#normative></a></h3>
    <div data-fill-with=normative-references>
        <dl>
            <dt id=css21 title=CSS21><a class=self-link href=#css21></a>[CSS21]
            <dd>Bert Bos 等. <a href="https://www.w3.org/TR/2011/REC-CSS2-20110607">层叠样式表 2级 修订版1 (CSS 2.1) 规范</a>.
                2011年6月7日. W3C 推荐. URL: <a
                    href="https://www.w3.org/TR/2011/REC-CSS2-20110607">http://www.w3.org/TR/2011/REC-CSS2-20110607</a>
            <dt id=css3cascade title=CSS3CASCADE><a class=self-link href=#css3cascade></a>[CSS3CASCADE]
            <dd>Håkon Wium Lie; Elika J. Etemad; Tab Atkins Jr.. <a
                    href="https://www.w3.org/TR/2013/CR-css-cascade-3-20131003/">CSS 级联与继承 3级</a>. 2013年10月3日. W3C 候选推荐.
                (进行中). URL: <a
                    href="https://www.w3.org/TR/2013/CR-css-cascade-3-20131003/">http://www.w3.org/TR/2013/CR-css-cascade-3-20131003/</a>
            <dt id=dom title=DOM><a class=self-link href=#dom></a>[DOM]
            <dd>Anne van Kesteren; Aryeh Gregor; Ms2ger. <a href="https://dom.spec.whatwg.org/">DOM Living Standard</a>.
                WHATWG Living Standard. (进行中). URL: <a
                    href="https://dom.spec.whatwg.org/">http://dom.spec.whatwg.org/</a>
            <dt id=rfc2119 title=RFC2119><a class=self-link href=#rfc2119></a>[RFC2119]
            <dd>S. Bradner. <a href=http://www.ietf.org/rfc/rfc2119.txt>RFC 中用以指示需求级别的关键词</a>. URL: <a
                    href=http://www.ietf.org/rfc/rfc2119.txt>http://www.ietf.org/rfc/rfc2119.txt</a>
        </dl>
    </div>

    <h3 class="no-num no-ref heading settled heading" id=informative><span class=content>
            资料性引用</span><a class=self-link href=#informative></a></h3>
    <div data-fill-with=informative-references>
        <dl>
            <dt id=html title=HTML><a class=self-link href=#html></a>[HTML]
            <dd>Ian Hickson. <a href="https://www.whatwg.org/specs/web-apps/current-work/multipage/">HTML</a>. 现行标准. URL:
                <a
                    href="https://www.whatwg.org/specs/web-apps/current-work/multipage/">http://www.whatwg.org/specs/web-apps/current-work/multipage/</a>
            <dt id=selectors4 title=SELECTORS4><a class=self-link href=#selectors4></a>[SELECTORS4]
            <dd>Elika J. Etemad; Tab Atkins Jr.. <a href="https://www.w3.org/TR/2013/WD-selectors4-20130502/">选择器
                    4级</a>. 2013年5月2日. W3C 工作草案. (进行中). URL: <a
                    href="https://www.w3.org/TR/2013/WD-selectors4-20130502/">http://www.w3.org/TR/2013/WD-selectors4-20130502/</a>
        </dl>
    </div>

    <h2 class="no-num no-ref heading settled heading" id=index><span class=content>
            索引</span><a class=self-link href=#index></a></h2>
    <div data-fill-with=index>
        <ul class=indexlist>
            <li>active shadow tree, <a href=#active-shadow-tree title="section 3">3</a>
            <li>::content, <a href=#selectordef-content title="section 3.2.3">3.2.3</a>
            <li>/deep/, <a href=#selectordef-deep title="section 3.2.4">3.2.4</a>
            <li>distribution list, <a href=#distribution-list title="section 3">3</a>
            <li>fragment pseudo-element, <a href=#fragment-pseudo-element title="section 4">4</a>
            <li>:host(), <a href=#selectordef-host title="section 3.2.1">3.2.1</a>
            <li>:host, <a href=#selectordef-host0 title="section 3.2.1">3.2.1</a>
            <li>:host-context(), <a href=#selectordef-host-context title="section 3.2.1">3.2.1</a>
            <li>host element, <a href=#host-element0 title="section 3">3</a>
            <li>insertion point, <a href=#insertion-point title="section 3">3</a>
            <li>@scope, <a href=#at-ruledef-scope title="section 2.1.2">2.1.2</a>
            <li>::shadow, <a href=#selectordef-shadow title="section 3.2.2">3.2.2</a>
            <li>shadow host, <a href=#shadow-host title="section 3">3</a>
            <li>shadow root, <a href=#shadow-root title="section 3">3</a>
            <li>shadow tree, <a href=#shadow-tree title="section 3">3</a>
            <li>top-level element, <a href=#top-level-element title="section 3">3</a>
        </ul>
    </div>

    <h2 class="no-num no-ref heading settled heading" id=property-index><span class=content>
            属性索引</span><a class=self-link href=#property-index></a></h2>
    <div data-fill-with=property-index>
        <p>未定义属性。
    </div>


    <h2 class="no-num heading settled" id=issues-index><span class=content>问题索引</span><a class=self-link
            href=#issues-index></a></h2>
    <div style="counter-reset: issue">
        <div class=issue>
            该规则使作者很容易创建作用域样式表，
            这可能会影响作用域样式实现的优化策略。

            <a href=#issue-5f568f10> ↵ </a>
        </div>
        <div class=issue>
            如果多个<a class=css data-link-type=maybe href=#at-ruledef-scope title=@scope>@scope</a>规则应用于同一个元素，
            它们是否应该按优先级进行级联？

            <a href=#issue-5c7571b6> ↵ </a>
        </div>
        <div class=issue>
            该机制的定义方式与<a class=css data-link-type=maybe href=#selectordef-host-context
                title=:host-context()>:host-context()</a>类似，
            但匹配的是<a data-link-type=dfn href=http://dev.w3.org/csswg/selectors-4/#scoping-root
                title="scoping root">作用域根</a>的祖先。

            <p> 然而，对于作用域样式表，你可能希望能够对外部树使用复杂选择器进行匹配，
                而非仅仅是单一的复合选择器，
                所以我们或许需要采用一种不会在语法上反转树元素顺序的更通用机制。

            <p> 可能的设想：

            <pre>:scope-context(<a class="production css-code" data-link-type=type href="https://www.w3.org/TR/selectors4/#ltselector" title="<selector>">&lt;selector&gt;</a>) div {...}
scope(<a class="production css-code" data-link-type=type href="https://www.w3.org/TR/selectors4/#ltselector" title="<selector>">&lt;selector&gt;</a>) div {...}
\scope <a class="production css-code" data-link-type=type href="https://www.w3.org/TR/selectors4/#ltselector" title="<selector>">&lt;selector&gt;</a>\ div {...}
<a class="production css-code" data-link-type=type href="https://www.w3.org/TR/selectors4/#ltselector" title="<selector>">&lt;selector&gt;</a> \scope\ div {...}
</pre>
            <p> 该功能将取代<span class=css data-link-type=maybe title=@global>@global</span>，因为@global作为选择器并不理想。
            </p><a href=#issue-aecbd194> ↵ </a>
        </div>

        <div class=issue>
            本节仍在讨论中，
            欢迎就以下功能的直观语法提出建议和反馈。

            <a href=#issue-dea392ae> ↵ </a>
        </div>
        <div class=issue>
            <a class=css data-link-type=maybe href=#selectordef-content title=::content>::content</a> 作为名称过于宽泛，
            其实它只针对影子树的投影内容。

            <a href=#issue-1b6118ae> ↵ </a>
        </div>
        <div class=issue>
            这本质上是超级后代组合器。
            如果后代组合器有专门的符号，
            或许可以直接将其重复两次。
            或许我们可以给后代组合器一个别名 <span class=css data-link-type=maybe title=">>">&gt;&gt;</span>，
            因为它其实是超级子代组合器？
            那么 <a class=css data-link-type=maybe href=#selectordef-deep title=/deep>/deep/</a> 就可以写作
            <span class=css data-link-type=maybe title=">>>">&gt;&gt;&gt;</span>




            <a href=#issue-250ee37f> ↵ </a>
        </div>
        <div class=issue>
            扩展以指定：
            <ul>
                <li><span class=css data-link-type=maybe
                        title="<region-element-selector>::region">&lt;region-element-selector&gt;::region</span>
                <li><span class=css data-link-type=maybe
                        title="<paginated-element-selector>::page(<page-selector>)">&lt;paginated-element-selector&gt;::page(&lt;page-selector&gt;)</span>
                <li><span class=css data-link-type=maybe
                        title="<multicol-element>::column(<anb>)">&lt;multicol-element&gt;::column(&lt;AnB&gt;)</span>
                <li><span class=css data-link-type=maybe
                        title="<fragmented-element-selector>::nth-fragment(<anb>)">&lt;fragmented-element-selector&gt;::nth-fragment(&lt;AnB&gt;)</span>
                <li><span class=css data-link-type=maybe title=::first-line>::first-line</span>
            </ul>
            <a href=#issue-f778a2c0> ↵ </a>
        </div>

        <div class=issue>
            这个列表要么应该包含所有具有功能性继承的属性，要么包含所有属性。
            为什么它只是所有属性的一个看似随意的子集，包括盒子属性？

            <a href=#issue-9b00b7af> ↵ </a>
        </div>
        <div class=issue>
            我们需要某种方式来查询特定区域中片段的样式。
            <code>getComputedStyle()</code> 不够，
            因为一个元素可以存在于多个区域，每个片段可能有不同样式。

            <a href=#issue-5bff6297> ↵ </a>
        </div>
    </div>
    <script src="https://www.w3.org/scripts/TR/fixup.js"></script>
    <script src="/dropdown.js"></script>