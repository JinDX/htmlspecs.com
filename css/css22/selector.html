<!DOCTYPE html>
<html lang="zh-hans">

<head>
  <title>选择器</title>
  <link rel="stylesheet" href="https://www.w3.org/TR/CSS22/style/default.css" type="text/css">
  <link rel="stylesheet" href="https://www.w3.org/StyleSheets/TR/2016/W3C-WD.css" type="text/css">
  <link rel="prev" href="syndata.html">
  <link rel="next" href="cascade.html">
  <link rel="contents" href="index.html#minitoc">
  <link rel="CSS-properties" href="propidx.html" title="properties">
  <link rel="index" href="indexlist.html" title="index">
  <link rel="first" href="index.html">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

</head>

<body>
  <div class="navbar">
    <p><a href="syndata.html">上一页</a> &nbsp;
      <a href="cascade.html">下一页</a> &nbsp;
      <a href="index.html#minitoc">目录</a> &nbsp;
      <a href="propidx.html">属性</a> &nbsp;
      <a href="indexlist.html">索引</a> &nbsp;
  </div>
  <hr class="navbar">

  <h1><a id="q0">5 选择器</a></h1>
  <div id="toc" class="subtoc">
    <p><strong>目录</strong>
    <ul class="toc">
      <li><a href="selector.html#pattern-matching" class="tocxref">5.1 模式匹配</a></li>
      <li><a href="selector.html#selector-syntax" class="tocxref">5.2 选择器语法</a>
        <ul class="toc">
          <li><a href="selector.html#grouping" class="tocxref">5.2.1 分组</a></li>
        </ul>
      </li>
      <li><a href="selector.html#universal-selector" class="tocxref">5.3 通用选择器</a></li>
      <li><a href="selector.html#type-selectors" class="tocxref">5.4 类型选择器</a></li>
      <li><a href="selector.html#descendant-selectors" class="tocxref">5.5 后代选择器</a></li>
      <li><a href="selector.html#child-selectors" class="tocxref">5.6 子选择器</a></li>
      <li><a href="selector.html#adjacent-selectors" class="tocxref">5.7 相邻兄弟选择器</a></li>
      <li><a href="selector.html#attribute-selectors" class="tocxref">5.8 属性选择器</a>
        <ul class="toc">
          <li><a href="selector.html#matching-attrs" class="tocxref">5.8.1 匹配属性和属性值</a></li>
          <li><a href="selector.html#default-attrs" class="tocxref">5.8.2 DTD 中的默认属性值</a></li>
          <li><a href="selector.html#class-html" class="tocxref">5.8.3 类选择器</a></li>
        </ul>
      </li>
      <li><a href="selector.html#id-selectors" class="tocxref">5.9 ID 选择器</a></li>
      <li><a href="selector.html#pseudo-elements" class="tocxref">5.10 伪元素和伪类</a></li>
      <li><a href="selector.html#pseudo-class-selectors" class="tocxref">5.11 伪类</a>
        <ul class="toc">
          <li><a href="selector.html#first-child" class="tocxref">5.11.1 :first-child 伪类</a></li>
          <li><a href="selector.html#link-pseudo-classes" class="tocxref">5.11.2 链接伪类：<span class="index-def"
                title="pseudo-classes:::link|:link|link (pseudo-class)">:link</span> 和 <span class="index-def"
                title="pseudo-classes:::visited|:visited|visited (pseudo-class)">:visited</span></a></li>
          <li><a href="selector.html#dynamic-pseudo-classes" class="tocxref">5.11.3 动态伪类：<span class="index-def"
                title="pseudo-classes:::hover|:hover|hover (pseudo-class)">:hover</span>、<span class="index-def"
                title="pseudo-classes:::active|:active|active (pseudo-class)">:active</span> 和 <span class="index-def"
                title="pseudo-classes:::focus|:focus|focus (pseudo-class)">:focus</span></a></li>
          <li><a href="selector.html#lang" class="tocxref">5.11.4 语言伪类：<span class="index-def"
                title="pseudo-classes:::lang|:lang|lang (pseudo-class)">:lang</span></a></li>
        </ul>
      </li>
      <li><a href="selector.html#pseudo-element-selectors" class="tocxref">5.12 伪元素</a>
        <ul class="toc">
          <li><a href="selector.html#first-line-pseudo" class="tocxref">5.12.1 <span class="index-def"
                title="pseudo-elements:::first-line|:first-line|first-line">:first-line</span> 伪元素</a></li>
          <li><a href="selector.html#first-letter" class="tocxref">5.12.2 <span class="index-def"
                title="pseudo-elements:::first-letter|:first-letter|first-letter">:first-letter</span> 伪元素</a></li>
          <li><a href="selector.html#before-and-after" class="tocxref">5.12.3 <span class="index-def"
                title="pseudo-elements:::before|:before">:before</span> 和 <span class="index-def"
                title="pseudo-elements:::after|:after">:after</span> 伪元素</a></li>
        </ul>
      </li>
    </ul>
  </div>


  <h2>5.1 <a id="pattern-matching">模式匹配</a></h2>

  <p>在 CSS 中，模式匹配规则决定了哪些样式规则适用于<a href="conform.html#doctree">文档树</a>中的元素。这些模式，称为<a id="x0"><span class="index-inst"
        title="selector">选择器，</span></a>可以从简单的元素名称到丰富的上下文模式不等。如果某个元素符合模式中的所有条件，则选择器<a id="x1"><span class="index-def"
        title="match|selector::match"><dfn>匹配</dfn></span></a>该元素。
  </p>

  <p>选择器中文档语言元素名称的大小写敏感性取决于文档语言。例如，在 HTML 中，元素名称是不区分大小写的，但在 XML 中，它们是区分大小写的。
  </p>

  <p>下表总结了 CSS&nbsp;2.2 选择器语法：</p>

  <table class=data>
    <tr>
      <th>模式</th>
      <th>含义</th>
      <th>描述的章节</th>
    </tr>
    <tr>
      <td>*</td>
      <td>匹配任何元素。</td>
      <td><a href="#universal-selector">通用选择器</a></td>
    </tr>
    <tr>
      <td>E</td>
      <td>匹配任何 E 元素（即类型为 E 的元素）。</td>
      <td><a href="#type-selectors">类型选择器</a></td>
    </tr>
    <tr>
      <td>E F</td>
      <td>匹配任何 F 元素，该元素是 E 元素的后代。</td>
      <td><a href="#descendant-selectors">后代选择器</a></td>
    </tr>
    <tr>
      <td>E &gt; F</td>
      <td>匹配任何 F 元素，该元素是 E 元素的子元素。</td>
      <td><a href="#child-selectors">子选择器</a></td>
    </tr>
    <tr>
      <td>E:first-child</td>
      <td>当 E 是其父元素的第一个子元素时，匹配元素 E。</td>
      <td><a href="#first-child">:first-child 伪类</a></td>
    </tr>
    <tr>
      <td>E:link<br>E:visited</td>
      <td>如果 E 是超链接的源锚点，且目标尚未访问（:link）或已访问（:visited），则匹配元素 E。</td>
      <td><a href="#link-pseudo-classes">链接伪类</a></td>
    </tr>
    <tr>
      <td>E:active<br>E:hover<br>E:focus</td>
      <td>在某些用户操作期间匹配 E。</td>
      <td><a href="#dynamic-pseudo-classes">动态伪类</a></td>
    </tr>
    <tr>
      <td>E:lang(c)</td>
      <td>如果类型为 E 的元素使用（人类）语言 c，则匹配该元素（文档语言指定如何确定语言）。</td>
      <td><a href="#lang">:lang() 伪类</a></td>
    </tr>
    <tr>
      <td>E + F</td>
      <td>匹配任何紧接在兄弟元素 E 之后的 F 元素。</td>
      <td><a href="#adjacent-selectors">相邻选择器</a></td>
    </tr>
    <tr>
      <td>E[foo]</td>
      <td>匹配任何设置了 "foo" 属性的 E 元素（无论值是什么）。</td>
      <td><a href="#attribute-selectors">属性选择器</a></td>
    </tr>
    <tr>
      <td>E[foo="warning"]</td>
      <td>匹配 "foo" 属性值正好等于 "warning" 的任何 E 元素。</td>
      <td><a href="#attribute-selectors">属性选择器</a></td>
    </tr>
    <tr>
      <td>E[foo~="warning"]</td>
      <td>匹配 "foo" 属性值是以空格分隔的值列表之一，且其中之一正好等于 "warning" 的任何 E 元素。</td>
      <td><a href="#attribute-selectors">属性选择器</a></td>
    </tr>
    <tr>
      <td>E[lang|="en"]</td>
      <td>匹配 "lang" 属性具有以 "en" 开头的连字符分隔值列表的任何 E 元素。</td>
      <td><a href="#attribute-selectors">属性选择器</a></td>
    </tr>
    <tr>
      <td>DIV.warning</td>
      <td><em>语言特定。</em>（在 HTML 中，与 DIV[class~="warning"] 相同。）</td>
      <td><a href="#class-html">类选择器</a></td>
    </tr>
    <tr>
      <td>E#myid</td>
      <td>匹配 ID 等于 "myid" 的任何 E 元素。</td>
      <td><a href="#id-selectors">ID 选择器</a></td>
    </tr>
  </table>


  <h2>5.2 <a id="selector-syntax">选择器语法</a></h2>

  <p><span class="index-def" title="simple selector"><a id="simple-selector"><dfn>简单选择器</dfn></a></span>要么是<a
      href="#type-selectors">类型选择器</a>或<a href="#universal-selector">通用选择器</a>，紧随其后的是零个或多个<a
      href="#attribute-selectors">属性选择器</a>、<a href="#id-selectors">ID 选择器</a>或<a
      href="#pseudo-classes">伪类</a>，顺序不限。只要其所有组件匹配，简单选择器就匹配。

  <p class="note">注意：CSS&nbsp;2.2 中使用的术语与 CSS3 中的不同。例如，“简单选择器”在 CSS3 中指的是比 CSS&nbsp;2.2 中更小的选择器部分。参见 CSS3 选择器模块 <a
      href="refs.html#ref-CSS3SEL" rel="biblioentry" class="noxref"><span class="informref">[CSS3SEL]</span></a>。
  </p>

  <p><a id="x4"><span class="index-def" title="selector"><dfn>选择器</dfn></span></a>是一串由组合符分隔的一个或多个简单选择器。<span
      class="index-def" title="combinator"><a id="combinator"><dfn>组合符</dfn></a></span>包括：空白、“&gt;” 和
    “+”。组合符与其周围的简单选择器之间可以出现空白。

  <p>与选择器匹配的文档树元素称为选择器的<span class="index-def" title="subject (of selector)|selector::subject of"><a
     id="subject"><dfn>主体</dfn></a></span>。由单个简单选择器组成的选择器匹配任何满足其要求的元素。将一个简单选择器和组合符添加到链中会施加额外的匹配约束，因此选择器的主体始终是与最后一个简单选择器匹配的元素的子集。

  <p>可以将一个<a href="#pseudo-elements">伪元素</a>附加到链中的最后一个简单选择器后面，在这种情况下，样式信息适用于每个主体的一个子部分。</p>

  <h3>5.2.1 <a id="grouping">分组</a></h3>

  <p>当多个选择器共享相同的声明时，它们可以分组为一个用逗号分隔的列表。</p>

  <div class="example">
    <P style="display:none">示例:</P>
    <P>在此示例中，我们将三个具有相同声明的规则压缩为一个。因此，</p>

    <pre>
h1 { font-family: sans-serif }
h2 { font-family: sans-serif }
h3 { font-family: sans-serif }
</pre>

    <p>等同于：</p>

    <pre>
h1, h2, h3 { font-family: sans-serif }
</pre>
  </div>

  <p>CSS 还提供了其他“简写”机制，包括 <span class="index-def" title="multiple declarations"><a id="x8"
        href="syndata.html#declaration">多重声明</a></span> 和 <span class="index-inst" title="shorthand property"><a
     id="x9" href="about.html#shorthand">简写属性</a></span>。</p>

  <h2>5.3 <a id="universal-selector">通用选择器</a></h2>

  <p><a id="x10"><span class="index-def" title="universal selector">通用选择器</span></a>，写作 "*"，匹配任何元素类型的名称。它匹配<a
      href="conform.html#doctree">文档树</a>中的任何单个元素。</p>

  <p>如果通用选择器不是<a href="#simple-selector">简单选择器</a>的唯一组件，则 "*" 可以省略。例如：</p>

  <ul>
    <li><code>*[lang=fr] </code> 和 <code>[lang=fr]</code> 是等价的。</li>
    <li><code>*.warning</code> 和 <code>.warning</code> 是等价的。</li>
    <li><code>*#myid</code> 和 <code>#myid</code> 是等价的。</li>
  </ul>

  <h2>5.4 <a id="type-selectors">类型选择器</a></h2>

  <p><a id="x11"><span class="index-def"
        title="type selector"><em>类型选择器</em></span></a>匹配文档语言元素类型的名称。类型选择器匹配文档树中该元素类型的每个实例。</p>

  <div class="example">
    <P style="display:none">示例:</P>
    <P>以下规则匹配文档树中的所有 H1 元素：</p>

    <pre>
h1 { font-family: sans-serif }
</pre>
  </div>

  <h2>5.5 <a id="descendant-selectors">后代选择器</a></h2>

  <p>有时，作者可能希望选择器匹配文档树中作为另一个元素的后代的元素（例如，“匹配包含在 H1 元素中的 EM 元素”）。<a id="x12"><span class="index-def"
        title="descendant-selectors">后代选择器</span></a>在模式中表达了这种关系。后代选择器由两个或多个用<a
      href="syndata.html#whitespace">空白</a>分隔的选择器组成。形式为 "<code>A B</code>" 的后代选择器在元素 <code>B</code> 是某个<a
      href="conform.html#doctree">祖先</a>元素 <code>A</code> 的任意后代时匹配。</p>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>例如，考虑以下规则：</p>

    <pre>
h1 { color: red }
em { color: red }
</pre>

    <p>虽然这些规则的目的是通过更改颜色来强调文本，但在以下情况下效果会丧失：</p>

    <pre>
&lt;H1&gt;This headline is &lt;EM&gt;very&lt;/EM&gt; important&lt;/H1&gt;
</pre>

    <p>我们通过补充一条规则来解决这种情况，该规则规定只要 EM 出现在 H1 中，文本颜色就会变为蓝色：</p>

    <pre>
h1 { color: red }
em { color: red }
h1 em { color: blue }
</pre>

    <p>第三条规则将匹配以下片段中的 EM：</p>

    <pre>
&lt;H1&gt;This &lt;SPAN class="myclass"&gt;headline 
is &lt;EM&gt;very&lt;/EM&gt; important&lt;/SPAN&gt;&lt;/H1&gt;
</pre>
  </div>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>以下选择器：</p>

    <pre>
div * p 
</pre>

    <p>匹配作为 DIV 元素的孙辈或更后代的 P 元素。请注意，"*" 两侧的空白不是通用选择器的一部分；空白是一个组合符，表示 DIV 必须是某个元素的祖先，并且该元素必须是 P 的祖先。</p>
  </div>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>以下规则中的选择器结合了后代选择器和<a href="#attribute-selectors">属性选择器</a>，匹配以下元素：（1）设置了 "href" 属性且（2）位于 P 内，而 P 本身位于 DIV 内：</p>

    <pre>
div p *[href]
</pre>
  </div>

  <h2>5.6 <a id="child-selectors">子选择器</a></h2>

  <p><a id="x13"><span class="index-def" title="child selector"><em>子选择器</em></span></a>用于匹配某个元素的<a
      href="conform.html#doctree">子元素</a>。子选择器由两个或多个选择器组成，并用 "&gt;" 分隔。</p>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>以下规则设置了所有作为 BODY 子元素的 P 元素的样式：</p>

    <pre>
body &gt; P { line-height: 1.3 }
</pre>
  </div>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>以下示例结合了后代选择器和子选择器：</p>
    <pre>
div ol&gt;li p
</pre>

    <P>它匹配作为 LI 后代的 P 元素；LI 元素必须是 OL 元素的子元素；OL 元素必须是 DIV 的后代。注意 "&gt;" 组合符周围的可选空白已被省略。
  </div>

  <p>有关选择元素第一个子元素的信息，请参见下文的<a href="#first-child">:first-child</a>伪类部分。

  <h2>5.7 <a id="adjacent-selectors">相邻兄弟选择器</a></h2>

  <p>相邻兄弟选择器的语法如下：E1 + E2，其中 E2 是选择器的主体。如果 E1 和 E2 在文档树中共享相同的父元素，并且 E1 紧接在 E2 之前（忽略非元素节点，如文本节点和注释），则选择器匹配。</p>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>因此，以下规则规定，当 P 元素紧跟在 MATH 元素之后时，不应缩进：</p>

    <pre>
math + p { text-indent: 0 } 
</pre>

    <p>下一个示例减少了紧跟在 H1 之后的 H2 之间的垂直空间：</p>

    <pre>
h1 + h2 { margin-top: -5mm }   
</pre>
  </div>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>以下规则与前一个示例中的规则类似，但添加了一个类选择器。因此，只有当 H1 具有 <samp>class="opener"</samp> 时，才会进行特殊格式化：</p>

    <pre>
h1.opener + h2 { margin-top: -5mm }   
</pre>
  </div>

  <h2>5.8 <a id="attribute-selectors">属性选择器</a></h2>

  <p>CSS&nbsp;2.2 允许作者指定规则，以匹配在源文档中定义了某些属性的元素。</p>

  <h3>5.8.1 <a id="matching-attrs">匹配属性和属性值</a></h3>

  <p>属性选择器可以通过以下四种方式匹配：</p>

  <dl>
    <dt><code>[att]</code>
    <dd>当元素设置了 "att" 属性时匹配，无论属性的值是什么。</dd>

    <dt><a id="x14"><span class="index-def" title="exact matching|="><code>[att=val]</code></span></a>
    <dd>当元素的 "att" 属性值正好是 "val" 时匹配。</dd>

    <dt><a id="x16"><span class="index-def" title="space-separated matching|~="><code>[att~=val]</code></span></a>
    <dd>表示具有 <code>att</code> 属性的元素，其值是由空格分隔的单词列表，其中之一正好是 "val"。如果 "val" 包含空格，它将永远不会表示任何内容（因为单词是用空格<em>分隔</em>的）。如果
      "val" 是空字符串，它也不会表示任何内容。</dd>

    <dt><a id="x18"><span class="index-def"
          title="hyphen-separated matching|&#124;="><code>[att|=val]</code></span></a>
    <dd>表示具有 <code>att</code> 属性的元素，其值要么正好是 "val"，要么以 "val" 开头，紧跟 "-" (U+002D)。这主要是为了允许<a id="x20"><span
          class="index-inst" title="language code">语言子代码</span></a>匹配（例如，HTML 中 <code>a</code> 元素上的
      <code>hreflang</code> 属性），如 BCP&nbsp;47（<a href="refs.html#ref-BCP47" rel="biblioentry" class="noxref"><span
          class="informref">[BCP47]</span></a>）或其后继者中所述。对于 <code>lang</code>（或<code>xml:lang</code>）语言子代码匹配，请参见<a
        href="#lang">:lang 伪类</a>。
    </dd>
  </dl>

  <p>属性值必须是标识符或字符串。选择器中属性名称和值的大小写敏感性取决于文档语言。</p>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>例如，以下属性选择器匹配所有指定了 "title" 属性的 H1 元素，无论其值是什么：</p>

    <pre>
h1[title] { color: blue; }
</pre>
  </div>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>在以下示例中，选择器匹配所有 "class" 属性值正好为 "example" 的 SPAN 元素：</p>

    <pre>
span[class=example] { color: blue; }
</pre>
  </div>

  <p>可以使用多个属性选择器来引用一个元素的多个属性，甚至多次引用相同的属性。</p>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>此处，选择器匹配所有 "hello" 属性值正好为 "Cleveland" 且 "goodbye" 属性值正好为 "Columbus" 的 SPAN 元素：</p>

    <pre>
span[hello="Cleveland"][goodbye="Columbus"] { color: blue; }
</pre>
  </div>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>以下选择器说明了 "=" 和 "~=" 之间的区别。第一个选择器将匹配 "rel" 属性值为 "copyright copyleft copyeditor" 的元素。第二个选择器仅在 "href" 属性的值为
      "http://www.w3.org/" 时匹配。</p>

    <pre>
a[rel~="copyright"]
a[href="http://www.w3.org/"]
</pre>
  </div>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>以下规则隐藏所有 "lang" 属性值为 "fr" 的元素（即语言为法语）。</p>

    <pre>
*[lang=fr] { display : none }
</pre>
  </div>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>以下规则将匹配 "lang" 属性值以 "en" 开头的元素，包括 "en"、"en-US" 和 "en-cockney"：</p>

    <pre>
*[lang|="en"] { color : red }
</pre>
  </div>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>类似地，以下听觉样式表规则允许剧本中的每个角色用不同的声音朗读：</p>

    <pre>
DIALOGUE[character=romeo] 
     { voice-family: "Laurence Olivier", charles, male }
      
DIALOGUE[character=juliet]  
     { voice-family: "Vivien Leigh", victoria, female }
</pre>
  </div>

  <H3>5.8.2 <a id="default-attrs">DTD 中的默认属性值</a></H3>

  <p>匹配发生在文档树中的属性值上。默认属性值可能在<a id="x21"><span class="index-inst"
        title="DTD">DTD</span></a>或其他地方定义，但并非总能通过属性选择器选择。样式表的设计应确保即使默认值未包含在文档树中，它们也能正常工作。</p>

  <p>更准确地说，UA 可能会，但<em>不</em>要求读取 DTD 的“外部子集”，但<em>要求</em>查找文档“内部子集”中的默认属性值。（有关这些子集的定义，请参阅 <a href="refs.html#ref-XML11"
      rel="biblioentry" class="noxref"><span class="normref">[XML11]</span></a>。）根据 UA 的不同，在 DTD
    的外部子集中定义的默认属性值可能会，也可能不会出现在文档树中。</p>

  <p>一个识别 XML 命名空间的 UA（参见 <a href="refs.html#ref-XMLNAMESPACES" rel="biblioentry" class="noxref"><span
        class="informref">[XMLNAMESPACES]</span></a>）可以，但不要求使用其对该命名空间的了解，将默认属性值视为它们存在于文档中。（例如，XHTML UA 并不要求使用其对 XHTML
    DTD 的内置知识。）</p>

  <p class="note">注意，通常实现会选择忽略外部子集。</p>

  <div class="example">
    <P style="display:none">示例:</P>
    <P>例如，考虑一个元素 EXAMPLE，其属性“notation”的默认值为“decimal”。DTD 片段可能是：</p>

    <pre>
&lt;!ATTLIST EXAMPLE notation (decimal,octal) "decimal">
</pre>

    <p>如果样式表包含以下规则：</p>

    <pre>
EXAMPLE[notation=decimal] { /*... 默认属性设置 ...*/ }
EXAMPLE[notation=octal]   { /*... 其他设置...*/ }
</pre>

    <p>第一个规则可能不会匹配其“notation”属性由默认值设置的元素，即未显式设置的元素。为了捕捉所有情况，必须删除默认值的属性选择器：</p>

    <pre>
EXAMPLE                   { /*... 默认属性设置 ...*/ }
EXAMPLE[notation=octal]   { /*... 其他设置...*/ }
</pre>

    <p>在这里，由于选择器 <code>EXAMPLE[notation=octal]</code> 比单独的类型选择器更<a
        href="cascade.html#specificity">具体</a>，因此对于“notation”属性值为“octal”的元素，第二条规则中的样式声明将覆盖第一条规则中的声明。需要注意的是，所有仅适用于默认情况的属性声明在非默认情况下的样式规则中都应被覆盖。
    </p>
  </div>


  <h3>5.8.3 <a id="class-html">类选择器</a></h3>

  <p>在使用 HTML 时，作者可以使用句点（<code>.</code>）表示法作为表示<code>class</code>属性的<code>~=</code>表示法的替代方法。因此，对于
    HTML，<code>div.value</code> 和 <code>div[class~=value]</code> 具有相同的含义。属性值必须紧跟在“句点”（<code>.</code>）之后。如果 UA
    具有特定命名空间的知识，使其能够确定哪个属性是相应命名空间的“class”属性，那么 UA 可以在 XML
    文档中使用句点（<code>.</code>）表示法应用选择器。例如，特定命名空间的知识的一个示例是特定命名空间规范中的描述（例如，SVG 1.1 规范中描述了<a href="refs.html#ref-SVG11"
      rel="biblioentry" class="noxref"><span class="informref">[SVG11]</span></a>中的<a
      href="https://www.w3.org/TR/2003/REC-SVG11-20030114/styling.html#ClassAttribute">SVG “class” 属性</a>及 UA
    应如何解释它，类似地，MathML 3.0 中也描述了<a href="refs.html#ref-MATH30" rel="biblioentry" class="noxref"><span
        class="informref">[MATH30]</span></a>中的<a href="https://www.w3.org/TR/MathML2/chapter2.html#fund.globatt">MathML
      “class” 属性</a>）。</p>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>例如，我们可以将样式信息分配给所有<code>class~="pastoral"</code>的元素，如下所示：</p>

    <pre>
*.pastoral { color: green }  /* 所有 class~=pastoral 的元素 */
</pre>

    或者简写为：

    <pre>
.pastoral { color: green }  /* 所有 class~=pastoral 的元素 */
</pre>

    <p>以下规则只将样式分配给<code>class~="pastoral"</code>的 H1 元素：</p>

    <pre>
H1.pastoral { color: green }  /* class~=pastoral 的 H1 元素 */
</pre>

    <p>根据这些规则，下面的第一个 H1 实例不会是绿色文本，而第二个会是绿色文本：</p>

    <pre>
&lt;H1&gt;Not green&lt;/H1&gt;
&lt;H1 class="pastoral"&gt;Very green&lt;/H1&gt;
</pre>
  </div>

  <p>要匹配 "class" 值的子集，每个值必须以“.”为前缀。</p>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>例如，以下规则匹配任何 "class" 属性被分配了一系列空格分隔值且包含“pastoral”和“marine”的 P 元素：</p>

    <pre>
p.marine.pastoral { color: green }
</pre>

    <p>此规则在<code>class="pastoral blue aqua marine"</code>时匹配，但在<code>class="pastoral blue"</code>时不匹配。</p>
  </div>

  <div class="note">
    <p><em><strong>注意。</strong> CSS 赋予“class”属性如此大的权力，以至于作者可以设计基于几乎没有关联表示的元素（例如 HTML 中的 DIV 和
        SPAN）的“文档语言”，并通过“class”属性分配样式信息。作者应避免这种做法，因为文档语言的结构元素通常具有公认和接受的含义，而作者定义的类可能没有。</em></p>
  </div>

  <div class="note">
    <p><em><strong>注意：</strong> 如果一个元素有多个 class 属性，则在搜索 class
        之前，其值必须在值之间用空格连接。工作组目前尚未意识到可以达到这种情况的任何方式，因此此行为在本规范中明确为非规范性内容。</em></p>
  </div>

  <h2>5.9 <a id="id-selectors">ID 选择器</a></h2>

  <p>文档语言可能包含声明为 ID 类型的属性。ID 类型的属性之所以特殊，是因为不能有两个这样的属性具有相同的值；无论文档语言如何，ID 属性都可以用于唯一标识其元素。在 HTML 中，所有 ID 属性都命名为 "id"；XML
    应用程序可能会为 ID 属性指定不同的名称，但相同的限制适用。</p>

  <p>文档语言的 ID 属性允许作者为文档树中的一个元素实例分配一个标识符。CSS ID 选择器根据标识符匹配元素实例。CSS ID 选择器包含一个 "#"，后面紧跟 ID 值，该值必须是一个标识符。</p>

  <p class="note">注意，CSS 并未规定 UA 如何知道元素的 ID 属性。UA 可能会，例如，读取文档的 DTD，硬编码该信息或询问用户。</p>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>以下 ID 选择器匹配 ID 属性值为 "chapter1" 的 H1 元素：</p>

    <pre>
h1#chapter1 { text-align: center }
</pre>
  </div>

  <div class="html example">
    <p>在以下示例中，样式规则匹配 ID 值为 "z98y" 的元素。因此，该规则将匹配 P 元素：</p>

    <pre>
&lt;HEAD&gt;
  &lt;TITLE&gt;Match P&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
    *#z98y { letter-spacing: 0.3em }
  &lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
   &lt;P id=z98y&gt;Wide text&lt;/P&gt;
&lt;/BODY&gt;
</pre>

    <p>然而，在下一个示例中，样式规则将仅匹配 ID 值为 "z98y" 的 H1 元素。该规则将不匹配此示例中的 P 元素：</p>

    <pre>
&lt;HEAD&gt;
  &lt;TITLE&gt;Match H1 only&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
    H1#z98y { letter-spacing: 0.5em }
  &lt;/STYLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
   &lt;P id=z98y&gt;Wide text&lt;/P&gt;
&lt;/BODY&gt;
</pre>
  </div>

  <p>ID 选择器的优先级比属性选择器高。例如，在 HTML 中，选择器 <samp>#p123</samp> 在层叠顺序中比 <samp>[id=p123]</samp> 更具体。</p>

  <div class="note">
    <p><em><strong>注意。</strong> 在 XML 1.1 中<a href="refs.html#ref-XML11" rel="biblioentry" class="noxref"><span
            class="informref">[XML11]</span></a>，关于哪个属性包含元素的 ID 的信息包含在 DTD 中。当解析 XML 时，UA 并不总是读取 DTD，因此可能不知道元素的 ID
        是什么。如果样式表设计者知道或怀疑会出现这种情况，他应该改用普通的属性选择器：<code>[name=p371]</code> 而不是 <code>#p371</code>。然而，普通属性选择器的层叠顺序与 ID
        选择器不同。可能需要在声明中添加 "!important" 优先级：<code>[name=p371] {color: red !important}</code>。</em></p>
  </div>

  <p>如果一个元素有多个 ID 属性，为 ID 选择器的目的，这些属性都必须被视为该元素的 ID。这种情况可能会通过混合使用 xml:id <a href="refs.html#ref-XMLID" rel="biblioentry"
      class="noxref"><span class="informref">[XMLID]</span></a>、DOM3 Core <a href="refs.html#ref-DOM-LEVEL-3-CORE"
      rel="biblioentry" class="noxref"><span class="informref">[DOM-LEVEL-3-CORE]</span></a>、XML DTDs <a
      href="refs.html#ref-XML11" rel="biblioentry" class="noxref"><span class="informref">[XML11]</span></a>
    以及特定命名空间的知识来实现。</p>

  <h2>5.10 <a id="pseudo-elements">伪元素</a> 和 <a id="pseudo-classes">伪类</a></h2>

  <p>在 CSS&nbsp;2.2 中，样式通常基于元素在<a href="conform.html#doctree">文档树</a>中的位置进行附加。这种简单的模型在许多情况下是足够的，但由于<a
      href="conform.html#doctree">文档树</a>的结构，一些常见的出版场景可能无法实现。例如，在 HTML 4（参见 <a href="refs.html#ref-HTML4"
      rel="biblioentry" class="noxref"><span class="normref">[HTML4]</span></a>）中，没有元素引用段落的第一行，因此没有简单的 CSS 选择器可以引用它。</p>

  <p>CSS 引入了<a id="x22"><span class="index-def" title="pseudo-elements"><dfn>伪元素</dfn></span></a>和<a id="x23"><span
        class="index-def" title="pseudo-classes"><dfn>伪类</dfn></span></a>的概念，以允许基于文档树之外的信息进行格式化。</p>

  <ul>
    <li>伪元素创建了关于文档树的抽象，超出了文档语言指定的内容。例如，文档语言不提供访问元素内容的第一个字母或第一行的机制。CSS
      伪元素允许样式表设计师引用这些原本无法访问的信息。伪元素还可以为样式表设计师提供一种方法，将样式分配给源文档中不存在的内容（例如，<a
        href="generate.html#before-after-content">:before 和 :after</a>伪元素允许访问生成的内容）。</li>

    <li>伪类根据元素的名称、属性或内容以外的特征对元素进行分类；原则上，这些特征无法从文档树中推导出来。伪类可能是动态的，因为在用户与文档交互时，元素可能会获得或失去伪类。例外的是<a
        href="#first-child">':first-child'</a>，它<em>可以</em>从文档树中推导出来，而<a href="#lang">':lang()'</a>在某些情况下也可以从文档树中推导出来。
    </li>
  </ul>

  <p>伪元素和伪类都不会出现在文档源代码或文档树中。</p>

  <p>伪类可以出现在选择器中的任何位置，而伪元素只能附加在选择器的最后一个简单选择器之后。</p>

  <p>伪元素和伪类的名称不区分大小写。</p>

  <p>某些伪类是互斥的，而其他伪类可以同时应用于同一元素。在规则冲突的情况下，通常的<a href="cascade.html#cascading-order">层叠顺序</a>将决定结果。</p>

  <h2>5.11 <a id="pseudo-class-selectors">伪类</a></h2>

  <h3>5.11.1 <a id="first-child">:first-child</a> 伪类</h3>

  <p><a id="x24"><span class="index-def" title="first-child|:first-child">:first-child</span></a> 伪类匹配某个元素的第一个子元素。</p>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>在以下示例中，选择器匹配作为 DIV 元素的第一个子元素的任何 P 元素。该规则抑制了 DIV 的第一个段落的缩进：</p>

    <pre>
div &gt; p:first-child { text-indent: 0 }
</pre>

    该选择器将匹配以下片段中 DIV 内的 P 元素：

    <pre>
&lt;P&gt; The last P before the note.
&lt;DIV class="note"&gt;
   &lt;P&gt; The first P inside the note.
&lt;/DIV&gt;
</pre>

    但不会匹配以下片段中的第二个 P 元素：

    <pre>
&lt;P&gt; The last P before the note.
&lt;DIV class="note"&gt;
   &lt;H2&gt;Note&lt;/H2&gt;
   &lt;P&gt; The first P inside the note.
&lt;/DIV&gt;
</pre>
  </div>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>以下规则将字体粗细设置为 'bold'，适用于作为 P 元素的某个后代且 P 元素是第一个子元素的任何 EM 元素：</p>

    <pre>
p:first-child em { font-weight : bold }
</pre>
  </div>

  <p>请注意，由于<a href="visuren.html#anonymous">匿名</a>框不是文档树的一部分，因此在计算第一个子元素时不计入它们。</p>

  <div class="html example">
    <P>例如，以下示例中的 EM：</p>

    <pre>
&lt;P&gt;abc &lt;EM&gt;default&lt;/EM&gt;
</pre>

    是 P 元素的第一个子元素。
  </div>

  <p>以下两个选择器是等效的：</p>

  <pre>
* &gt; a:first-child   /* A 是任何元素的第一个子元素 */
a:first-child       /* 同上 */
</pre>


  <h3>5.11.2 <a id="link-pseudo-classes">链接伪类</a>：<a id="x26"><span class="index-def"
        title="pseudo-classes:::link|:link|link (pseudo-class)">:link</span></a> 和 <a id="x29"><span class="index-def"
        title="pseudo-classes:::visited|:visited|visited (pseudo-class)">:visited</span></a></h3>

  <p>用户代理通常以不同的方式显示未访问过的链接和之前访问过的链接。CSS 提供了伪类 ':link' 和 ':visited' 来区分它们：</p>

  <ul>
    <li>:link 伪类适用于尚未访问过的链接。</li>
    <li>:visited 伪类适用于用户已访问过的链接。</li>
  </ul>

  <p>UA 可能会在某个时刻将已访问的链接恢复到（未访问的）':link' 状态。</p>

  <p>这两种状态是互斥的。</p>

  <p>文档语言决定了哪些元素是超链接源锚点。例如，在 HTML4 中，链接伪类适用于具有 "href" 属性的 A 元素。因此，以下两个 CSS&nbsp;2.2 声明具有类似的效果：</p>

  <pre>
a:link { color: red }
:link  { color: red }
</pre>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>如果以下链接：</p>

    <pre>
&lt;A class="external" href="http://out.side/"&gt;external link&lt;/A&gt;
</pre>

    已被访问，则以下规则：

    <pre>
a.external:visited { color: blue }
</pre>

    将使其显示为蓝色。
  </div>

  <p class=note>注意。样式表作者可能会滥用 :link 和 :visited 伪类，在未经用户同意的情况下确定用户访问过哪些站点。</p>

  <p>因此，UA 可以将所有链接视为未访问的链接，或实施其他措施以在呈现已访问和未访问链接时保护用户隐私。有关处理隐私的更多信息，请参阅 <a href="refs.html#ref-P3P" rel="biblioentry"
      class="noxref"><span class="informref">[P3P]</span></a>。</p>

  <h3>5.11.3 <a id="dynamic-pseudo-classes">动态伪类：</a>
    <a id="x32"><span class="index-def" title="pseudo-classes:::hover|:hover|hover (pseudo-class)">:hover</span></a>,
    <a id="x35"><span class="index-def"
        title="pseudo-classes:::active|:active|active (pseudo-class)">:active</span></a>, 和 <a id="x38"><span
        class="index-def" title="pseudo-classes:::focus|:focus|focus (pseudo-class)">:focus</span></a>
  </h3>

  <p>交互式用户代理有时会根据用户操作更改渲染。CSS 提供了三个常见情况的伪类：</p>

  <ul>
    <li>:hover 伪类适用于用户指定一个元素时（使用某些指针设备），但不激活它。例如，当光标（鼠标指针）悬停在由元素生成的框上时，视觉用户代理可以应用此伪类。不支持<a
        href="media.html#interactive-media-group">交互媒体</a>的用户代理不必支持此伪类。某些支持<a
        href="media.html#interactive-media-group">交互媒体</a>的符合标准的用户代理可能无法支持此伪类（例如，笔设备）。</li>
    <li>:active 伪类适用于用户激活元素时。例如，在用户按下鼠标按钮和释放按钮之间的时间内。</li>
    <li>:focus 伪类适用于元素具有焦点时（接受键盘事件或其他形式的文本输入）。</li>
  </ul>

  <p>一个元素可以同时匹配多个伪类。</p>

  <p>CSS 不定义哪些元素可以处于上述状态，或如何进入和离开这些状态。脚本可能会更改元素是否对用户事件做出反应，不同的设备和用户代理可能会有不同的方式来指向或激活元素。</p>

  <p>CSS&nbsp;2.2 不定义 ':active' 或 ':hover' 元素的父元素是否也处于该状态。</p>

  <p>用户代理不要求因伪类转换而重新排版当前显示的文档。例如，样式表可能指定 :active 链接的<a href="fonts.html#propdef-font-size" class="noxref"><span
        class="propinst-font-size">字体大小</span></a>应大于非活动链接的字体大小，但由于这可能导致读者选择链接时字母的位置发生变化，因此用户代理可能会忽略相应的样式规则。</p>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>例如：</p>

    <pre>
a:link    { color: red }    /* 未访问的链接 */
a:visited { color: blue }   /* 已访问的链接 */
a:hover   { color: yellow } /* 悬停的链接 */
a:active  { color: lime }   /* 活动链接 */
</pre>

    <p>注意，A:hover 必须放在 A:link 和 A:visited 规则之后，否则层叠规则将隐藏 A:hover 规则的<a href="colors.html#propdef-color"
        class="noxref"><span class="propinst-color">颜色</span></a>属性。类似地，由于 A:active 放在 A:hover 之后，当用户同时激活和悬停在 A
      元素上时，将应用活动颜色（青柠色）。</p>
  </div>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>一个结合动态伪类的示例：</p>

    <pre>
a:focus { background: yellow }
a:focus:hover { background: white }
</pre>

    <p>最后一个选择器匹配同时处于 :focus 伪类和 :hover 伪类中的 A 元素。</p>
  </div>

  <p>有关焦点轮廓的展示信息，请查阅<a href="ui.html#dynamic-outlines">动态焦点轮廓</a>部分。</p>

  <div class="note">
    <P><em><strong>注意。</strong> 在 CSS1 中，':active' 伪类与 ':link' 和 ':visited' 互斥。这不再是情况。一个元素可以同时是 ':visited' 和 ':active'（或
        ':link' 和 ':active'），正常的层叠规则决定应用哪些样式声明。</em></p>
  </div>

  <div class="note">
    <P><em><strong>注意。</strong> 还请注意，在 CSS1 中，':active' 伪类仅适用于链接。</em></p>
  </div>

  <h3>5.11.4 <a id="lang">语言伪类：</a> <a id="x41"><span class="index-def"
        title="pseudo-classes:::lang|:lang|lang (pseudo-class)">:lang</span></a></h3>

  <p>如果文档语言指定了如何确定元素的<a id="x44"><span class="index-inst" title="language (human)">人类语言</span></a>，则可以在 CSS
    中编写基于元素语言匹配的选择器。例如，在 HTML 中<a href="refs.html#ref-HTML4" rel="biblioentry" class="noxref"><span
        class="normref">[HTML4]</span></a>，语言由 "lang" 属性、META 元素以及可能的协议信息（如 HTTP 头）组合确定。XML 使用一个名为 xml:lang
    的属性，可能还有其他特定文档语言的方法来确定语言。</p>

  <p>伪类 ':lang(C)' 在元素的语言为 C 时匹配。是否匹配仅基于标识符 C 是否等于或是元素语言值的连字符分隔子字符串，与 <a href="#attribute-selectors">'|='</a>
    操作符的工作方式相同。C 与元素语言值的匹配对于 ASCII 范围内的字符是大小写不敏感的。C 标识符不必是有效的语言名称。</p>

  <p>C 不得为空。</p>

  <p class=note>注意：建议文档和协议使用 BCP&nbsp;47 中的代码 <a href="refs.html#ref-BCP47" rel="biblioentry" class="noxref"><span
        class="informref">[BCP47]</span></a> 或其后续版本指示语言，对于基于 XML 的文档，通过 "xml:lang" 属性来指示语言 <a href="refs.html#ref-XML11"
      rel="biblioentry" class="noxref"><span class="normref">[XML11]</span></a>。参见<a
      href="https://www.w3.org/International/questions/qa-lang-2or3">“FAQ: 两字母还是三字母语言代码”</a>。</p>

  <div class="example">
    <P style="display:none">示例:</P>
    <p>以下规则为使用加拿大法语或德语的 HTML 文档设置引号：</p>

    <pre>
html:lang(fr-ca) { quotes: '« ' ' »' }
html:lang(de) { quotes: '»' '«' '\2039' '\203A' }
:lang(fr) &gt; Q { quotes: '« ' ' »' }
:lang(de) &gt; Q { quotes: '»' '«' '\2039' '\203A' }
</pre>

    <p>第二对规则实际上根据其父元素的语言在 Q 元素上设置 <a href="generate.html#propdef-quotes" class="noxref"><span
          class="propinst-quotes">"quotes"</span></a> 属性。这样做是因为引号的选择通常基于引用周围元素的语言，而不是引用本身：就像这段法语 “à l'improviste”
      在英语文本中间使用了英语引号一样。</p>
  </div>

  <div class=note>
    <p><strong>注意</strong> [lang|=xx] 和 :lang(xx) 之间的区别。在这个 HTML 示例中，只有 BODY 匹配 [lang|=fr]（因为它有一个 LANG 属性），但 BODY 和 P
      都匹配 :lang(fr)（因为它们都使用法语）。</p>

    <pre>&lt;body lang=fr>
  &lt;p>Je suis Français.&lt;/p>
&lt;/body></pre>
  </div>

  <h2>5.12 <a id="pseudo-element-selectors">伪元素</a></h2>

  <p>伪元素在 CSS 中的行为与真实元素类似，除了下面和<a href="generate.html#before-after-content">其他地方</a>描述的例外情况。</p>

  <p class="note"><em>注意，以下部分并未定义在所有情况下 ':first-line' 和 ':first-letter' 的确切渲染。CSS 的未来版本可能会更精确地定义它们。</em></p>

  <h3>5.12.1 <span class="index-def" title="pseudo-elements:::first-line|:first-line|first-line"><a
     id="first-line-pseudo">:first-line</a></span> 伪元素</h3>

  <p>:first-line 伪元素对段落的第一行内容应用特殊样式。例如：</p>

  <pre class="example">
p:first-line { text-transform: uppercase }
</pre>

  <p>上述规则的意思是“将每个段落第一行的字母转换为大写”。然而，选择器 "P:first-line" 并不匹配任何真实的 HTML 元素。它匹配的是<a
      href="conform.html#conformance">符合标准的用户代理</a>将在每个段落开头插入的一个伪元素。</p>

  <p>注意，第一行的长度取决于多种因素，包括页面宽度、字体大小等。因此，一个普通的 HTML 段落可能是这样的：</p>

  <pre class="html example">
&lt;P&gt;这是一个稍微长一点的 HTML 段落，它将被分成几行。第一行将通过虚构的标签序列来识别。其他行将被视为段落中的普通行。&lt;/P&gt;
</pre>

  <p>其行可能会如下划分：</p>

  <pre class="html example">
这是一个稍微长一点的 HTML 段落，它
将被分成几行。第一行将通过虚构的标签
序列来识别。其他行将被视为段落中的普通行。
</pre>

  <p>用户代理可能会“重写”这些行以包含用于 :first-line 的<em><a id="x48"><span class="index-def"
          title="fictional tag sequence">虚构的标签序列</span></a></em>。这个虚构的标签序列有助于展示属性的继承方式。</p>

  <pre>
&lt;P&gt;<b>&lt;P:first-line&gt;</b> 这是一个稍微长一点的 HTML 段落，
将<b>&lt;/P:first-line&gt;</b> 被分成几行。第一行将通过虚构的标签
序列来识别。其他行将被视为段落中的普通行。&lt;/P&gt;
</pre>

  <p>如果伪元素打断了真实元素，所需效果通常可以通过一个虚构的标签序列来描述，该序列关闭然后重新打开该元素。因此，如果我们在前面的段落中标记一个 SPAN 元素：</p>

  <pre>
&lt;P&gt;<b>&lt;SPAN class="test"&gt;</b> 这是一个稍微长一点的 HTML 段落，
将被分成几行。<b>&lt;/SPAN&gt;</b> 第一行将通过虚构的标签
序列来识别。其他行将被视为段落中的普通行。&lt;/P&gt;
</pre>

  <p>当插入 :first-line 的虚构标签序列时，用户代理可以模拟 SPAN 的开始和结束标签。</p>

  <pre>
&lt;P&gt;&lt;P:first-line&gt;<b>&lt;SPAN class="test"&gt;</b> 这是一个稍微长一点的 HTML 段落，
将<b>&lt;/SPAN&gt;</b>&lt;/P:first-line&gt;<b>&lt;SPAN class="test"&gt;</b> 被分成几行。<b>&lt;/SPAN&gt;</b> 第一行将通过虚构的标签
序列来识别。其他行将被视为段落中的普通行。&lt;/P&gt;
</pre>

  <p><a id="x49"><span class="index-inst" title="pseudo-elements:::first-line">:first-line</span></a> 伪元素只能附加到<a
      href="visuren.html#block-boxes">块级容器元素</a>。</p>

  <p><a
     id="first-formatted-line"></a>元素的“第一格式化行”可能出现在同一流中的块级后代内（即，非定位且非浮动的块级后代）。例如，<code>&lt;DIV>&lt;P>此行...&lt;/P>&lt;/DIV></code>
    中 DIV 的第一行是 P 的第一行（假设 P 和 DIV 都是块级的）。</p>

  <p>
    表格单元格或内联块的第一行不能是祖先元素的第一格式化行。因此，在<code>&lt;DIV&gt;&lt;P STYLE="display: inline-block">你好&lt;BR&gt;再见&lt;/P&gt; 等等&lt;/DIV&gt;</code>中，DIV
    的第一格式化行不是“你好”行。</p>

  <p class="note">注意，这段落中的 P 的第一行：<code>&lt;p&gt;&lt;br&gt;第一...</code> 不包含任何字母（假设 HTML 4 中 BR 的默认样式）。单词“第一”不在第一格式化行上。
  </p>

  <p>用户代理应该表现得好像第一行伪元素的虚构起始标签刚好嵌套在最内层的块级元素内。（由于 CSS1 和 CSS2 在这种情况下保持沉默，因此作者不应依赖此行为。）以下是一个示例。以下段落的虚构标签序列为：</p>

  <pre>
&lt;DIV>
  &lt;P>第一段落&lt;/P>
  &lt;P>第二段落&lt;/P>
&lt;/DIV>
</pre>

  <p>的虚构标签序列为：</p>

  <pre>
&lt;DIV>
  &lt;P>&lt;DIV:first-line>&lt;P:first-line>第一段落&lt;/P:first-line>&lt;/DIV:first-line>&lt;/P>
  &lt;P>&lt;P:first-line>第二段落&lt;/P:first-line>&lt;/P>
&lt;/DIV>
</pre>

  <p><a id="first-line">:first-line</a> 伪元素类似于内联级元素，但有某些限制。以下属性适用于 :first-line 伪元素：<a href="fonts.html">字体属性</a>，<a
      href="colors.html">颜色属性</a>，<a href="colors.html#background-properties">背景属性</a>，<a
      href="text.html#propdef-word-spacing" class="noxref"><span class="propinst-word-spacing">单词间距</span></a>，<a
      href="text.html#propdef-letter-spacing" class="noxref"><span class="propinst-letter-spacing">字母间距</span></a>，<a
      href="text.html#propdef-text-decoration" class="noxref"><span class="propinst-text-decoration">文本装饰</span></a>，<a
      href="text.html#propdef-text-transform" class="noxref"><span class="propinst-text-transform">文本转换</span></a>，以及<a
      href="visudet.html#propdef-line-height" class="noxref"><span
        class="propinst-line-height">行高</span></a>。用户代理也可以应用其他属性。</p>


  <h3>5.12.2 <a id="first-letter">The</a> <a id="x50"><span class="index-def"
        title="pseudo-elements:::first-letter|:first-letter|first-letter">:first-letter</span></a> 伪元素</h3>

  <p>:first-letter 伪元素必须选择块级元素第一行的第一个字母，如果该字母前面没有任何其他内容（如图片或内联表格）。:first-letter 伪元素可用于<a id="x53"><span
        class="index-inst" title="initial caps">“首字母大写”</span></a>和<a id="x54"><span class="index-inst"
        title="drop caps">“下沉式首字母”</span></a>，这些都是常见的排版效果。如果其<a href="visuren.html#propdef-float" class="noxref"><span
        class="propinst-float">float</span></a>属性为“none”，这种类型的首字母类似于内联级元素，否则它类似于浮动元素。</p>

  <p>以下属性适用于 :first-letter 伪元素：<a href="fonts.html">字体属性</a>，<a href="text.html#propdef-text-decoration"
      class="noxref"><span class="propinst-text-decoration">文本装饰</span></a>，<a href="text.html#propdef-text-transform"
      class="noxref"><span class="propinst-text-transform">文本转换</span></a>，<a href="text.html#propdef-letter-spacing"
      class="noxref"><span class="propinst-letter-spacing">字母间距</span></a>，<a href="text.html#propdef-word-spacing"
      class="noxref"><span class="propinst-word-spacing">单词间距</span></a>（如适用），<a href="visudet.html#propdef-line-height"
      class="noxref"><span class="propinst-line-height">行高</span></a>，<a href="visuren.html#propdef-float"
      class="noxref"><span class="propinst-float">浮动</span></a>，<a href="visudet.html#propdef-vertical-align"
      class="noxref"><span class="propinst-vertical-align">垂直对齐</span></a>（仅当 'float' 为 'none' 时适用），<a
      href="box.html#margin-properties">边距属性</a>，<a href="box.html#padding-properties">填充属性</a>，<a
      href="box.html#border-properties">边框属性</a>，<a href="colors.html">颜色属性</a>，<a
      href="colors.html#background-properties">背景属性</a>。用户代理还可以应用其他属性。为了让用户代理渲染出正确的下沉式首字母或首字母大写效果，用户代理可能会根据字母的形状选择行高、宽度和高度，而不像正常元素那样。CSS3
    预计将有专门适用于首字母的属性。</p>

  <div class="html example">
    <p>以下示例展示了首字母大写的可能渲染效果。注意，first-letter 伪元素继承的行高为 1.1，但本示例中的用户代理计算首字母高度时不同，因此不会在前两行之间造成多余的空隙。还要注意，首字母的虚拟起始标签位于 SPAN
      内，因此首字母的字体粗细是正常的，而不是像 SPAN 那样加粗：</p>
    <pre>
p { line-height: 1.1 }
p:first-letter { font-size: 3em; font-weight: normal }
span { font-weight: bold }
...
&lt;p>&lt;span>Het hemelsche&lt;/span> gerecht heeft zich ten lange lesten&lt;br>
Erbarremt over my en mijn benaeuwde vesten&lt;br>
En arme burgery, en op mijn volcx gebed&lt;br>
En dagelix geschrey de bange stad ontzet.
</pre>
    <div class="figure">
      <p><img src="https://www.w3.org/TR/CSS22/images/initial-cap.png" alt="图像展示 :first-letter 伪元素">
    </div>
  </div>

  <div class="html example">
    <p>以下 CSS 2.2 示例将使首字母下沉，跨越约两行：</p>

    <pre>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
 &lt;HEAD&gt;
  &lt;TITLE&gt;下沉首字母&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
   P              { font-size: 12pt; line-height: 1.2 }
   P:first-letter { font-size: 200%; font-style: italic;
                    font-weight: bold; float: left }
   SPAN           { text-transform: uppercase }
  &lt;/STYLE&gt;
 &lt;/HEAD&gt;
 &lt;BODY&gt;
  &lt;P&gt;&lt;SPAN&gt;The first&lt;/SPAN&gt; few words of an article
    in The Economist.&lt;/P&gt;
 &lt;/BODY&gt;
&lt;/HTML&gt;
</pre>

    <p>此示例可能格式化如下：</p>

    <div class="figure">
      <p><img src="https://www.w3.org/TR/CSS22/images/first-letter.png"
          alt="图像展示 :first-letter 和 :first-line 伪元素的组合效果"><SPAN class="dlink">&nbsp;&nbsp;&nbsp;<a
     id="img-first-letter" href="images/longdesc/first-letter-desc.html" title="下沉首字母示例的长描述">[D]</A></SPAN></p>
    </div>

    <p><a id="x55"><span class="index-inst" title="虚拟标签序列">虚拟标签序列</span></a>如下：</p>

    <pre>
&lt;P&gt;
&lt;SPAN&gt;
&lt;P:first-letter&gt;
T
&lt;/P:first-letter&gt;he first
&lt;/SPAN&gt; 
few words of an article in the Economist.
&lt;/P&gt;
</pre>

    <p>注意，:first-letter 伪元素标签紧靠内容（即首字符），而 :first-line 伪元素的起始标签则插入在块级元素的起始标签之后。</p>
  </div>

  <p>为了实现传统的下沉式首字母格式，用户代理可能会近似调整字体大小，例如对齐基线。此外，排版时可能会考虑字形轮廓。</p>

  <p>标点符号（即在 Unicode 中定义为 "open" (Ps)、"close" (Pe)、"initial" (Pi)、“final” (Pf) 和“其他” (Po)
    标点符号类的字符），如果出现在首字母之前或之后，则应包含在内，如：</p>

  <div class="figure">
    <p><img src="https://www.w3.org/TR/CSS22/images/first-letter2.png" alt="应该包括在首字母之前的引号。"><SPAN
        class="dlink">&nbsp;&nbsp;&nbsp;<a id="img-first-letter2" href="images/longdesc/first-letter2-desc.html"
          title="标点符号和下沉首字母示例的长描述">[D]</A></SPAN></p>
  </div>

  <p>如果首字符实际上是一个数字，例如“67 万美元是一笔巨款”，':first-letter' 也适用。</p>

  <p>:first-letter 伪元素适用于<a href="visuren.html#block-boxes">块级容器元素</a>。</p>

  <p>:first-letter 伪元素可用于包含文本的所有这些元素，或在同一流中包含文本的后代。用户代理应表现得好像 first-letter 伪元素的虚拟起始标签位于元素的第一个文本之前，即使该文本位于后代中。</p>

  <div class=example>
    <P style="display:none">Example(s):</P>
    <p>这是一个示例。此 HTML 片段的虚拟标签序列如下：</p>
    <pre>
&lt;div>
&lt;p>The first text.
</pre>
    <p>是：</p>
    <pre>
&lt;div>
&lt;p>&lt;div:first-letter>&lt;p:first-letter>T&lt;/...>&lt;/...>he first text.
</pre>
  </div>

  <p>
    表格单元格或内联块的首字母不能是祖先元素的首字母。因此，在<code>&lt;DIV&gt;&lt;P STYLE="display: inline-block">Hello&lt;BR&gt;Goodbye&lt;/P&gt; etcetera&lt;/DIV&gt;</code>中，DIV
    的首字母不是字母“H”。实际上，DIV 没有首字母。</p>

  <p>首字母必须出现在<a href="#first-formatted-line">第一格式化行</a>上。例如，在这个片段中：<code>&lt;p&gt;&lt;br&gt;First...</code>
    第一行不包含任何字母，':first-letter' 不会匹配任何内容（假设 BR 的默认样式在 HTML4 中）。尤其是，它不会匹配“First”中的“F”。</p>

  <p>如果一个元素是<a href="generate.html#lists">列表项</a>（'display: list-item'），':first-letter' 适用于标记后的主要框中的首字母。用户代理可能会忽略带有
    'list-style-position: inside' 的列表项上的 ':first-letter'。如果一个元素有 ':before' 或 ':after' 内容，':first-letter'
    适用于包含该内容的元素的首字母。</p>

  <p class="example">例如，在规则 'p:before {content: "Note: "}' 之后，选择器 'p:first-letter' 将匹配“Note”中的“N”。</p>

  <p>某些语言可能有关于如何处理某些字母组合的特定规则。例如，在荷兰语中，如果“ij”字母组合出现在单词的开头，则两个字母都应视为 :first-letter 伪元素的一部分。</p>

  <p>如果构成首字母的字母不在同一个元素中，例如在<code>&lt;p>'&lt;em>T...</code> 中的“'T”，用户代理可以从其中一个元素、两个元素创建首字母伪元素，或者根本不创建伪元素。</p>

  <p>同样，如果块的首字母不在行首（例如由于双向重排），则用户代理可能不会创建伪元素。</p>

  <div class="example">
    <P style="display:none">Example(s):</P>
    <p><a id="overlapping-example">以下示例</a>说明了重叠伪元素可能如何相互作用。每个 P 元素的首字母将是绿色的，字体大小为
      '24pt'。第一格式化行的其余部分将是“蓝色的”，而段落的其余部分将是“红色的”。</p>

    <pre>
p { color: red; font-size: 12pt }
p:first-letter { color: green; font-size: 200% }
p:first-line { color: blue }

&lt;P&gt;Some text that ends up on two lines&lt;/P&gt;
</pre>

    <p>假设在单词“ends”之前会出现换行，这个片段的<a id="x56"><span class="index-inst" title="虚拟标签序列">虚拟标签序列</span></a>可能是：</p>

    <pre>
&lt;P&gt;
&lt;P:first-line&gt;
&lt;P:first-letter&gt; 
S 
&lt;/P:first-letter&gt;ome text that 
&lt;/P:first-line&gt; 
ends up on two lines 
&lt;/P&gt;
</pre>

    <p>注意 :first-letter 元素在 :first-line 元素内。:first-line 上设置的属性由 :first-letter 继承，但如果在 :first-letter 上设置了相同的属性，则会被覆盖。</p>
  </div>

  <h3>5.12.3 <a id="before-and-after">The</a> <a id="x57"><span class="index-def"
        title="pseudo-elements:::before|:before">:before</span></a> 和 <a id="x59"><span class="index-def"
        title="pseudo-elements:::after|:after">:after</span></a> 伪元素</h3>

  <p>':before' 和 ':after' 伪元素可用于在元素内容的前后插入生成的内容。它们在<a href="generate.html">生成文本</a>一节中进行了说明。</p>

  <div class="example">
    <P style="display:none">Example(s):</P>
    <P>
    <pre>
h1:before {content: counter(chapno, upper-roman) ". "}
</pre>
  </div>

  <p>当 :first-letter 和 :first-line 伪元素应用于具有使用 :before 和 :after 生成的内容的元素时，它们适用于包括生成内容的元素的首字母或首行。</p>

  <div class="example">
    <P style="display:none">Example(s):</P>
    <P>
    <pre>
p.special:before {content: "Special! "}
p.special:first-letter {color: #ffd800}
</pre>
    <p>这将使“Special!”中的“S”呈现为金色。</p>
  </div>

  <hr class="navbar">

  <div class="navbar">
    <p><a href="syndata.html">上一页</a> &nbsp;
      <a href="cascade.html">下一页</a> &nbsp;
      <a href="index.html#minitoc">内容</a> &nbsp;
      <a href="propidx.html">属性</a> &nbsp;
      <a href="indexlist.html">索引</a> &nbsp;
  </div>
  <script src="https://www.w3.org/scripts/TR/2016/fixup.js"></script>
</body>

</html>