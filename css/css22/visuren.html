<!DOCTYPE html>
<html lang="zh-hans">

<head>
  <title>视觉格式化模型</title>
  <link rel="stylesheet" href="https://www.w3.org/TR/CSS22/style/default.css" type="text/css">
  <link rel="stylesheet" href="https://www.w3.org/StyleSheets/TR/2016/W3C-WD.css" type="text/css">
  <link rel="prev" href="box.html">
  <link rel="next" href="visudet.html">
  <link rel="contents" href="index.html#minitoc">
  <link rel="CSS-properties" href="propidx.html" title="properties">
  <link rel="index" href="indexlist.html" title="index">
  <link rel="first" href="index.html">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <style type="text/css">
    .current,
    .proposed,
    span.delcurrent {
      background: #feb
    }

    ins.proposed,
    span.insproposed,
    li.insproposed {
      background: #bfb
    }

    del.proposed,
    span.delproposed {
      background: #fbb
    }

    span.insproposed,
    li.insproposed {
      text-decoration: underline
    }

    span.delproposed,
    span.delcurrent {
      text-decoration: line-through
    }

    body>del,
    body>ins {
      display: block
    }

    blockquote.math {
      display: table
    }

    blockquote.math p {
      display: table-row
    }

    blockquote.math span {
      display: table-cell;
      padding-right: 0.3em
    }

    blockquote.math span:first-child {
      text-align: right
    }
  </style>
</head>

<body>
  <div class="navbar">
    <p><a href="box.html">上一页</a> &nbsp;
      <a href="visudet.html">下一页</a> &nbsp;
      <a href="index.html#minitoc">目录</a> &nbsp;
      <a href="propidx.html">属性</a> &nbsp;
      <a href="indexlist.html">索引</a> &nbsp;
  </div>
  <hr class="navbar">

  <h1><a name="q0">9 可视化格式模型</a></h1>
  <div id="toc" class="subtoc">
    <p><strong>内容</strong>
    <ul class="toc">
      <li><a href="visuren.html#visual-model-intro" class="tocxref">9.1 可视化格式模型介绍</a>
        <ul class="toc">
          <li><a href="visuren.html#viewport" class="tocxref">9.1.1 视口</a>
          <li><a href="visuren.html#containing-block" class="tocxref">9.1.2 <span class="index-def"
                title="containing block">包含块</span></a>
        </ul>
      <li><a href="visuren.html#box-gen" class="tocxref">9.2 控制框生成</a>
        <ul class="toc">
          <li><a href="visuren.html#block-boxes" class="tocxref">9.2.1 块级元素和块框</a>
            <ul class="toc">
              <li><a href="visuren.html#anonymous-block-level" class="tocxref">9.2.1.1 匿名块框</a>
            </ul>
          <li><a href="visuren.html#inline-boxes" class="tocxref">9.2.2 内联级元素和内联框</a>
            <ul class="toc">
              <li><a href="visuren.html#anonymous" class="tocxref">9.2.2.1 匿名内联框</a>
            </ul>
          <li><a href="visuren.html#run-in" class="tocxref">9.2.3 行内框</a>
          <li><a href="visuren.html#display-prop" class="tocxref">9.2.4 <span class="propinst-display">'display'</span>
              属性</a>
        </ul>
      <li><a href="visuren.html#positioning-scheme" class="tocxref">9.3 定位方案</a>
        <ul class="toc">
          <li><a href="visuren.html#choose-position" class="tocxref">9.3.1 选择一个定位方案：<span
                class="propinst-position">'position'</span> 属性</a>
          <li><a href="visuren.html#position-props" class="tocxref">9.3.2 框偏移：<span
                class="propinst-top">'top'</span>，<span class="propinst-right">'right'</span>，<span
                class="propinst-bottom">'bottom'</span>，<span class="propinst-left">'left'</span></a>
        </ul>
      <li><a href="visuren.html#normal-flow" class="tocxref">9.4 正常流</a>
        <ul class="toc">
          <li><a href="visuren.html#block-formatting" class="tocxref">9.4.1 块格式化上下文</a>
          <li><a href="visuren.html#inline-formatting" class="tocxref">9.4.2 内联格式化上下文</a>
          <li><a href="visuren.html#relative-positioning" class="tocxref">9.4.3 相对定位</a>
        </ul>
      <li><a href="visuren.html#floats" class="tocxref">9.5 浮动</a>
        <ul class="toc">
          <li><a href="visuren.html#float-position" class="tocxref">9.5.1 浮动的定位：<span
                class="propinst-float">'float'</span> 属性</a>
          <li><a href="visuren.html#flow-control" class="tocxref">9.5.2 控制浮动旁边的流：<span
                class="propinst-clear">'clear'</span> 属性</a>
        </ul>
      <li><a href="visuren.html#absolute-positioning" class="tocxref">9.6 绝对定位</a>
        <ul class="toc">
          <li><a href="visuren.html#fixed-positioning" class="tocxref">9.6.1 固定定位</a>
        </ul>
      <li><a href="visuren.html#dis-pos-flo" class="tocxref">9.7 'display'、'position' 和 'float' 之间的关系</a>
      <li><a href="visuren.html#comparison" class="tocxref">9.8 正常流、浮动和绝对定位的比较</a>
        <ul class="toc">
          <li><a href="visuren.html#comp-normal-flow" class="tocxref">9.8.1 正常流</a>
          <li><a href="visuren.html#comp-relpos" class="tocxref">9.8.2 相对定位</a>
          <li><a href="visuren.html#comp-float" class="tocxref">9.8.3 浮动一个框</a>
          <li><a href="visuren.html#comp-abspos" class="tocxref">9.8.4 绝对定位</a>
        </ul>
      <li><a href="visuren.html#layers" class="tocxref">9.9 层次化呈现</a>
        <ul class="toc">
          <li><a href="visuren.html#z-index" class="tocxref">9.9.1 指定堆叠级别：<span
                class="propinst-z-index">'z-index'</span> 属性</a>
        </ul>
      <li><a href="visuren.html#direction" class="tocxref">9.10 文字方向：<span class="propinst-direction">'direction'</span>
          和 <span class="propinst-unicode-bidi">'unicode-bidi'</span>
          属性</a>
    </ul>
  </div>


  <h2>9.1 <a name="visual-model-intro">可视化格式模型介绍</a></h2>

  <p>本章和下一章描述了<a name="x0"><span class="index-def" title="visual formatting model">可视化格式模型</span></a>：用户代理如何处理<a
      href="conform.html#doctree">文档树</a>以用于可视<a href="media.html">媒体</a>。
  </p>

  <p>在可视化格式模型中，文档树中的每个元素根据<a href="box.html">框模型</a>生成零个或多个框。这些框的布局受以下因素影响：</p>

  <ul>
    <li><a href="box.html#box-dimensions">框的尺寸</a>和<a href="#box-gen">类型</a>。
    </li>
    <li><a href="#positioning-scheme">定位方案</a>（正常流、浮动和绝对定位）。
    </li>
    <li>文档树中元素之间的关系
      （<a href="conform.html#doctree">文档树</a>）。
    </li>
    <li>外部信息（例如，视口大小，<a href="conform.html#intrinsic">图像的固有</a>尺寸等）。
    </li>
  </ul>

  <p>本章和下一章中定义的属性适用于<a href="media.html#continuous-media-group">连续媒体</a>和<a
      href="media.html#paged-media-group">分页媒体</a>。<span class="paged">
      然而，当应用于分页媒体时，<a href="box.html#margin-properties">外边距属性</a>的含义有所不同（详见<a href="page.html#page-margins">页面模型</a>）。
    </span>
  </p>

  <p>可视化格式模型并未规定所有格式化的细节（例如，它没有指定字母间距算法）。<a href="conform.html#conformance">符合标准的用户代理</a>可能在本规范未涵盖的格式化问题上表现不同。
  </p>

  <h3>9.1.1 <a name="viewport">视口</a></h3>

  <p>针对<a href="media.html#continuous-media-group">连续媒体</a>的用户代理通常为用户提供一个<a name="x1"><span class="index-def"
        title="viewport"><dfn>视口</dfn></span></a>（屏幕上的一个窗口或其他查看区域），用户通过视口来查看文档。当视口大小调整时，用户代理可能会改变文档的布局（参见<a
      href="visudet.html#containing-block-details">初始包含块</a>）。
  </p>
  <p>
    当视口小于渲染文档的画布区域时，用户代理应提供一个滚动机制。

    每个<a href="intro.html#canvas">画布</a>最多有一个视口，但用户代理可以渲染多个画布（即，提供同一文档的不同视图）。
  </p>

  <h3>9.1.2 <span class="index-def" title="containing block">
      <a name="containing-block">包含块</a></span>
  </h3>

  <p>在 CSS&nbsp;2.2 中，许多框的位置和尺寸是相对于一个称为<a name="x3"><span class="index-def"
        title="containing block"><dfn>包含块</dfn></span></a>的矩形框的边缘来计算的。通常，生成的框作为后代框的包含块；我们称一个框“建立”了其后代的包含块。短语“一个框的包含块”指的是“框所在的包含块”，而不是它生成的那个。
  </p>
  <p>每个框的位置是相对于其包含块给出的，但它不受该包含块的限制；它可能会<a href="visufx.html#overflow">溢出</a>。
  </p>

  <p>关于如何计算包含块的尺寸的<a href="visudet.html#containing-block-details">详细信息</a>将在<a href="visudet.html">下一章</a>中描述。
  </p>
  <h2>9.2 <a name="box-gen">控制框生成</a></h2>

  <p>以下部分描述了在 CSS&nbsp;2.2 中可能生成的框类型。框的类型部分地影响其在可视化格式模型中的行为。下面描述的<a href="visuren.html#propdef-display"
      class="noxref"><span class="propinst-display">'display'</span></a>属性指定了框的类型。
  </p>

  <p>某些<a href="visuren.html#propdef-display" class="noxref"><span
        class="propinst-display">'display'</span></a>属性的值会使源文档的一个元素生成一个包含后代框和生成内容的<span class="index-def"
      title="principal box"><a
        name="principal-box"><dfn>主要框</dfn></a></span>，并且该框也参与任何定位方案。一些元素除了主要框外还可能生成其他框：'list-item'元素。这些附加的框是相对于主要框放置的。
  </p>

  <h3>9.2.1 <a name="block-boxes">块级元素和块框</a></h3>

  <p><span class="index-def" title="block-level element"><a name="block-level"><dfn>块级元素</dfn></a></span> &ndash;
    源文档中那些在视觉上被格式化为块的元素（例如段落）&ndash; 是生成块级主要框的元素。使一个元素成为块级的<a href="visuren.html#propdef-display" class="noxref"><span
        class="propinst-display">'display'</span></a>属性值包括：'block'、'list-item'和'table'。<a name="x6"><span
        class="index-def" title="block-level box"><dfn>块级框</dfn></span></a>是参与<a href="#block-formatting">块格式化上下文</a>的框。
  </p>

  <p>在 CSS&nbsp;2.2 中，块级框也是块容器框，除非它是表格框或替换元素的主要框。一个<span class="index-def" title="block container box"><a
        name="block-container-box"><dfn>块容器框</dfn></a></span>要么只包含块级框，要么建立一个<a
      href="#inline-formatting">内联格式化上下文</a>，因此只包含<a href="#anonymous-block-level">内联级框</a>。主要框是块容器框的元素是一个<span
      class="index-def" title="block container element"><a
        name="block-container-element"><dfn>块容器元素。</dfn></a></span>使非替换元素生成块容器的'display'属性值包括'block'、'list-item'和'inline-block'。并非所有块容器框都是块级框：非替换内联块和非替换表格单元格是块容器但不是块级框。既是块级框又是块容器的块级框称为<a
      name="x9"><span class="index-def" title="block box"><dfn>块框</dfn></span></a>。
  </p>

  <p>“块级框”、“块容器框”和“块框”这三个术语有时可以在上下文明确的情况下简写为“块”。
  </p>

  <h4>9.2.1.1 <a name="anonymous-block-level">匿名块框</a></h4>

  <p>在这样的文档中：
  </p>
  <pre><code class="html">
&lt;DIV&gt;
  Some text
  &lt;P&gt;More text
&lt;/DIV&gt;
</code></pre>
  <p>
    （假设 DIV 和 P 都有 'display: block'），DIV 似乎同时具有内联内容和块级内容。为了更容易定义格式，我们假设在 "Some text" 周围有一个<em><a name="x10"><span
          class="index-def" title="anonymous">匿名块框</span></a></em>。
  </p>
  <div class="figure">
    <p><img src="https://www.w3.org/TR/CSS22/images/anon-block.png"
        alt="diagram showing the three boxes for the example above"><SPAN class="dlink">&nbsp;&nbsp;&nbsp;<A
          name="img-anon-block" href="images/longdesc/anon-block-desc.html"
          title="Long description for anonymous block box">[D]</A></SPAN>
    </p>
    <p class="caption">此图显示了上述示例中的三个框，其中一个是匿名框。
    </p>
  </div>

  <p>换句话说：如果一个块容器框（例如上面生成的 DIV）内有一个块级框（例如上面的 P），那么我们强制它内部<em>仅</em>包含块级框。
  </p>

  <p>
    当一个内联框包含一个流内块级框时，内联框（及其在同一行框内的内联祖先）会在块级框（以及任何连续的块级兄弟或仅由可折叠的空白字符和/或流外元素分隔的兄弟）周围断开，将内联框分成两个框（即使任一侧为空），分别位于块级框的两侧。断开前后的行框被封装在匿名块框中，而块级框成为这些匿名框的兄弟。当这样的内联框受到相对定位的影响时，任何产生的平移也会影响内联框中包含的块级框。
  </p>

  <div class="example">
    <P style="display:none">示例：</P>
    <p>如果使用以下规则，此模型将适用于以下示例：</p>

    <pre><code class="css">
p    { display: inline }
span { display: block }
</code></pre>

    <p>与这个 HTML 文档一起使用：</p>

    <pre class="html example"><code class="html">
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;被块打断的匿名文本&lt;/TITLE&gt;
&lt;/HEAD&gt;
&lt;BODY&gt;
&lt;P&gt;
<em>这是在 SPAN 之前的匿名文本。</em>
&lt;SPAN&gt;这是 SPAN 的内容。&lt;/SPAN&gt;
<em>这是在 SPAN 之后的匿名文本。</em>
&lt;/P&gt;
&lt;/BODY&gt;
</code></pre>

    <p>P 元素包含一块（C1）匿名文本，后面跟着一个块级元素，再后面跟着另一块（C2）匿名文本。生成的框将是表示 BODY 的块框，包含一个围绕 C1 的匿名块框、SPAN 块框和另一个围绕 C2 的匿名块框。
    </p>
  </div>

  <p>匿名框的属性是从包围它的非匿名框继承的（例如，在“小节标题‘匿名块框’”下方的示例中，继承自 DIV 的属性）。非继承属性具有其初始值。例如，匿名框的字体从 DIV 继承，但外边距将为 0。
  </p>
  <p>
    设置在导致生成匿名块框的元素上的属性仍然适用于该元素的框和内容。例如，如果在上述示例中的 P 元素上设置了边框，则边框将围绕 C1（在行的末端开放）和 C2（在行的起始开放）绘制。
  </p>
  <p>
    一些用户代理以其他方式实现了包含块的内联框的边框，例如，通过将这些嵌套块包装在“匿名行框”内，从而围绕这些框绘制内联边框。由于 CSS1 和 CSS2 并未定义此行为，因此仅支持 CSS1 和 CSS2
    的用户代理可能会实现此替代模型，并且仍声称符合 CSS&nbsp;2.2 的这一部分。这不适用于在本规范发布后开发的用户代理。
  </p>

  <p>在解析将引用匿名块框的百分比值时，将忽略匿名块框：改为使用最近的非匿名祖先框。例如，如果 DIV 内的匿名块框的子元素需要知道其包含块的高度以解析百分比高度，那么它将使用由 DIV 形成的包含块的高度，而不是匿名块框的高度。
  </p>

  <h3>9.2.2 <a name="inline-boxes">内联级元素和内联框</a></h3>

  <p><span class="index-def" title="inline-level element">
      <a name="inline-level"><dfn>内联级元素</dfn></a></span>是源文档中不会形成新的内容块的那些元素；内容分布在行中（例如段落中的强调文本、内联图像等）。以下<a
      href="visuren.html#propdef-display" class="noxref"><span
        class="propinst-display">'display'</span></a>属性值使元素成为内联级：'inline'、'inline-table'和'inline-block'。

    内联级元素生成<a name="x12"><span class="index-def" title="inline-level box"><dfn>内联级框</dfn></span></a>，这些框是参与内联格式化上下文的框。
  </p>

  <p><span class="index-def" title="inline box"><a
        name="inline-box"><dfn>内联框</dfn></a></span>是既为内联级又参与其包含的内联格式化上下文的框。具有'display'值为'inline'的非替换元素生成一个内联框。不是内联框的内联级框（例如替换的内联级元素、内联块元素和内联表格元素）被称为<a
      name="x14"><span class="index-def"
        title="atomic inline-level box"><dfn>原子内联级框</dfn></span></a>，因为它们在内联格式化上下文中作为一个单一的、不透明的框参与。
  </p>

  <h4>9.2.2.1 <a name="anonymous">匿名内联框</a></h4>

  <p>任何直接包含在块容器元素中的文本（不在内联元素内）必须被视为匿名内联元素。
  </p>

  <p>在具有如下 HTML 标记的文档中：</p>

  <div class="html example">
    <pre><code class="html">
&lt;p&gt;Some &lt;em&gt;emphasized&lt;/em&gt; text&lt;/p&gt;
</code></pre>
  </div>

  <p><code>&lt;p&gt;</code>生成一个块框，其中包含几个内联框。"emphasized" 的框是由内联元素（<code>&lt;em&gt;</code>）生成的内联框，但其他框（"Some" 和
    "text"）是由块级元素（<code>&lt;p&gt;</code>）生成的内联框。后者被称为<a name="x15"><span class="index-def"
        title="anonymous inline boxes">匿名内联框</span></a>，因为它们没有关联的内联级元素。
  </p>

  <p>这些匿名内联框继承自其块父框的可继承属性。非继承属性具有其初始值。在示例中，匿名内联框的颜色继承自 P，但背景是透明的。
  </p>

  <p>
    根据<a href="text.html#propdef-white-space" class="noxref"><span
        class="propinst-white-space">'white-space'</span></a>属性后续会被折叠掉的空白内容不会生成任何匿名内联框。
  </p>

  <p>如果从上下文中可以清楚地知道是哪种类型的匿名框，则在本规范中，匿名内联框和匿名块框都简单地称为匿名框。
  </p>

  <p>在格式化<a href="tables.html#anonymous-boxes">表格</a>时，还会出现更多类型的匿名框。
  </p>


  <h3>9.2.3 <a name="run-in">行内块框</a></h3>

  <p>[此部分存在的目的是为了使章节编号与之前的草案保持一致。<a name="x16"><span class="index-def" title="run-in">'Display: run-in'</span></a> 现在在
    CSS 第&nbsp;3&nbsp;级中定义（请参见 <a href="https://www.w3.org/TR/css3-box/">CSS 基本框模型</a>）。]
  </p>

  <h3>9.2.4 <a name="display-prop">The</a> <a href="visuren.html#propdef-display" class="noxref"><span
        class="propinst-display">'display'</span></a> 属性</h3>

  <table class="def propdef">
    <tbody>
      <tr>
        <th>名称:</th>
        <td><a name="x17"><span class="index-def" title="'display'"><dfn id="propdef-display">display</dfn></span></a>
        </td>
      </tr>
      <tr>
        <th>值:</th>
        <td>inline | block | list-item | inline-block |
          table | inline-table | table-row-group | table-header-group |
          table-footer-group | table-row | table-column-group | table-column |
          table-cell | table-caption | none | <a href="cascade.html#value-def-inherit" class="noxref"><span
              class="value-inst-inherit">inherit</span></a>
        </td>
      </tr>
      <tr>
        <th>初始值:</th>
        <td>inline</td>
      </tr>
      <tr>
        <th>适用于:</th>
        <td>所有元素</td>
      </tr>
      <tr>
        <th>是否继承:</th>
        <td>否</td>
      </tr>
      <tr>
        <th>百分比:</th>
        <td>不适用</td>
      </tr>
      <tr>
        <th>媒体:</th>
        <td><a href="media.html#all-media-group" class="noxref">所有</a></td>
      </tr>
      <tr>
        <th>计算值:</th>
        <td>详见文本</td>
      </tr>
    </tbody>
  </table>

  <p>此属性的值具有以下含义：</p>

  <dl>
    <dt><span class="index-def" title="'block', definition of"><a
          name="value-def-block"><strong>block</strong></a></span></dt>
    <dd>此值使元素生成一个主要的块框。</dd>

    <dt><span class="index-def" title="'inline-block', definition of"><a
          name="value-def-inline-block"><strong>inline-block</strong></a></span></dt>
    <dd>此值使元素生成一个主要的内联级块容器。（inline-block 的内部格式化为块框，元素本身格式化为一个原子内联级框。）</dd>

    <dt><span class="index-def" title="'inline', definition of"><a
          name="value-def-inline"><strong>inline</strong></a></span></dt>
    <dd>此值使元素生成一个或多个内联框。</dd>

    <dt><span class="index-def" title="'list-item', definition of"><a
          name="value-def-list-item"><strong>list-item</strong></a></span></dt>
    <dd>此值使元素（例如 HTML 中的 LI）生成一个主要块框和一个标记框。有关列表的信息和示例，请参阅<a href="generate.html#lists">列表</a>部分。</dd>

    <dt><strong>none</strong></dt>
    <dd><a name="x22"><span class="index-def" title="'none'::as display value">此值</span></a>使元素不会出现在<a
        href="intro.html#formatting-structure">格式化结构</a>中（即，在可视媒体中，元素不会生成任何框，也不会对布局产生影响）。后代元素也不会生成任何框；该元素及其内容将完全从格式化结构中移除。此行为<strong>不能</strong>通过在后代上设置<a
        href="visuren.html#propdef-display" class="noxref"><span class="propinst-display">'display'</span></a>属性来覆盖。

      <p>请注意，'none' 的 display 并不会创建一个不可见的框；它根本不创建任何框。CSS 包含使元素在格式化结构中生成框的机制，这些框会影响格式化但本身不可见。详情请参阅<a
          href="visufx.html#visibility">可见性</a>部分。
      </p>
    </dd>

    <dt>
      <a href="tables.html#value-def-table" class="noxref"><span class="value-inst-table">table</span></a>，
      <a href="tables.html#value-def-inline-table" class="noxref"><span
          class="value-inst-inline-table">inline-table</span></a>，
      <a href="tables.html#value-def-table-row-group" class="noxref"><span
          class="value-inst-table-row-group">table-row-group</span></a>，
      <a href="tables.html#value-def-table-column" class="noxref"><span
          class="value-inst-table-column">table-column</span></a>，
      <a href="tables.html#value-def-table-column-group" class="noxref"><span
          class="value-inst-table-column-group">table-column-group</span></a>，
      <a href="tables.html#value-def-table-header-group" class="noxref"><span
          class="value-inst-table-header-group">table-header-group</span></a>，
      <a href="tables.html#value-def-table-footer-group" class="noxref"><span
          class="value-inst-table-footer-group">table-footer-group</span></a>，
      <a href="tables.html#value-def-table-row" class="noxref"><span class="value-inst-table-row">table-row</span></a>，
      <a href="tables.html#value-def-table-cell" class="noxref"><span
          class="value-inst-table-cell">table-cell</span></a>，以及
      <a href="tables.html#value-def-table-caption" class="noxref"><span
          class="value-inst-table-caption">table-caption</span></a>
    </dt>
    <dd>这些值使元素表现得像表格元素（受限于<a href="tables.html">表格</a>章节中描述的限制）。
    </dd>
  </dl>

  <p>计算值与指定值相同，但定位和浮动元素（请参阅<a href="#dis-pos-flo">"display"、"position" 和 "float" 之间的关系</a>）以及根元素除外。

    对于根元素，计算值的更改方式详见<a href="#dis-pos-flo">"display"、"position" 和 "float" 之间的关系</a>部分。
  </p>

  <p>请注意，虽然<a href="about.html#initial-value">初始值</a>为<a href="visuren.html#propdef-display" class="noxref"><span
        class="propinst-display">'display'</span></a>是'inline'，但用户代理的<a
      href="cascade.html#default-style-sheet">默认样式表</a>中的规则可能会<a href="cascade.html">覆盖</a>此值。请参阅附录中的 HTML 4<a
      href="sample.html">示例样式表</a>。
  </p>
  <div class="example">
    <P style="display:none">示例：</P>
    <p>以下是<a href="visuren.html#propdef-display" class="noxref"><span
          class="propinst-display">'display'</span></a>属性的一些示例：</p>
    <pre><code class="css">
p   { display: block }
em  { display: inline }
li  { display: list-item } 
img { display: none }      /* 不显示图像 */
</code></pre>
  </div>


  <h2>9.3 <a name="positioning-scheme">定位方案</a></h2>

  <p>在 CSS&nbsp;2.2 中，一个框可以根据三种<a name="x23"><span class="index-def"
        title="positioning scheme"><dfn>定位方案</dfn></span></a>进行布局：</p>

  <ol>
    <li><a href="#normal-flow">正常流</a>。在 CSS&nbsp;2.2 中，正常流包括块级框的<a href="#block-formatting">块格式化</a>、内联级框的<a
        href="#inline-formatting">内联格式化</a>，以及块级和内联级框的<a href="#relative-positioning">相对定位</a>。
    </li>
    <li><a href="#floats">浮动</a>。在浮动模型中，框首先根据正常流进行布局，然后从流中移出并尽可能向左或向右移动。内容可以沿着浮动的一侧流动。
    </li>
    <li><a href="#absolute-positioning">绝对定位</a>。在绝对定位模型中，框完全从正常流中移除（它对后面的兄弟元素没有影响），并相对于包含块分配位置。
    </li>
  </ol>

  <p>如果一个元素是浮动的、绝对定位的或是根元素，则称其为<dfn><a name="x24"><span class="index-def">脱离流</span></a></dfn>元素。如果一个元素没有脱离流，则称其为<dfn><a
        name="x25"><span class="index-def">在流中</span></a></dfn>元素。元素<var>A</var>的<dfn><a name="x26"><span
          class="index-def">流</span></a></dfn>是由<var>A</var>及所有最近的脱离流祖先为<var>A</var>的在流中元素组成的集合。
  </p>

  <div class="note">
    <em><strong>注意：</strong>
      CSS&nbsp;2.2 的定位方案通过允许作者避免用于布局效果的标记技巧（例如，隐藏图像），帮助他们使文档更加易于访问。
    </em>
  </div>

  <h3>9.3.1 <a name="choose-position">选择一个定位方案：</a> <a href="visuren.html#propdef-position" class="noxref"><span
        class="propinst-position">'position'</span></a> 属性</h3>

  <p><a href="visuren.html#propdef-position" class="noxref"><span class="propinst-position">'position'</span></a> 和 <a
      href="visuren.html#propdef-float" class="noxref"><span class="propinst-float">'float'</span></a> 属性决定了使用哪种
    CSS&nbsp;2.2 定位算法来计算框的位置。
  </p>

  <table class="def propdef">
    <tbody>
      <tr>
        <th>名称:</th>
        <td><a name="x27"><span class="index-def" title="'position'"><dfn
                id="propdef-position">position</dfn></span></a></td>
      </tr>
      <tr>
        <th>值:</th>
        <td>static | relative | absolute | fixed | <a href="cascade.html#value-def-inherit" class="noxref"><span
              class="value-inst-inherit">inherit</span></a></td>
      </tr>
      <tr>
        <th>初始值:</th>
        <td>static</td>
      </tr>
      <tr>
        <th>适用于:</th>
        <td>所有元素</td>
      </tr>
      <tr>
        <th>是否继承:</th>
        <td>否</td>
      </tr>
      <tr>
        <th>百分比:</th>
        <td>不适用</td>
      </tr>
      <tr>
        <th>媒体:</th>
        <td><a href="media.html#visual-media-group" class="noxref">可视媒体</a></td>
      </tr>
      <tr>
        <th>计算值:</th>
        <td>按指定值</td>
      </tr>
    </tbody>
  </table>

  <p>此属性的值具有以下含义：</p>

  <dl>
    <dt><strong>static</strong></dt>
    <dd>框是一个正常的框，按照<a href="#normal-flow">正常流</a>布局。<a href="visuren.html#propdef-top" class="noxref"><span
          class="propinst-top">'top'</span></a>、<a href="visuren.html#propdef-right" class="noxref"><span
          class="propinst-right">'right'</span></a>、<a href="visuren.html#propdef-bottom" class="noxref"><span
          class="propinst-bottom">'bottom'</span></a> 和 <a href="visuren.html#propdef-left" class="noxref"><span
          class="propinst-left">'left'</span></a> 属性不适用。
    </dd>

    <dt><strong>relative</strong></dt>
    <dd>框的位置是根据<a href="#normal-flow">正常流</a>计算的（这称为正常流中的位置）。然后框相对于其正常位置进行<a href="#relative-positioning">偏移</a>。当一个框 B
      相对定位时，后续框的位置是按照 B 未偏移时计算的。'position:relative' 对
      table-row-group、table-header-group、table-footer-group、table-row、table-column-group、table-column、table-cell 和
      table-caption 元素的效果是未定义的。
    </dd>

    <dt><strong>absolute</strong></dt>
    <dd>框的位置（可能还有大小）由 <a href="visuren.html#propdef-top" class="noxref"><span class="propinst-top">'top'</span></a>、<a
        href="visuren.html#propdef-right" class="noxref"><span class="propinst-right">'right'</span></a>、<a
        href="visuren.html#propdef-bottom" class="noxref"><span class="propinst-bottom">'bottom'</span></a> 和 <a
        href="visuren.html#propdef-left" class="noxref"><span class="propinst-left">'left'</span></a> 属性指定。这些属性指定相对于框的<a
        href="#containing-block">包含块</a>的偏移。绝对定位的框被从正常流中移除，这意味着它们对后续兄弟元素的布局没有影响。此外，尽管<a
        href="#absolutely-positioned">绝对定位</a>的框有外边距，但它们不会与其他外边距<a href="box.html#collapsing-margins">折叠</a>。
    </dd>

    <dt><strong>fixed</strong></dt>
    <dd>框的位置是按照 'absolute' 模型计算的，但除此之外，框相对于某个参考点是<a href="#fixed-positioning">固定</a>的。与 'absolute'
      模型一样，框的外边距不会与任何其他外边距折叠。在 handheld、projection、screen、tty 和 tv 媒体类型的情况下，框是相对于<a
        href="#viewport">视口</a>固定的，并且在滚动时不会移动。在 print 媒体类型的情况下，框会在每一页上渲染，并且相对于页面框固定，即使页面是通过<a
        href="#viewport">视口</a>看到的（例如，在打印预览的情况下）。对于其他媒体类型，呈现是未定义的。作者可能希望以依赖媒体的方式指定 'fixed'。例如，作者可能希望一个框保持在屏幕上的<a
        href="#viewport">视口</a>顶部，但不在每个打印页面的顶部。可以通过使用<a href="media.html#at-media-rule">@media 规则</a>来分隔这两个规范，如下所示：

      <div class="example">
        <P style="display:none">示例：</P>
        <pre><code class="css">   
@media screen { 
  h1#first { position: fixed } 
}
@media print { 
  h1#first { position: static }
}
</code></pre>
      </div>
      <p>用户代理不得对固定框的内容进行分页。<span class="note">注意，用户代理可以通过其他方式打印不可见的内容。详见第&nbsp;13 章的<a
            href="page.html#outside-page-box">“页面框外的内容”</a>。</span>
    </dd>
  </dl>

  <p>
    用户代理可以将根元素的 position 属性视为 'static'。
  </p>

  <h3>9.3.2 <a name="position-props">框的偏移</a>：<a href="visuren.html#propdef-top" class="noxref"><span
        class="propinst-top">'top'</span></a>，<a href="visuren.html#propdef-right" class="noxref"><span
        class="propinst-right">'right'</span></a>，<a href="visuren.html#propdef-bottom" class="noxref"><span
        class="propinst-bottom">'bottom'</span></a>，<a href="visuren.html#propdef-left" class="noxref"><span
        class="propinst-left">'left'</span></a></h3>

  <p>如果元素的<a href="visuren.html#propdef-position" class="noxref"><span
        class="propinst-position">'position'</span></a>属性的值不是'static'，则该元素被称为<span class="index-def"
      title="positioned element/box"><a name="positioned-element"><dfn>定位元素</dfn></a></span>。定位元素生成定位框，按照以下四个属性布局：</p>

  <table class="def propdef">
    <tbody>
      <tr>
        <th>名称:</th>
        <td><a name="x29"><span class="index-def" title="'top'"><dfn id="propdef-top">top</dfn></span></a></td>
      </tr>
      <tr>
        <th>值:</th>
        <td><a href="syndata.html#value-def-length" class="noxref"><span
              class="value-inst-length">&lt;length&gt;</span></a> | <a href="syndata.html#value-def-percentage"
            class="noxref"><span class="value-inst-percentage">&lt;percentage&gt;</span></a> | auto | <a
            href="cascade.html#value-def-inherit" class="noxref"><span class="value-inst-inherit">inherit</span></a>
        </td>
      </tr>
      <tr>
        <th>初始值:</th>
        <td>auto</td>
      </tr>
      <tr>
        <th>适用于:</th>
        <td>定位元素</td>
      </tr>
      <tr>
        <th>是否继承:</th>
        <td>否</td>
      </tr>
      <tr>
        <th>百分比:</th>
        <td>参考包含块的高度</td>
      </tr>
      <tr>
        <th>媒体:</th>
        <td><a href="media.html#visual-media-group" class="noxref">可视媒体</a></td>
      </tr>
      <tr>
        <th>计算值:</th>
        <td>如果指定为长度，则为相应的绝对长度；如果指定为百分比，则为指定值；否则为'auto'。</td>
      </tr>
    </tbody>
  </table>

  <p>此属性指定一个<a href="#absolutely-positioned">绝对定位</a>框的上外边距边缘相对于框的<a
      href="#containing-block">包含块</a>的上边缘向下的偏移量。对于相对定位的框，偏移是相对于框本身的上边缘（即，框在正常流中被赋予一个位置，然后根据这些属性从该位置偏移）。
  </p>

  <table class="def propdef">
    <tbody>
      <tr>
        <th>名称:</th>
        <td><a name="x30"><span class="index-def" title="'right'"><dfn id="propdef-right">right</dfn></span></a></td>
      </tr>
      <tr>
        <th>值:</th>
        <td><a href="syndata.html#value-def-length" class="noxref"><span
              class="value-inst-length">&lt;length&gt;</span></a> | <a href="syndata.html#value-def-percentage"
            class="noxref"><span class="value-inst-percentage">&lt;percentage&gt;</span></a> | auto | <a
            href="cascade.html#value-def-inherit" class="noxref"><span class="value-inst-inherit">inherit</span></a>
        </td>
      </tr>
      <tr>
        <th>初始值:</th>
        <td>auto</td>
      </tr>
      <tr>
        <th>适用于:</th>
        <td>定位元素</td>
      </tr>
      <tr>
        <th>是否继承:</th>
        <td>否</td>
      </tr>
      <tr>
        <th>百分比:</th>
        <td>参考包含块的宽度</td>
      </tr>
      <tr>
        <th>媒体:</th>
        <td><a href="media.html#visual-media-group" class="noxref">可视媒体</a></td>
      </tr>
      <tr>
        <th>计算值:</th>
        <td>如果指定为长度，则为相应的绝对长度；如果指定为百分比，则为指定值；否则为'auto'。</td>
      </tr>
    </tbody>
  </table>

  <p>与'top'类似，但指定框的右外边距边缘相对于框的<a href="#containing-block">包含块</a>的右边缘向左的偏移量。对于相对定位的框，偏移是相对于框本身的右边缘。
  </p>

  <table class="def propdef">
    <tbody>
      <tr>
        <th>名称:</th>
        <td><a name="x31"><span class="index-def" title="'bottom'"><dfn id="propdef-bottom">bottom</dfn></span></a></td>
      </tr>
      <tr>
        <th>值:</th>
        <td><a href="syndata.html#value-def-length" class="noxref"><span
              class="value-inst-length">&lt;length&gt;</span></a> | <a href="syndata.html#value-def-percentage"
            class="noxref"><span class="value-inst-percentage">&lt;percentage&gt;</span></a> | auto | <a
            href="cascade.html#value-def-inherit" class="noxref"><span class="value-inst-inherit">inherit</span></a>
        </td>
      </tr>
      <tr>
        <th>初始值:</th>
        <td>auto</td>
      </tr>
      <tr>
        <th>适用于:</th>
        <td>定位元素</td>
      </tr>
      <tr>
        <th>是否继承:</th>
        <td>否</td>
      </tr>
      <tr>
        <th>百分比:</th>
        <td>参考包含块的高度</td>
      </tr>
      <tr>
        <th>媒体:</th>
        <td><a href="media.html#visual-media-group" class="noxref">可视媒体</a></td>
      </tr>
      <tr>
        <th>计算值:</th>
        <td>如果指定为长度，则为相应的绝对长度；如果指定为百分比，则为指定值；否则为'auto'。</td>
      </tr>
    </tbody>
  </table>

  <p>与'top'类似，但指定框的下外边距边缘相对于框的<a href="#containing-block">包含块</a>的下边缘向上的偏移量。对于相对定位的框，偏移是相对于框本身的下边缘。
  </p>

  <table class="def propdef">
    <tbody>
      <tr>
        <th>名称:</th>
        <td><a name="x32"><span class="index-def" title="'left'"><dfn id="propdef-left">left</dfn></span></a></td>
      </tr>
      <tr>
        <th>值:</th>
        <td><a href="syndata.html#value-def-length" class="noxref"><span
              class="value-inst-length">&lt;length&gt;</span></a> | <a href="syndata.html#value-def-percentage"
            class="noxref"><span class="value-inst-percentage">&lt;percentage&gt;</span></a> | auto | <a
            href="cascade.html#value-def-inherit" class="noxref"><span class="value-inst-inherit">inherit</span></a>
        </td>
      </tr>
      <tr>
        <th>初始值:</th>
        <td>auto</td>
      </tr>
      <tr>
        <th>适用于:</th>
        <td>定位元素</td>
      </tr>
      <tr>
        <th>是否继承:</th>
        <td>否</td>
      </tr>
      <tr>
        <th>百分比:</th>
        <td>参考包含块的宽度</td>
      </tr>
      <tr>
        <th>媒体:</th>
        <td><a href="media.html#visual-media-group" class="noxref">可视媒体</a></td>
      </tr>
      <tr>
        <th>计算值:</th>
        <td>如果指定为长度，则为相应的绝对长度；如果指定为百分比，则为指定值；否则为'auto'。</td>
      </tr>
    </tbody>
  </table>

  <p>与'top'类似，但指定框的左外边距边缘相对于框的<a href="#containing-block">包含块</a>的左边缘向右的偏移量。对于相对定位的框，偏移是相对于框本身的左边缘。
  </p>

  <p>这四个属性的值具有以下含义：</p>

  <dl>
    <dt><strong><a href="syndata.html#value-def-length" class="noxref"><span
            class="value-inst-length">&lt;length&gt;</span></a></strong></dt>
    <dd>偏移是从参考边缘的固定距离。允许使用负值。
    </dd>
    <dt><strong><a href="syndata.html#value-def-percentage" class="noxref"><span
            class="value-inst-percentage">&lt;percentage&gt;</span></a></strong></dt>

    <dd>偏移是包含块的宽度（对于<a href="visuren.html#propdef-left" class="noxref"><span class="propinst-left">'left'</span></a>或<a
        href="visuren.html#propdef-right" class="noxref"><span class="propinst-right">'right'</span></a>）或高度（对于<a
        href="visuren.html#propdef-top" class="noxref"><span class="propinst-top">'top'</span></a>和<a
        href="visuren.html#propdef-bottom" class="noxref"><span class="propinst-bottom">'bottom'</span></a>）的百分比。允许使用负值。
    </dd>
    <dt><strong>auto</strong></dt>
    <dd>对于非替换元素，此值的效果取决于相关属性中哪些值也为'auto'。有关详细信息，请参见绝对定位、非替换元素的<a href="visudet.html#abs-non-replaced-width">宽度</a>和<a
        href="visudet.html#abs-non-replaced-height">高度</a>部分。对于替换元素，此值的效果仅取决于替换内容的固有尺寸。有关详细信息，请参见绝对定位、替换元素的<a
        href="visudet.html#abs-replaced-width">宽度</a>和<a href="visudet.html#abs-replaced-height">高度</a>部分。
    </dd>
  </dl>

  <h2>9.4 <a name="normal-flow">正常流</a></h2>

  <p>正常流中的框属于一个<a name="x33"><span class="index-def" title="formatting context">格式化上下文</span></a>，在 CSS&nbsp;2.2
    中，格式化上下文可以是表格、块或内联。在未来的 CSS 级别中，将引入其他类型的格式化上下文。<a href="#block-level">块级</a>框参与<a
      href="#block-formatting">块格式化</a>上下文。<a href="#inline-level">内联级框</a>参与<a
      href="#inline-formatting">内联格式化</a>上下文。表格格式化上下文在<a href="tables.html">表格章节</a>中描述。
  </p>

  <h3>9.4.1 <a name="block-formatting">块格式化上下文</a></h3>

  <p>浮动元素、绝对定位元素、非块框的块容器（如内联块、表格单元格和表格标题），以及'overflow'属性值不是'visible'的块框（除非该值已传播到视口）为其内容建立新的块格式化上下文。</p>

  <p>在块格式化上下文中，框从包含块的顶部开始，一个接一个地垂直布局。两个兄弟框之间的垂直距离由<a href="box.html#propdef-margin" class="noxref"><span
        class="propinst-margin">'margin'</span></a>属性决定。在块格式化上下文中，邻接块级框之间的垂直外边距会<a
      href="box.html#collapsing-margins">折叠</a>。
  </p>

  <p>
    在块格式化上下文中，每个框的左外边缘触碰包含块的左边缘（对于从右到左的格式化，右边缘触碰）。即使存在浮动元素也是如此（尽管框的<em>行框</em>可能因浮动元素而缩小），除非该框建立了新的块格式化上下文（在这种情况下，由于浮动元素，框本身<em>可能</em>变窄）。
  </p>

  <p>关于分页媒体中的分页符信息，请参阅<a href="page.html#allowed-page-breaks">允许的分页符</a>部分。
  </p>

  <h3>9.4.2 <a name="inline-formatting">内联格式化上下文</a></h3>

  <p>
    当一个块容器框中不包含块级框时，会建立内联格式化上下文。在内联格式化上下文中，框从包含块的顶部开始，水平一个接一个地布局。这些框之间会保留水平外边距、边框和内边距。框可以以不同方式垂直对齐：它们的底部或顶部可以对齐，或者它们内部文本的基线可以对齐。包含这些框并形成一行的矩形区域称为<a
      name="line-box"><dfn>行框</dfn></a>。
  </p>

  <p>行框的宽度由<a href="#containing-block">包含块</a>和浮动元素的存在决定。行框的高度由<a href="visudet.html#line-height">行高计算</a>部分中的规则决定。
  </p>

  <p>行框总是足够高以容纳其包含的所有框。然而，它可能比其包含的最高的框还要高（例如，如果框对齐的方式是基线对齐）。当框 B 的高度小于包含它的行框的高度时，B 在行框内的垂直对齐方式由<a
      href="visudet.html#propdef-vertical-align" class="noxref"><span
        class="propinst-vertical-align">'vertical-align'</span></a>属性决定。当多个内联级框无法水平地容纳在一个行框内时，它们会分布在两个或多个垂直堆叠的行框中。因此，段落是行框的垂直堆叠。行框是无垂直间距地堆叠的（除非另有规定），并且它们永不重叠。
  </p>

  <p>通常，行框的左边缘触碰其包含块的左边缘，右边缘触碰其包含块的右边缘。然而，浮动框可能位于包含块边缘和行框边缘之间。因此，尽管同一内联格式化上下文中的行框通常具有相同的宽度（即包含块的宽度），但如果由于<a
      href="#floats">浮动元素</a>导致可用水平空间减少，它们的宽度可能会有所不同。同一内联格式化上下文中的行框通常在高度上有所不同（例如，一行可能包含一个高的图像，而其他行仅包含文本）。
  </p>

  <p>当一行中的内联级框的总宽度小于包含它们的行框的宽度时，它们在行框内的水平分布由<a href="text.html#propdef-text-align" class="noxref"><span
        class="propinst-text-align">'text-align'</span></a>属性决定。如果该属性的值为 'justify'，用户代理可能会拉伸内联框中的空格和单词（但不包括内联表格和内联块框）。
  </p>

  <p>
    当一个内联框超出行框的宽度时，它会被拆分成多个框，并将这些框分布在多个行框中。如果内联框无法拆分（例如，如果内联框包含单个字符，或者语言特定的断词规则不允许在内联框内断开，或者内联框受 nowrap 或 pre
    的白空间值影响），则内联框会溢出行框。
  </p>

  <p>
    当一个内联框被拆分时，拆分处（或有多个拆分时的任意拆分处）不会对边距、边框和内边距产生视觉效果。
  </p>

  <p>由于<a href="#direction">双向文本处理</a>，内联框也可能在<em>同一行框内</em>被拆分成多个框。
  </p>

  <p id="phantom-line-box">行框是在内联格式化上下文中根据需要创建的，用于容纳内联级内容。对于那些不包含文本、不包含<a
      href="text.html#white-space-prop">保留的空白</a>、不包含具有非零边距、内边距或边框的内联元素以及不包含其他<a
      href="#positioning-scheme">在流中</a>内容（如图像、内联块或内联表格），并且不以保留换行符结束的行框，应被视为零高度行框来确定其中任何元素的位置，并且在其他目的上应视为不存在。
  </p>

  <div class="html example">
    <p>以下是内联框构造的一个示例。以下段落（由 HTML 块级元素 P 创建）包含与 EM 和 STRONG 元素交错的匿名文本：</p>
    <pre><code class="html">
&lt;P&gt;Several &lt;EM&gt;emphasized words&lt;/EM&gt; appear
&lt;STRONG&gt;in this&lt;/STRONG&gt; sentence, dear.&lt;/P&gt;
</code></pre>

    <p>P 元素生成一个包含五个内联框的块框，其中三个是匿名的：</p>

    <ul>
      <li>匿名: "Several"</li>
      <li>EM: "emphasized words"</li>
      <li>匿名: "appear"</li>
      <li>STRONG: "in this"</li>
      <li>匿名: "sentence, dear."</li>
    </ul>

    <p>为了格式化段落，用户代理将这五个框流入行框。在此示例中，为 P 元素生成的框为行框建立了包含块。如果包含块足够宽，所有内联框将适合一个行框：</p>
    <pre>
 Several <em>emphasized words</em> appear <strong>in this</strong> sentence, dear.
</pre>

    <p>如果不够宽，内联框将被拆分并分布在多个行框中。前面的段落可能会如下拆分：</p>
    <pre>
Several <em>emphasized words</em> appear
<strong>in this</strong> sentence, dear.
</pre>

    或如下拆分：

    <pre>
Several <em>emphasized</em>  
<em>words</em> appear <strong>in this</strong> 
sentence, dear.
</pre>

  </div>

  <p>在前面的示例中，EM 框被拆分成两个 EM 框（称它们为 "split1" 和 "split2"）。在 split1 之后或 split2 之前，边距、边框、内边距或文本装饰没有可见的效果。
  </p>

  <div class="html example">
    <p>请考虑以下示例：</p>
    <pre><code class="html">
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
  &lt;HEAD&gt;
    &lt;TITLE&gt;多行内联流示例&lt;/TITLE&gt;
    &lt;STYLE type="text/css"&gt;
      EM {
        padding: 2px; 
        margin: 1em;
        border-width: medium;
        border-style: dashed;
        line-height: 2.4em;
      }
    &lt;/STYLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;P&gt;Several &lt;EM&gt;emphasized words&lt;/EM&gt; appear here.&lt;/P&gt;
  &lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>

    <p>根据 P 的宽度，框可能如下分布：</p>

    <div class="figure">
      <p><img src="https://www.w3.org/TR/CSS22/images/inline-layout.png" alt="展示行拆分对边距、边框和内边距显示效果的图像"><SPAN
          class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-inline-layout" href="images/longdesc/inline-layout-desc.html"
            title="内联框拆分对边距/边框行为影响的长描述">[D]</A></SPAN></p>
    </div>

    <ul>
      <li>边距插入在 "emphasized" 之前和 "words" 之后。</li>
      <li>内边距插入在 "emphasized" 之前、上方和下方，以及 "words" 之后、上方和下方。在每种情况下都会在三个边上绘制虚线边框。</li>
    </ul>
  </div>

  <h3>9.4.3 <a name="relative-positioning">相对定位</a></h3>

  <p>当一个框已经按照<a href="#normal-flow">正常流</a>或浮动布局后，它可以相对于该位置进行偏移。这称为<a name="x35"><span class="index-def"
        title="relative positioning"><dfn>相对定位</dfn></span></a>。以这种方式偏移一个框（B1）不会影响后面的框（B2）：B2 会被赋予一个位置，就像 B1
    没有偏移一样，并且在应用 B1 的偏移后，B2 不会重新定位。这意味着相对定位可能导致框重叠。然而，如果相对定位导致 'overflow:auto' 或 'overflow:scroll'
    的框发生溢出，用户代理必须允许用户访问该内容（在其偏移位置），这可能会通过创建滚动条影响布局。
  </p>

  <p>相对定位的框保留其正常流大小，包括换行和最初为其保留的空间。<a href="#containing-block">包含块</a>部分解释了何时相对定位的框建立一个新的包含块。
  </p>

  <p>对于相对定位的元素，'left' 和 'right' 水平移动框，但不改变它们的大小。'left' 将框向右移动，'right' 将框向左移动。由于框不会因 'left' 或 'right'
    而被拆分或拉伸，因此使用的值始终为：left = -right。
  </p>

  <p>如果 'left' 和 'right' 都是 'auto'（它们的初始值），则使用的值为 '0'（即，框保持在其原始位置）。
  </p>

  <p>如果 'left' 为 'auto'，则使用的值为 'right' 的负值（即，框向左移动 'right' 的值）。
  </p>

  <p>如果 'right' 指定为 'auto'，则使用的值为 'left' 的负值。
  </p>

  <p>如果 'left' 和 'right' 都不是 'auto'，则位置过度约束，必须忽略其中一个。如果包含块的 'direction' 属性为 'ltr'，则 'left' 的值优先，'right' 变为
    -'left'。如果包含块的 'direction' 为 'rtl'，则 'right' 优先，'left' 被忽略。
  </p>

  <div class="example">
    <P style="display:none">示例：</P>
    <p><strong>示例。</strong> 以下三个规则是等效的：</p>
    <pre><code class="css">
div.a8 { position: relative; direction: ltr; left: -1em; right: auto }
div.a8 { position: relative; direction: ltr; left: auto; right: 1em }
div.a8 { position: relative; direction: ltr; left: -1em; right: 5em }
</code></pre>
  </div>

  <p>'top' 和 'bottom' 属性上下移动相对定位的元素，而不改变它们的大小。'top' 将框向下移动，'bottom' 将框向上移动。由于框不会因 'top' 或 'bottom' 而被拆分或拉伸，因此使用的值始终为：top
    = -bottom。如果两者都是 'auto'，则使用的值都是 '0'。如果其中一个为 'auto'，它将变为另一个的负值。如果两者都不是 'auto'，则 'bottom' 被忽略（即，'bottom' 的使用值将是 'top'
    的负值）。
  </p>

  <p class="note">
    注意。相对定位框的动态移动可以在脚本环境中产生动画效果（另请参见<a href="visufx.html#propdef-visibility" class="noxref"><span
        class="propinst-visibility">'visibility'</span></a>属性）。虽然相对定位可以用作上标和下标的一种形式，但行高不会自动调整以考虑定位。有关更多信息，请参阅<a
      href="visudet.html#line-height">行高计算</a>的描述。
  </p>

  <p>相对定位的示例在<a href="#comparison">比较正常流、浮动和绝对定位</a>部分中提供。
  </p>
  <h2>9.5 <a name="floats">浮动</a></h2>

  <p>浮动框是一个在当前行上向左或向右移动的框。浮动（或“浮动的”或“浮动”框）的最有趣特征是内容可能沿其侧边流动（或被<a href="visuren.html#propdef-clear" class="noxref"><span
        class="propinst-clear">'clear'</span></a>属性禁止流动）。内容沿左浮动框的右侧流动，沿右浮动框的左侧流动。以下是浮动定位和内容流动的介绍；控制浮动行为的确切<a
      href="#float-rules">规则</a>在<a href="visuren.html#propdef-float" class="noxref"><span
        class="propinst-float">'float'</span></a>属性的描述中给出。</p>

  <p>浮动框向左或向右移动，直到其外边缘接触到包含块边缘或另一个浮动框的外边缘。如果有行框，浮动框的外上边缘与当前行框的顶部对齐。</p>

  <p>如果没有足够的水平空间容纳浮动框，它会向下移动，直到适合为止或不再有浮动框存在。</p>

  <p>由于浮动框不在流中，在浮动框之前和之后创建的非定位块框会垂直流动，仿佛浮动框不存在。然而，在浮动框旁边创建的当前和后续行框会根据需要缩短以为浮动框的边距框腾出空间。</p>

  <p>当存在以下四个条件时，行框位于浮动框旁边：（a）在行框的顶部或以下，（b）在行框的底部或以上，（c）在浮动框的上边距边缘以下，以及（d）在浮动框的下边距边缘以上。</p>

  <p class="note">注意：这意味着外部高度为零或负高度的浮动框不会缩短行框。</p>

  <p>
    如果缩短的行框太小而无法容纳任何内容，则行框会向下移动（并重新计算其宽度），直到某些内容适合或不再有浮动框存在。浮动框之前的当前行中的任何内容都会在同一行的浮动框另一侧重新排版。换句话说，如果在遇到适合剩余行框空间的左浮动框之前将内联级框放置在行上，则左浮动框将被放置在该行上，与行框的顶部对齐，然后该行上的内联级框会相应地移动到浮动框的右侧（右侧是左浮动框的另一侧），对于从右到左的文本和右浮动框则相反。
  </p>

  <p id="bfc-next-to-float">表格的边框框、块级替换元素或正常流中建立新<a href="visuren.html#block-formatting">块格式化上下文</a>的元素（例如 'overflow'
    值不是 'visible'
    的元素）不得与同一块格式化上下文中任何浮动框的边距框重叠。如果有必要，实施应该通过将该元素放置在任何前面的浮动框下方来清除该元素，但如果有足够的空间，也可以将其放置在这些浮动框旁边。它们甚至可以使该元素的边框框比<a
      href="visudet.html#blockwidth">第&nbsp;10.3.3 节</a>中定义的更窄。CSS2 未定义用户代理何时可以将该元素放在浮动框旁边，或该元素可能变得多窄。</p>

  <div class="example">
    <P style="display:none">示例：</P>
    <p><strong>示例。</strong>在以下文档片段中，包含块太窄，无法在浮动框旁边容纳内容，因此内容会被移动到浮动框下方，在行框中根据 text-align 属性对齐。</p>
    <pre><code class="css">
p { width: 10em; border: solid aqua; }
span { float: left; width: 5em; height: 5em; border: solid blue; }
</code>

...

<code class="html">
&lt;p&gt;
  &lt;span&gt; &lt;/span&gt;
  Supercalifragilisticexpialidocious
&lt;/p&gt;
</code></pre>
    <p>这个片段可能如下所示：</p>
    <div class="figure">
      <p><img style="display:block" src="https://www.w3.org/TR/CSS22/images/supercal.png"
          alt="显示一个无法在浮动框旁边容纳的不可拆分内容片段被重新排版到浮动框之后的图像。"></p>
    </div>
  </div>

  <p>多个浮动框可能相邻，这种模型也适用于同一行中的相邻浮动框。</p>

  <div class="example">
    <P style="display:none">示例：</P>
    <p>以下规则将所有带有 <samp>class="icon"</samp> 的 IMG 框浮动到左侧（并将左边距设为 '0'）：</p>
    <pre><code class="css">
img.icon { 
  float: left;
  margin-left: 0;
}
</code></pre>
  </div>

  <div class="html example">
    <p>请考虑以下 HTML 源代码和样式表：</p>

    <pre><code class="html">  
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
  &lt;HEAD&gt;
    &lt;TITLE&gt;浮动示例&lt;/TITLE&gt;
    &lt;STYLE type="text/css"&gt;
      IMG { float: left }
      BODY, P, IMG { margin: 2em }
    &lt;/STYLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;P&gt;&lt;IMG src=img.png alt="这个图像将说明浮动"&gt;
       一些没有其他...的示例文本
  &lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>

    <p>IMG 框被浮动到左侧。后续内容在浮动框右侧进行格式化，从与浮动框同一行开始。由于浮动框的存在，浮动框右侧的行框被缩短，但在浮动框之后恢复其“正常”宽度（即由 P 元素建立的包含块的宽度）。该文档可能被格式化为：</p>

    <div class="figure">
      <p><img src="https://www.w3.org/TR/CSS22/images/floateg.png" alt="展示浮动框如何与边距交互的图像。"><SPAN
          class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-floateg"
            href="https://www.w3.org/TR/CSS22/images/longdesc/floateg-desc.html" title="浮动和文本流示例的长描述">[D]</A></SPAN></p>
    </div>

    <p>如果文档是这样的，格式化将完全相同：</p>
    <pre><code class="html">
&lt;BODY&gt;
  &lt;P&gt;一些示例文本 
  &lt;IMG src=img.png alt="这个图像将说明浮动"&gt;
           没有其他...
&lt;/BODY&gt;
</code></pre>

    <p>因为浮动框左侧的内容被浮动框挤开，并在其右侧重新排版。</p>
  </div>

  <p>如<a href="box.html#collapsing-margins">第 8.3.1 节</a>所述，浮动框的边距永远不会与相邻框的边距<a
      href="box.html#collapsing-margins">折叠</a>。因此，在前面的示例中，P 框和浮动的 IMG 框之间的垂直边距不会<a
      href="box.html#collapsing-margins">折叠</a>。</p>

  <p>
    浮动框的内容堆叠，就像浮动框生成了新的堆叠上下文一样，除了任何定位元素和实际创建新堆叠上下文的元素参与浮动框父级的堆叠上下文。浮动框可以与正常流中的其他框重叠（例如，当正常流框旁边的浮动框具有负边距时）。当这种情况发生时，浮动框位于非定位的流内块前面，但在流内内联框的后面。
  </p>

  <div class="example">
    <P style="display:none">示例：</P>
    <p>这里有另一个例子，展示了当浮动框与正常流中的元素边框重叠时会发生什么。</p>
    <div class="figure">
      <p><img src="https://www.w3.org/TR/CSS22/images/float2p.png" alt="展示浮动图像如何重叠两个段落的边框：边框被图像遮挡。"><SPAN
          class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-float2p" href="images/longdesc/float2p-desc.html"
            title="浮动框如何与正常流中的框重叠的长描述">[D]</A></SPAN></p>
      <p class="caption">浮动图像遮挡了其重叠的块框的边框。</p>
    </div>
  </div>

  <p>以下示例说明了使用<a href="visuren.html#propdef-clear" class="noxref"><span
        class="propinst-clear">'clear'</span></a>属性来防止内容在浮动框旁边流动。</p>

  <div class="example">
    <P style="display:none">示例：</P>
    <p>假设有如下规则：</p>
    <pre><code class="css">
p { clear: left }
</code></pre>

    <p>格式化可能如下所示：</p>
    <div class="figure">
      <p><img src="https://www.w3.org/TR/CSS22/images/floatclear.png" alt="显示浮动图像和 'clear: left' 对两个段落的影响的图像。"><SPAN
          class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-floatclear" href="images/longdesc/floatclear-desc.html"
            title="浮动框如何与正常流中的框重叠的长描述">[D]</A></SPAN></p>
      <p class="caption">两个段落都设置了 'clear: left'，这使得第二个段落被“推到”浮动框下方——在其上边距之上添加了“清除”以实现这一点（参见<a
          href="visuren.html#propdef-clear" class="noxref"><span class="propinst-clear">'clear'</span></a>属性）。</p>
    </div>
  </div>


  <h3>9.5.1 <a name="float-position">浮动的定位：</a><a href="visuren.html#propdef-float" class="noxref"><span
        class="propinst-float">'float'</span></a>属性</h3>

  <table class="def propdef">
    <tbody>
      <tr>
        <th>名称:</th>
        <td><a name="x36"><span class="index-def" title="'float'"><dfn id="propdef-float">float</dfn></span></a></td>
      </tr>
      <tr>
        <th>值:</th>
        <td>left | right | none | <a href="cascade.html#value-def-inherit" class="noxref"><span
              class="value-inst-inherit">inherit</span></a></td>
      </tr>
      <tr>
        <th>初始值:</th>
        <td>none</td>
      </tr>
      <tr>
        <th>适用于:</th>
        <td>所有元素，但请参见<a href="visuren.html#dis-pos-flo">9.7</a></td>
      </tr>
      <tr>
        <th>是否继承:</th>
        <td>否</td>
      </tr>
      <tr>
        <th>百分比:</th>
        <td>不适用</td>
      </tr>
      <tr>
        <th>媒体:</th>
        <td><a href="media.html#visual-media-group" class="noxref">可视媒体</a></td>
      </tr>
      <tr>
        <th>计算值:</th>
        <td>如指定的值</td>
      </tr>
    </tbody>
  </table>

  <p>该属性指定一个框是否应向左浮动、向右浮动或不浮动。它可以应用于任何元素，但仅适用于生成非<a href="#absolutely-positioned">绝对定位</a>框的元素。该属性的值具有以下含义：</p>

  <dl>
    <dt><strong>left</strong></dt>
    <dd>元素生成一个<a href="#block-boxes">块</a>框，向左浮动。内容沿框的右侧流动，从顶部开始（受<a href="visuren.html#propdef-clear"
        class="noxref"><span class="propinst-clear">'clear'</span></a>属性影响）。</dd>

    <dt><strong>right</strong></dt>
    <dd>类似于 'left'，但框向右浮动，内容沿框的左侧流动，从顶部开始。</dd>

    <dt><strong>none</strong></dt>
    <dd>框不浮动。</dd>
  </dl>

  <p>用户代理可以将根元素的浮动视为 'none'。</p>

  <p><a name="float-rules"><span class="index-def" title="float rules">以下是控制浮动行为的精确规则：</span></a></p>

  <ol>
    <li>左浮动框的左<a href="box.html#outer-edge">外边缘</a>不得位于其<a href="#containing-block">包含块</a>的左边缘的左侧。对于右浮动元素，规则类似。</li>
    <li>如果当前框是左浮动的，并且在源文档中较早生成的元素有任何左浮动框，那么对于每个这样的较早框，要么当前框的左<a href="box.html#outer-edge">外边缘</a>必须位于较早框的右<a
        href="box.html#outer-edge">外边缘</a>的右侧，要么其顶部必须低于较早框的底部。对于右浮动框，规则类似。</li>
    <li>左浮动框的右<a href="box.html#outer-edge">外边缘</a>不得位于其旁边的任何右浮动框的左<a
        href="box.html#outer-edge">外边缘</a>的右侧。对于右浮动元素，规则类似。</li>
    <li>浮动框的<a href="box.html#outer-edge">外顶部</a>不得高于其<a
        href="#containing-block">包含块</a>的顶部。当浮动框出现在两个折叠的边距之间时，浮动框的位置应当如同它具有一个其他空的<a
        href="#anonymous-block-level">匿名块父元素</a>参与流动一样。该父元素的位置由<a href="box.html#collapsed-through">边距折叠</a>部分的规则定义。
    </li>
    <li>浮动框的<a href="box.html#outer-edge">外顶部</a>不得高于源文档中较早生成的任何<a href="#block-boxes">块</a>或<a
        href="#floats">浮动</a>框的外顶部。</li>
    <li>元素的浮动框的<a href="box.html#outer-edge">外顶部</a>不得高于包含源文档中较早生成的框的任何<a name="x38" href="#line-box"><span
          class="index-inst" title="line-box">行框</span></a>的顶部。</li>
    <li>一个左浮动框如果左侧有另一个左浮动框，则其右外边缘不得超出其包含块的右边缘。（大致来说：左浮动框不得超出右边缘，除非它已经尽可能向左对齐。）对于右浮动元素，规则类似。</li>
    <li>浮动框必须放置在尽可能高的位置。</li>
    <li>左浮动框必须尽可能向左放置，右浮动框尽可能向右放置。较高的位置比更靠左/右的位置更优先。</li>
  </ol>

  <p>但在 CSS&nbsp;2.2 中，如果在块格式化上下文中存在流内负垂直边距，使得浮动框的位置高于所有此类负边距被设置为零时的位置，则浮动框的位置未定义。</p>

  <p>这些规则中对其他元素的引用仅指与浮动框在同一<a href="#block-formatting">块格式化上下文</a>中的其他元素。</p>

  <div class="example">
    <P style="display:none">示例：</P>
    <p>以下 HTML 片段会使 b 向右浮动。</p>
    <pre>&lt;P&gt;a&lt;SPAN style="float: right"&gt;b&lt;/SPAN&gt;&lt;/P&gt;</pre>
    <p>如果 P 元素的宽度足够，a 和 b 将并排显示。它可能如下所示：</p>
    <div class="figure">
      <p><img src="https://www.w3.org/TR/CSS22/images/float-right.png" alt="一个框的左侧显示 a，右侧显示 b 的图像"></p>
    </div>
  </div>


  <h3>9.5.2 <a name="flow-control">控制浮动旁边的流动：</a> <a href="visuren.html#propdef-clear" class="noxref"><span
        class="propinst-clear">'clear'</span></a>属性</h3>

  <table class="def propdef">
    <tbody>
      <tr>
        <th>名称:</th>
        <td><a name="x39"><span class="index-def" title="'clear'"><dfn id="propdef-clear">clear</dfn></span></a></td>
      </tr>
      <tr>
        <th>值:</th>
        <td>none | left | right | both | <a href="cascade.html#value-def-inherit" class="noxref"><span
              class="value-inst-inherit">inherit</span></a></td>
      </tr>
      <tr>
        <th>初始值:</th>
        <td>none</td>
      </tr>
      <tr>
        <th>适用于:</th>
        <td>块级元素</td>
      </tr>
      <tr>
        <th>是否继承:</th>
        <td>否</td>
      </tr>
      <tr>
        <th>百分比:</th>
        <td>不适用</td>
      </tr>
      <tr>
        <th>媒体:</th>
        <td><a href="media.html#visual-media-group" class="noxref">可视媒体</a></td>
      </tr>
      <tr>
        <th>计算值:</th>
        <td>如指定的值</td>
      </tr>
    </tbody>
  </table>

  <p>该属性指示元素框的哪一侧<em>不得</em>与之前的浮动框相邻。'clear' 属性不考虑元素内部或其他<a href="visuren.html#block-formatting">块格式化上下文</a>中的浮动。</p>

  <p>当应用于非浮动的块级框时，值具有以下含义：</p>

  <dl>
    <dt><strong>left</strong></dt>
    <dd>要求框的顶部边框边缘位于源文档中较早生成的任何左浮动框的底部外边缘下方。</dd>

    <dt><strong>right</strong></dt>
    <dd>要求框的顶部边框边缘位于源文档中较早生成的任何右浮动框的底部外边缘下方。</dd>

    <dt><strong>both</strong></dt>
    <dd>要求框的顶部边框边缘位于源文档中较早生成的任何左浮动和右浮动框的底部外边缘下方。</dd>

    <dt><strong>none</strong></dt>
    <dd>框的位置不受浮动的约束。</dd>
  </dl>

  <p>除了 'none' 之外的值可能引入<dfn><span class="index-def"><a
          name="clearance">清除间距</a></span></dfn>。清除间距抑制边距折叠，并作为元素的上边距之上的间距。它用于将元素垂直推过浮动。</p>

  <p>计算设置了 'clear' 属性的元素的清除间距，首先需要确定元素顶部边框边缘的假设位置。这个位置是如果元素的 'clear' 属性设置为 'none'，元素实际的顶部边框边缘会处于的位置。</p>

  <p>如果元素顶部边框边缘的假设位置没有超过相关的浮动框，则引入清除间距，并按照 8.3.1 节的规则折叠边距。</p>

  <p>然后，清除间距的值设置为以下两者中的较大值：</p>

  <ol>
    <li>将块的边框边缘放置在要清除的最低浮动框的底部外边缘处所需的清除间距。</li>
    <li>将块的顶部边框边缘放置在其假设位置所需的清除间距。</li>
  </ol>

  <p>或者，清除间距可以设置为正好足以将块的边框边缘放置在要清除的最低浮动框的底部外边缘处的值。</p>

  <p class="note"><em><strong>注意：</strong>允许以上两种行为，取决于它们与现有 Web 内容的兼容性评估。未来的 CSS 规范将要求其中之一。</em></p>

  <p class="note">注意：清除间距可以是负值或零。</p>

  <div class="example">
    <P style="display:none">示例：</P>
    <p>示例 1. 假设（为简单起见），我们有三个框，按顺序为：块 B1，底部边距为 M1（B1 没有子元素、没有填充或边框），浮动块 F， 高度为 H，块 B2，顶部边距为 M2（没有填充或边框、没有子元素）。B2 的
      'clear' 设置为 'both'。我们还假设 B2 不是空的。</p>
    <p>在不考虑 B2 的 'clear' 属性的情况下，我们有如下图所示的情况。B1 和 B2 的边距折叠。假设 B1 的底部边框边缘位于 y = 0 处，则 F 的顶部位于 y = M1 处，B2 的顶部边框边缘位于 y =
      max(M1,M2) 处，F 的底部位于 y = M1 + H 处。</p>

    <div class="figure">
      <p><img src="https://www.w3.org/TR/CSS22/images/clearance.png" alt="浮动框 F 延伸到 M2 上方的边距。"></p>
    </div>

    <p>我们还假设 B2 不在 F 下方，即我们处于规范中描述的需要添加清除间距的情况。这意味着：</p>

    <blockquote>
      <p>max(M1,M2) &lt; M1 + H</p>
    </blockquote>

    <p>我们需要计算两次清除间距 C1 和 C2，并保留较大的值：C = max(C1,C2)。第一种方法是将 B2 的顶部与 F 的底部对齐，即位于 y = M1 + H。这意味着，由于在它们之间的清除间距导致边距不再折叠：</p>

    <blockquote class="math">
      <p> <span>F 的底部</span> <span>= B2 的顶部边框边缘</span> <span>&#8660;</span></p>
      <p> <span>M1 + H</span> <span>= M1 + C1 + M2</span> <span>&#8660;</span></p>
      <p> <span>C1</span> <span>= M1 + H - M1 - M2</span></p>
      <p> <span></span> <span>= H - M2</span></p>
    </blockquote>

    <p>第二种计算方法是将 B2 的顶部保持在原位，即位于 y = max(M1,M2) 处。这意味着：</p>

    <blockquote class="math">
      <p> <span>max(M1,M2)</span> <span>= M1 + C2 + M2</span> <span>&#8660;</span></p>
      <p> <span>C2</span> <span>= max(M1,M2) - M1 - M2</span></p>
    </blockquote>

    <p>我们假设 max(M1,M2) &lt; M1 + H，这意味着</p>

    <blockquote class="math">
      <p> <span>C2 = max(M1,M2) - M1 - M2</span> <span>&lt; M1 + H - M1 - M2 = H - M2</span> <span>&#8658;</span></p>
      <p> <span>C2</span> <span>&lt; H - M2</span></p>
    </blockquote>

    <p>并且，由于 C1 = H - M2，因此得出</p>

    <blockquote class="math">
      <p> <span>C2 &lt; C1</span></p>
    </blockquote>

    <p>因此</p>

    <blockquote class="math">
      <p> <span>C = max(C1,C2) = C1</span></p>
    </blockquote>
  </div>

  <div class="example">
    <P style="display:none">示例：</P>
    <p>示例 2. 负清除间距的示例是这种情况，其中清除间距为 -1em。（假设所有元素都没有边框或填充）：</p>
    <pre class="html">
&lt;p style="<b>margin-bottom: 4em</b>">
  第一段。

&lt;p style="<b>float: left; height: 2em; margin: 0</b>">
  浮动段落。

&lt;p style="<b>clear: left; margin-top: 3em</b>">
  最后一段。
</pre>

    <p>解释：如果没有 'clear'，第一段和最后一段的边距会折叠，并且最后一段的顶部边框边缘会与浮动段落的顶部对齐。但 'clear' 要求顶部边框边缘在浮动框下方，即低
      2em。这意味着必须引入清除间距。因此，边距不再折叠，并且清除间距的值设置为清除间距 + 上边距 = 2em，即清除间距 = 2em - 上边距 = 2em - 3em = -1em。</p>
  </div>

  <p>当该属性设置在浮动元素上时，会导致<a href="#float-rules">浮动定位规则</a>的修改。增加了一个额外的约束（#10）：</p>

  <ul>
    <li>浮动框的顶部<a href="box.html#outer-edge">外边缘</a>必须位于所有较早左浮动框（对于 'clear: left'）或所有较早右浮动框（对于 'clear: right'）或两者（'clear:
      both'）的底部外边缘下方。</li>
  </ul>

  <div class="note">
    <p><em><strong>注意。</strong>在 CSS1 中<a
          href="https://www.w3.org/TR/REC-CSS1/#clear">该属性适用于所有元素</a>。因此，实现可能支持此属性在所有元素上应用。在 CSS2 和 CSS&nbsp;2.2
        中，'clear' 属性仅适用于块级元素。因此，作者应该仅在块级元素上使用此属性。如果实现确实支持在内联元素上使用清除，而不是如上所述设置清除间距，实现应强制换行，并有效地插入一个或多个空行框（或如<a
          href="#floats">9.5 节</a>中所述将新行框向下移动），将清除的内联元素的行框顶部移到相应浮动框的下方。</em></p>
  </div>

  <h2>9.6 <a name="absolute-positioning">绝对定位</a></h2>

  <p>
    在绝对定位模型中，一个框相对于其包含块明确地偏移。它完全从正常流中移除（对后续的兄弟元素没有影响）。一个绝对定位的框为正常流的子元素和绝对（但不是固定）定位的后代建立了一个新的包含块。然而，绝对定位元素的内容不会围绕任何其他框流动。根据重叠框的<a
      href="#stack-level">堆叠层级</a>，它们可能遮挡其他框的内容（或被其他框遮挡）。</p>

  <p>本规范中对<a name="absolutely-positioned"><span class="index-def"
        title="absolutely positioned element"><dfn>绝对定位元素</dfn></span></a>（或其框）的引用意味着该元素的<a
      href="visuren.html#propdef-position" class="noxref"><span class="propinst-position">'position'</span></a>属性的值为
    'absolute' 或 'fixed'。</p>

  <h3>9.6.1 <a name="fixed-positioning">固定定位</a></h3>

  <p>固定定位是绝对定位的一个子类别。唯一的区别是，对于固定定位的框，包含块由<a href="#viewport">视口</a>建立。对于<a
      href="media.html#continuous-media-group">连续媒体</a>，当文档滚动时，固定框不会移动。在这一点上，它们类似于<a
      href="colors.html#background-properties">固定背景图像</a>。对于<a
      href="page.html">分页媒体</a>，具有固定位置的框在每一页上都会重复。这对于在每页底部放置签名等内容很有用。大于页面区域的固定位置框将被裁剪。初始包含块中不可见的固定位置框的部分将不会打印。</p>

  <div class="html example">
    <p>作者可以使用固定定位来创建类似框架的展示。考虑以下框架布局：</p>

    <div class="figure">
      <p><img src="https://www.w3.org/TR/CSS22/images/frame.png" alt="展示 position='fixed' 的类似框架布局的图像"><SPAN
          class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-frame" href="images/longdesc/frame-desc.html"
            title="框架布局示例的长描述">[D]</A></SPAN></p>
    </div>

    <p>这可能通过以下 HTML 文档和样式规则实现：</p>

    <pre><code class="html">
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
  &lt;HEAD&gt;
    &lt;TITLE&gt;A frame document with CSS&lt;/TITLE&gt;
    &lt;STYLE type="text/css" media="screen"&gt;
      BODY { height: 8.5in } /* Required for percentage heights below */
      #header {
        position: fixed;
        width: 100%;
        height: 15%;
        top: 0;
        right: 0;
        bottom: auto;
        left: 0;
      }
      #sidebar {
        position: fixed;
        width: 10em;
        height: auto;
        top: 15%;
        right: auto;
        bottom: 100px;
        left: 0;
      }
      #main {
        position: fixed;
        width: auto;
        height: auto;
        top: 15%;
        right: 0;
        bottom: 100px;
        left: 10em;
      }
      #footer {
        position: fixed;
        width: 100%;
        height: 100px;
        top: auto;
        right: 0;
        bottom: 0;
        left: 0;
      }
    &lt;/STYLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;DIV id="header"&gt; ...  &lt;/DIV&gt;
    &lt;DIV id="sidebar"&gt; ...  &lt;/DIV&gt;
    &lt;DIV id="main"&gt; ...  &lt;/DIV&gt;
    &lt;DIV id="footer"&gt; ...  &lt;/DIV&gt;
  &lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>
  </div>

  <h2>9.7 <a name="dis-pos-flo">‘display’、‘position’和‘float’之间的关系</a></h2>

  <p>影响框生成和布局的三个属性 &mdash; <a href="visuren.html#propdef-display" class="noxref"><span
        class="propinst-display">‘display’</span></a>、<a href="visuren.html#propdef-position" class="noxref"><span
        class="propinst-position">‘position’</span></a> 和 <a href="visuren.html#propdef-float" class="noxref"><span
        class="propinst-float">‘float’</span></a> &mdash; 相互作用如下：</p>

  <ol>
    <li>如果 <a href="visuren.html#propdef-display" class="noxref"><span class="propinst-display">‘display’</span></a> 的值为
      ‘none’，则 <a href="visuren.html#propdef-position" class="noxref"><span
          class="propinst-position">‘position’</span></a> 和 <a href="visuren.html#propdef-float" class="noxref"><span
          class="propinst-float">‘float’</span></a> 不适用。在这种情况下，元素不生成任何框。</li>

    <li>否则，如果 <a href="visuren.html#propdef-position" class="noxref"><span
          class="propinst-position">‘position’</span></a> 的值为 ‘absolute’ 或 ‘fixed’，则框为绝对定位，<a
        href="visuren.html#propdef-float" class="noxref"><span class="propinst-float">‘float’</span></a> 的计算值为 ‘none’，并且
      ‘display’ 根据下表设置。框的位置将由 <a href="visuren.html#propdef-top" class="noxref"><span
          class="propinst-top">‘top’</span></a>、<a href="visuren.html#propdef-right" class="noxref"><span
          class="propinst-right">‘right’</span></a>、<a href="visuren.html#propdef-bottom" class="noxref"><span
          class="propinst-bottom">‘bottom’</span></a> 和 <a href="visuren.html#propdef-left" class="noxref"><span
          class="propinst-left">‘left’</span></a> 属性及框的包含块决定。</li>

    <li>否则，如果 ‘float’ 的值不是 ‘none’，则框浮动，并且 ‘display’ 根据下表设置。</li>

    <li>否则，如果元素是根元素，‘display’ 根据下表设置，除了在 CSS&nbsp;2.2 中，指定的 ‘list-item’ 值是成为 ‘block’ 还是 ‘list-item’ 的计算值未定义。</li>

    <li>否则，其余的 <a href="visuren.html#propdef-display" class="noxref"><span class="propinst-display">‘display’</span></a>
      属性值按指定应用。</li>
  </ol>

  <table border="1">
    <tr>
      <th>指定值</th>
      <th style="width:30%">计算值</th>
    </tr>
    <tr>
      <td>inline-table</td>
      <td>table</td>
    </tr>
    <tr>
      <td>inline, table-row-group, table-column, table-column-group, table-header-group, table-footer-group, table-row,
        table-cell, table-caption, inline-block</td>
      <td>block</td>
    </tr>
    <tr>
      <td>其他</td>
      <td>与指定值相同</td>
    </tr>
  </table>

  <h2>9.8 <a name="comparison">普通流、浮动和绝对定位的比较</a></h2>
  <p>为了说明普通流、相对定位、浮动和绝对定位之间的差异，我们提供了一系列基于以下 HTML 的示例：</p>
  <pre class="html example"><code class="html">
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
  &lt;HEAD&gt;
    &lt;TITLE&gt;Comparison of positioning schemes&lt;/TITLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;P&gt;Beginning of body contents.
      &lt;SPAN id="outer"&gt; Start of outer contents.
      &lt;SPAN id="inner"&gt; Inner contents.&lt;/SPAN&gt;
      End of outer contents.&lt;/SPAN&gt;
      End of body contents.
    &lt;/P&gt;
  &lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>

  <p>在本文档中，我们假设以下规则：</p>

  <pre class="example"><code class="css">
body { display: block; font-size:12px; line-height: 200%; 
       width: 400px; height: 400px }
p    { display: block }
span { display: inline }
</code></pre>

  <p>由<em>outer</em>和<em>inner</em>元素生成的框的最终位置在每个示例中有所不同。在每个图示中，图示左侧的数字表示双倍行距（为清晰起见）的<a href="#normal-flow">正常流</a>位置。
  </p>

  <p class="note">
    注意：本节中的图示是说明性的，比例不准确。它们旨在突出 CSS 2.2 中各种定位方案之间的差异，并不打算作为所给示例的参考渲染。
  </p>

  <h3>9.8.1 <a name="comp-normal-flow">正常流</a></h3>

  <p>考虑以下为<em>outer</em>和<em>inner</em>指定的CSS声明，这些声明不会改变框的<a href="#normal-flow">正常流</a>：</p>

  <pre class="example"><code class="css">
#outer { color: red }
#inner { color: blue }
</code></pre>

  <p>P元素包含所有内联内容：<a href="#anonymous">匿名内联文本</a>和两个SPAN元素。因此，所有内容都将在由P元素建立的包含块内以内联格式化上下文布局，产生类似以下的效果：</p>

  <div class="figure">
    <p><img src="https://www.w3.org/TR/CSS22/images/flow-generic.png" alt="展示父级和兄弟框之间的文本正常流动的图像"><SPAN
        class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-flow-generic" href="images/longdesc/flow-generic-desc.html"
          title="正常流示例的长描述">[D]</A></SPAN></p>
  </div>

  <h3>9.8.2 <a name="comp-relpos">相对定位</a></h3>

  <p>要查看<a href="#relative-positioning">相对定位</a>的效果，我们指定：</p>

  <pre class="example"><code class="css">
#outer { position: relative; top: -12px; color: red }
#inner { position: relative; top: 12px; color: blue }
</code></pre>

  <p>文本正常流动直到<em>outer</em>元素。然后，<em>outer</em>文本在行1的末尾按正常流动位置和尺寸布局。接着，包含文本的内联框（分布在三行）整体向上移动‘-12px’。</p>

  <p>作为<em>outer</em>的子元素，<em>inner</em>的内容通常会紧跟在“of outer
    contents”之后（在行1.5）。然而，<em>inner</em>的内容相对于<em>outer</em>的内容被‘12px’（向下）偏移，回到它们在行2的原始位置。</p>

  <p>注意，<em>outer</em>之后的内容不会受到<em>outer</em>相对定位的影响。</p>

  <div class="figure">
    <p><img src="https://www.w3.org/TR/CSS22/images/flow-relative.png" alt="展示相对定位对框内容影响的图像"><SPAN
        class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-flow-relative" href="images/longdesc/flow-relative-desc.html"
          title="相对定位示例的长描述">[D]</A></SPAN></p>
  </div>

  <p>还要注意，如果<em>outer</em>的偏移为‘-24px’，<em>outer</em>的文本和主体文本将会重叠。</p>

  <h3>9.8.3 <a name="comp-float">浮动框</a></h3>

  <p>现在考虑使用以下规则将<em>inner</em>元素的文本向右<a href="#floats">浮动</a>的效果：</p>

  <pre class="example"><code class="css">
#outer { color: red }
#inner { float: right; width: 130px; color: blue }
</code></pre>

  <p>文本正常流动直到<em>inner</em>框，它被从流中拉出并浮动到右边的边距（其<a href="visudet.html#propdef-width" class="noxref"><span
        class="propinst-width">‘width’</span></a>已明确指定）。浮动左侧的行框被缩短，文档的其余文本流入其中。</p>

  <div class="figure">
    <p><img src="https://www.w3.org/TR/CSS22/images/flow-float.png" alt="展示浮动框效果的图像"><SPAN
        class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-flow-float" href="images/longdesc/flow-float-desc.html"
          title="浮动示例的长描述">[D]</A></SPAN></p>
  </div>

  <p>为了展示<a href="visuren.html#propdef-clear" class="noxref"><span
        class="propinst-clear">‘clear’</span></a>属性的效果，我们在示例中添加一个<em>sibling</em>元素：</p>

  <pre class="html example"><code class="html">
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
  &lt;HEAD&gt;
    &lt;TITLE&gt;定位方案比较 II&lt;/TITLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;P&gt;正文内容开始。
      &lt;SPAN id=outer&gt; 外部内容开始。
      &lt;SPAN id=inner&gt; 内部内容。&lt;/SPAN&gt;
      &lt;SPAN id=sibling&gt; 兄弟内容。&lt;/SPAN&gt;
      外部内容结束。&lt;/SPAN&gt;
      正文内容结束。
    &lt;/P&gt;
  &lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>

  <p>以下规则：</p>

  <pre class="example"><code class="css">
#inner { float: right; width: 130px; color: blue }
#sibling { color: red }
</code></pre>

  <p>导致<em>inner</em>框像以前一样向右浮动，文档的其余文本流入空出的空间：</p>

  <div class="figure">
    <p><img src="https://www.w3.org/TR/CSS22/images/flow-clear.png" alt="展示浮动框而未设置clear属性控制文本流动的图像"><SPAN
        class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-flow-clear" href="images/longdesc/flow-clear-desc.html"
          title="未设置clear属性的浮动示例的长描述">[D]</A></SPAN></p>
  </div>

  <p>但是，如果将<em>sibling</em>元素的<a href="visuren.html#propdef-clear" class="noxref"><span
        class="propinst-clear">‘clear’</span></a>属性设置为‘right’（即生成的<em>sibling</em>框不接受位于其右侧的浮动框旁边的位置），则<em>sibling</em>内容开始在浮动框下方流动：
  </p>

  <pre class="example"><code class="css">
#inner { float: right; width: 130px; color: blue }
#sibling { clear: right; color: red }
</code></pre>

  <div class="figure">
    <p><img src="https://www.w3.org/TR/CSS22/images/flow-clear2.png" alt="展示设置clear属性后浮动元素周围文本流动效果的图像"><SPAN
        class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-flow-clear2" href="images/longdesc/flow-clear2-desc.html"
          title="设置clear属性的浮动示例的长描述">[D]</A></SPAN></p>
  </div>

  <h3>9.8.4 <a name="comp-abspos">绝对定位</a></h3>

  <p>最后，我们考虑<a href="#absolute-positioning">绝对定位</a>的效果。考虑以下为<em>outer</em>和<em>inner</em>指定的CSS声明：</p>

  <pre class="example"><code class="css">
#outer { 
    position: absolute; 
    top: 200px; left: 200px; 
    width: 200px; 
    color: red;
}
#inner { color: blue }
</code></pre>

  <p>这些规则会使<em>outer</em>框的顶部相对于其包含块进行定位。对于一个定位的框，其包含块由最近的定位祖先（如果不存在，则由<a
      href="visudet.html#containing-block-details">初始包含块</a>）建立，就像我们的例子中那样。<em>outer</em>框的顶部距离包含块顶部“200px”，左侧距离左侧“200px”。<em>outer</em>的子框相对于其父框正常流动。
  </p>

  <div class="figure">
    <p><img src="https://www.w3.org/TR/CSS22/images/flow-absolute.png" alt="展示绝对定位框效果的图像"><SPAN
        class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-flow-absolute" href="images/longdesc/flow-absolute-desc.html"
          title="绝对定位示例的详细描述">[D]</A></SPAN></p>
  </div>

  <p>下面的例子展示了一个绝对定位框，它是一个相对定位框的子元素。虽然父元素<em>outer</em>框实际上并没有偏移，但将其<a href="visuren.html#propdef-position"
      class="noxref"><span
        class="propinst-position">'position'</span></a>属性设置为'relative'意味着其框可以作为定位后代的包含块。由于<em>outer</em>框是一个跨越多行的内联框，因此第一个内联框的顶部和左侧边缘（下图中用粗虚线表示）作为<a
      href="visuren.html#propdef-top" class="noxref"><span class="propinst-top">'top'</span></a>和<a
      href="visuren.html#propdef-left" class="noxref"><span class="propinst-left">'left'</span></a>偏移量的参考。</p>

  <pre class="example"><code class="css">
#outer { 
  position: relative; 
  color: red 
}
#inner { 
  position: absolute; 
  top: 200px; left: -100px; 
  height: 130px; width: 130px; 
  color: blue;
}
</code></pre>

  <p>结果类似于以下内容：</p>

  <div class="figure">
    <p><img src="https://www.w3.org/TR/CSS22/images/flow-abs-rel.png" alt="展示相对于包含块进行绝对定位的框的效果"><SPAN
        class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-flow-abs-rel" href="images/longdesc/flow-abs-rel-desc.html"
          title="相对于定位祖先进行定位的示例的详细描述">[D]</A></SPAN></p>
  </div>

  <p>如果我们不对<em>outer</em>框进行定位：</p>

  <pre class="example"><code class="css">
#outer { color: red }
#inner {
  position: absolute; 
  top: 200px; left: -100px; 
  height: 130px; width: 130px; 
  color: blue;
}
</code></pre>

  <p>在这种情况下，<em>inner</em>的包含块将成为<a
      href="visudet.html#containing-block-details">初始包含块</a>。下图显示了<em>inner</em>框在这种情况下将出现在的位置。</p>

  <div class="figure">
    <p><img src="https://www.w3.org/TR/CSS22/images/flow-static.png" alt="展示相对于由正常定位的父元素建立的包含块进行绝对定位的框的效果"><SPAN
        class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-flow-static" href="images/longdesc/flow-static-desc.html"
          title="相对于初始包含块进行绝对定位的详细描述">[D]</A></SPAN></p>
  </div>

  <div class="html example">
    <p>相对定位和绝对定位可用于实现修改线，如下例所示。以下代码片段：</p>
    <pre><code class="html">
&lt;P style=&quot;position: relative; margin-right: 10px; left: 10px;&quot;&gt;
I used two red hyphens to serve as a change bar. They
will &quot;float&quot; to the left of the line containing THIS
&lt;SPAN style=&quot;position: absolute; top: auto; left: -1em; color: red;&quot;&gt;--&lt;/SPAN&gt;
word.&lt;/P&gt;
</code></pre>

    <p>可能产生类似以下效果：</p>

    <div class="figure">
      <p><img src="https://www.w3.org/TR/CSS22/images/changebar.png" alt="展示使用浮动创建修改线效果的图像"><SPAN
          class="dlink">&nbsp;&nbsp;&nbsp;<A name="img-changebar" href="images/longdesc/changebar-desc.html"
            title="修改线示例的详细描述">[D]</A></SPAN></p>
    </div>

    <p>首先，段落（包含块边界在图中显示）按正常方式流动。然后它从包含块的左边缘偏移‘10px’（因此，为了预期的偏移，已预留了‘10px’的右边距）。作为修改线的两个红色破折号从流动中移出并定位在当前行上（由于'top:
      auto'），距离其包含块的左边缘'-1em'（由P元素在其最终位置建立）。结果是修改线似乎“浮动”在当前行的左侧。</p>
  </div>

  <h2>9.9 <a name="layers">层叠呈现</a></h2>

  <h3>9.9.1 <a name="z-index">指定堆叠层级</a>：<a href="visuren.html#propdef-z-index" class="noxref"><span
        class="propinst-z-index">z-index</span></a>属性</h3>

  <table class="def propdef">
    <tbody>
      <tr>
        <th>Name:
        <td><a name="x42"><span class="index-def" title="'z-index'"><dfn id="propdef-z-index">z-index</dfn></span></a>
      <tr>
        <th>Value:
        <td>auto | <a href="syndata.html#value-def-integer" class="noxref"><span
              class="value-inst-integer">&lt;integer&gt;</span></a> | <a href="cascade.html#value-def-inherit"
            class="noxref"><span class="value-inst-inherit">inherit</span></a>
      <tr>
        <th>Initial:
        <td>auto
      <tr>
        <th>Applies to:
        <td>定位元素
      <tr>
        <th>Inherited:
        <td>no
      <tr>
        <th>Percentages:
        <td>N/A
      <tr>
        <th>Media:
        <td><a href="media.html#visual-media-group" class="noxref">视觉</a>
      <tr>
        <th>Computed&nbsp;value:
        <td>按指定计算
  </table>

  <p>对于定位框，<a href="visuren.html#propdef-z-index" class="noxref"><span class="propinst-z-index">z-index</span></a>属性指定：
  </p>

  <ol>
    <li>框在当前堆叠上下文中的堆叠层级。</li>
    <li>框是否建立一个堆叠上下文。</li>
  </ol>

  <p>值的含义如下：</p>

  <dl>
    <dt><span class="index-inst" title="&lt;integer&gt;"><a name="x43" href="syndata.html#value-def-integer"
          class="noxref"><span class="value-inst-integer"><strong>&lt;integer&gt;</strong></span></a></span>
    <dd>此整数是生成的框在当前堆叠上下文中的堆叠层级。该框也建立了一个新的堆叠上下文。</dd>

    <dt><strong>auto</strong></dt>
    <dd>生成的框在当前堆叠上下文中的堆叠层级为0。如果该框的'position'值为fixed或如果它是根元素，它也建立了一个新的堆叠上下文。</dd>
  </dl>

  <p><em>在本节中，“在前面”的表达意味着靠近用户，即用户面对屏幕时更靠近用户。</em></p>

  <p>在CSS&nbsp;2.2中，每个框在三维空间中都有一个位置。除了它们的水平和垂直位置，框还沿着“z轴”排列并依次叠加。当框在视觉上重叠时，z轴位置尤其重要。本节讨论框如何在z轴上定位。</p>

  <p>渲染树绘制到画布上的顺序以堆叠上下文的形式描述。堆叠上下文可以包含更多的堆叠上下文。对于其父堆叠上下文而言，堆叠上下文是原子的；其他堆叠上下文中的框不能介于它的任何框之间。</p>

  <p>每个框属于一个<a name="x44"><span class="index-def" title="堆叠上下文"><dfn>堆叠上下文</dfn></span></a>。给定堆叠上下文中的每个定位框都有一个整数<a
      name="stack-level"><span class="index-def"
        title="堆叠层级"><dfn>堆叠层级</dfn></span></a>，这是它在相对于同一堆叠上下文中其他堆叠层级的z轴位置。堆叠层级较大的框始终在堆叠层级较小的框前面显示。框可以具有负堆叠层级。具有相同堆叠层级的框在同一堆叠上下文中按照文档树顺序从后到前进行堆叠。
  </p>

  <p>根元素构成根堆叠上下文。任何具有'auto'以外z-index计算值的定位元素（包括相对定位的元素）都会生成其他堆叠上下文。堆叠上下文不一定与包含块相关联。在CSS的未来版本中，其他属性可能会引入堆叠上下文，例如'<a
      href="https://www.w3.org/TR/css3-color/#transparency">透明度</a>' <a href="refs.html#ref-CSS3COLOR" rel="biblioentry"
      class="noxref"><span class="informref">[CSS3COLOR]</span></a>。</p>

  <p>在每个堆叠上下文中，以下各层按从后到前的顺序绘制：</p>

  <ol>
    <li>形成堆叠上下文的元素的背景和边框。</li>
    <li>具有负堆叠层级的子堆叠上下文（先绘制负值最大者）。</li>
    <li>流内、非内联级、非定位后代。</li>
    <li>非定位浮动框。</li>
    <li>流内、内联级、非定位后代，包括内联表格和内联块。</li>
    <li>具有堆叠层级为0的子堆叠上下文和具有堆叠层级为0的定位后代。</li>
    <li>具有正堆叠层级的子堆叠上下文（先绘制正值最小者）。</li>
  </ol>

  <p>
    在每个堆叠上下文中，堆叠层级为0的定位元素（在层&nbsp;6中）、非定位浮动框（层&nbsp;4）、内联块（层&nbsp;5）和内联表格（层&nbsp;5）会像这些元素本身生成了新的堆叠上下文一样绘制，但它们的定位后代和任何将生成的子堆叠上下文会参与当前堆叠上下文。
  </p>

  <p>这种绘制顺序递归地应用于每个堆叠上下文。本描述的堆叠上下文绘制顺序概述了<a href="zindex.html">附录&nbsp;E</a>中详细规范的规范性定义。</p>

  <div class="html example">
    <p>在以下示例中，框（以其“id”属性命名）的堆叠层级为：“text2”=0，“image”=1，“text3”=2，“text1”=3。“text2”的堆叠层级从根框继承。其他堆叠层级通过<a
        href="visuren.html#propdef-z-index" class="noxref"><span class="propinst-z-index">'z-index'</span></a>属性指定。</p>
    <pre><code class="html">
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
  &lt;HEAD&gt;
    &lt;TITLE&gt;Z-order positioning&lt;/TITLE&gt;
    &lt;STYLE type="text/css"&gt;
      .pile { 
        position: absolute; 
        left: 2in; 
        top: 2in; 
        width: 3in; 
        height: 3in; 
      }
    &lt;/STYLE&gt;
  &lt;/HEAD&gt;
  &lt;BODY&gt;
    &lt;P&gt;
      &lt;IMG id="image" class="pile" 
           src="butterfly.png" alt="A butterfly image"
           style="z-index: 1"&gt;

    &lt;DIV id="text1" class="pile" 
         style="z-index: 3"&gt;
      This text will overlay the butterfly image.
    &lt;/DIV&gt;

    &lt;DIV id="text2"&gt;
      This text will be beneath everything.
    &lt;/DIV&gt;

    &lt;DIV id="text3" class="pile" 
         style="z-index: 2"&gt;
      This text will underlay text1, but overlay the butterfly image
    &lt;/DIV&gt;
  &lt;/BODY&gt;
&lt;/HTML&gt;
</code></pre>
  </div>

  <p>此示例演示了<em>透明度</em>的概念。默认情况下，背景允许后面的框可见。在该示例中，每个框透明地覆盖在其下方的框上。可以通过使用现有的<a
      href="colors.html#background-properties">背景属性</a>之一来覆盖此行为。</p>

  <h2>9.10 <a name="direction">文本方向：</a> <a href="visuren.html#propdef-direction" class="noxref"><span
        class="propinst-direction">direction</span></a> 和 <a href="visuren.html#propdef-unicode-bidi"
      class="noxref"><span class="propinst-unicode-bidi">unicode-bidi</span></a> 属性</h2>

  <p><a href="conform.html#conformance">符合规范</a>的用户代理（UAs）如果不支持双向文本，可以忽略本节中描述的 <a href="visuren.html#propdef-direction"
      class="noxref"><span class="propinst-direction">direction</span></a> 和 <a href="visuren.html#propdef-unicode-bidi"
      class="noxref"><span class="propinst-unicode-bidi">unicode-bidi</span></a>
    属性。这一例外包括那些仅仅因为系统上的字体包含右到左字符而呈现右到左字符的用户代理，但不支持右到左文本方向的概念。</p>

  <p>某些脚本中的字符是从右向左书写的。在某些文档中，尤其是使用阿拉伯语或希伯来语脚本编写的文档，以及一些混合语言的情况下，单个（视觉显示的）块中的文本可能会出现混合方向性。这种现象被称为<a name="x46"><span
        class="index-def" title="bidirectionality (bidi)"><dfn>双向性</dfn></span></a>，简称为“bidi”。</p>

  <p>Unicode标准（<a href="refs.html#ref-UNICODE" rel="biblioentry" class="noxref"><span
        class="normref">[UNICODE]</span></a>，<a href="refs.html#ref-UAX9" rel="biblioentry" class="noxref"><span
        class="normref">[UAX9]</span></a>）定义了一个复杂的算法，用于确定文本的正确方向性。该算法包括基于字符属性的隐式部分以及用于嵌入和覆盖的显式控制。CSS&nbsp;2.2依赖此算法实现正确的双向渲染。<a
      href="visuren.html#propdef-direction" class="noxref"><span class="propinst-direction">direction</span></a> 和 <a
      href="visuren.html#propdef-unicode-bidi" class="noxref"><span
        class="propinst-unicode-bidi">unicode-bidi</span></a> 属性允许作者指定文档语言的元素和属性如何映射到此算法。</p>

  <p>支持双向文本的用户代理必须将Unicode双向算法应用于每个不被强制中断（<a
      href="http://www.unicode.org/reports/tr9/#Bidirectional_Character_Types">bidi类&nbsp;B</a>）或块边界中断的内联级框序列。该序列在双向算法中形成“段落”单元。段落嵌入级别根据包含块的<a
      href="visuren.html#propdef-direction" class="noxref"><span
        class="propinst-direction">direction</span></a>属性值设置，而不是通过Unicode算法步骤P2和P3中给出的启发式方法。</p>

  <p>由于文本的方向性取决于文档语言的结构和语义，因此这些属性在大多数情况下应仅由文档类型描述（DTD）的设计者或特殊文档的作者使用。如果默认样式表指定了这些属性，作者和用户不应指定规则来覆盖它们。</p>

  <p>HTML 4规范（[HTML4]，第8.2节）定义了HTML元素的双向性行为。在<a href="refs.html#ref-HTML4" rel="biblioentry" class="noxref"><span
        class="normref">[HTML4]</span></a>中指定的双向行为可以通过<a href="sample.html#bidi">示例样式表</a>中的样式表规则实现。HTML
    4规范还包含有关双向性问题的更多信息。</p>

  <table class="def propdef">
    <tbody>
      <tr>
        <th>Name:
        <td><a name="x47"><span class="index-def" title="'direction'"><dfn
                id="propdef-direction">direction</dfn></span></a>
      <tr>
        <th>Value:
        <td>ltr | rtl | <a href="cascade.html#value-def-inherit" class="noxref"><span
              class="value-inst-inherit">inherit</span></a>
      <tr>
        <th>Initial:
        <td>ltr
      <tr>
        <th>Applies to:
        <td>所有元素，但请参阅正文
      <tr>
        <th>Inherited:
        <td>yes
      <tr>
        <th>Percentages:
        <td>N/A
      <tr>
        <th>Media:
        <td><a href="media.html#visual-media-group" class="noxref">视觉</a>
      <tr>
        <th>Computed&nbsp;value:
        <td>按指定计算
  </table>

  <p>此属性指定块的基本书写方向以及Unicode双向算法的嵌入和覆盖方向（参见<a href="visuren.html#propdef-unicode-bidi" class="noxref"><span
        class="propinst-unicode-bidi">unicode-bidi</span></a>）。此外，它还指定了诸如<a href="tables.html">表格</a>列布局的方向、水平<a
      href="visufx.html#overflow">溢出</a>的方向以及在“text-align: justify”情况下块中不完整最后一行的位置等内容。</p>

  <p>此属性的值具有以下含义：</p>

  <dl>
    <dt><strong>ltr</strong></dt>
    <dd>从左到右的方向。</dd>
    <dt><strong>rtl</strong></dt>
    <dd>从右到左的方向。</dd>
  </dl>

  <p>要使<a href="visuren.html#propdef-direction" class="noxref"><span
        class="propinst-direction">direction</span></a>属性影响内联元素的重新排序，<a href="visuren.html#propdef-unicode-bidi"
      class="noxref"><span class="propinst-unicode-bidi">unicode-bidi</span></a>属性的值必须为'embed'或'override'。</p>

  <div class="note">
    <p>
      <em><strong>注意。</strong>
        当<a href="visuren.html#propdef-direction" class="noxref"><span
            class="propinst-direction">direction</span></a>属性指定给表格列元素时，不会被列中的单元格继承，因为列不是文档树中单元格的祖先。因此，CSS无法轻松捕获<a
          href="refs.html#ref-HTML4" rel="biblioentry" class="noxref"><span
            class="normref">[HTML4]</span></a>第11.3.2.1节中描述的“dir”属性继承规则。
      </em>
    </p>
  </div>

  <table class="def propdef">
    <tbody>
      <tr>
        <th>Name:
        <td><a name="x48"><span class="index-def" title="'unicode-bidi'"><dfn
                id="propdef-unicode-bidi">unicode-bidi</dfn></span></a>
      <tr>
        <th>Value:
        <td>normal | embed | bidi-override | <a href="cascade.html#value-def-inherit" class="noxref"><span
              class="value-inst-inherit">inherit</span></a>
      <tr>
        <th>Initial:
        <td>normal
      <tr>
        <th>Applies to:
        <td>所有元素，但请参阅正文
      <tr>
        <th>Inherited:
        <td>no
      <tr>
        <th>Percentages:
        <td>N/A
      <tr>
        <th>Media:
        <td><a href="media.html#visual-media-group" class="noxref">视觉</a>
      <tr>
        <th>Computed&nbsp;value:
        <td>按指定计算
  </table>

  <p>此属性的值具有以下含义：</p>

  <dl>
    <dt><strong>normal</strong></dt>
    <dd>元素不会在双向算法中打开额外的嵌入级别。对于内联元素，隐式重排序可以跨越元素边界。</dd>
    <dt><strong>embed</strong></dt>
    <dd>如果元素是内联的，此值将根据双向算法打开一个额外的嵌入级别。此嵌入级别的方向由<a href="visuren.html#propdef-direction" class="noxref"><span
          class="propinst-direction">'direction'</span></a>属性给出。在元素内部，重排序是隐式完成的。这相当于在元素的开头添加LRE（U+202A；对于'direction:
      ltr'）或RLE（U+202B；对于'direction: rtl'），在元素的结尾添加PDF（U+202C）。</dd>
    <dt><strong>bidi-override</strong></dt>
    <dd>对于内联元素，这会创建一个覆盖。对于块容器元素，这会为内联级别的后代（不在另一个块容器元素内）创建一个覆盖。这意味着在元素内部，重排序严格按照<a href="visuren.html#propdef-direction"
        class="noxref"><span
          class="propinst-direction">'direction'</span></a>属性的顺序进行，双向算法的隐式部分被忽略。这相当于在元素的开头或在每个匿名子块框的开头添加LRO（U+202D；对于'direction:
      ltr'）或RLO（U+202E；对于'direction: rtl'），在元素的结尾添加PDF（U+202C）。</dd>
  </dl>

  <p>每个块容器中的最终字符顺序与按照上述描述添加了双向控制代码、剥离了标记，并将生成的字符序列传递给生成与样式化文本相同换行的纯文本Unicode双向算法的实现后的顺序相同。在此过程中，具有'display:
    inline'的替换元素被视为中性字符，除非其<a href="visuren.html#propdef-unicode-bidi" class="noxref"><span
        class="propinst-unicode-bidi">'unicode-bidi'</span></a>属性的值不是'normal'，在这种情况下，它们将按照为元素指定的<a
      href="visuren.html#propdef-direction" class="noxref"><span
        class="propinst-direction">'direction'</span></a>视为强字符。所有其他原子内联级框始终被视为中性字符。</p>

  <p>请注意，为了能够以统一的方向流动内联框（完全从左到右或完全从右到左），可能需要创建更多的内联框（包括匿名内联框），并且在流动之前可能需要分割和重新排序某些内联框。</p>

  <p>由于Unicode算法的嵌入级别限制为<em
      title="根据Unicode 3.0，第3章，第12节，定义BD2。特别是第58页：http://www.unicode.org/unicode/uni2book/ch03.pdf">61级</em>，因此在适当情况下应谨慎使用除'normal'以外的<a
      href="visuren.html#propdef-unicode-bidi" class="noxref"><span
        class="propinst-unicode-bidi">'unicode-bidi'</span></a>值。特别是，'inherit'值应谨慎使用。然而，对于通常打算显示为块的元素，设置'unicode-bidi:
    embed'是首选，以便在显示更改为内联时保持元素的完整性（参见下面的示例）。</p>

  <p>以下示例显示了带有双向文本的XML文档。它说明了一个重要的设计原则：<a name="x49"><span class="index-inst"
        title="DTD">DTD</span></a>设计者应在语言本身（元素和属性）以及任何附带的样式表中考虑双向性。样式表应设计为使双向规则与其他样式规则分开。双向规则不应被其他样式表覆盖，以便保留文档语言或DTD的双向行为。
  </p>

  <div class="example">
    <P style="display:none">示例：</P>
    <p>在此示例中，小写字母代表本质上从左到右的字符，大写字母代表本质上从右到左的字符：</p>
    <pre class="xml example"><code class="xml">
&lt;HEBREW&gt;
  &lt;PAR&gt;HEBREW1 HEBREW2 english3 HEBREW4 HEBREW5&lt;/PAR&gt;
  &lt;PAR&gt;HEBREW6 &lt;EMPH&gt;HEBREW7&lt;/EMPH&gt; HEBREW8&lt;/PAR&gt;
&lt;/HEBREW&gt;
&lt;ENGLISH&gt;
  &lt;PAR&gt;english9 english10 english11 HEBREW12 HEBREW13&lt;/PAR&gt;
  &lt;PAR&gt;english14 english15 english16&lt;/PAR&gt;
  &lt;PAR&gt;english17 &lt;HE-QUO&gt;HEBREW18 english19 HEBREW20&lt;/HE-QUO&gt;&lt;/PAR&gt;
&lt;/ENGLISH&gt;
</code></pre>

    <p>由于这是XML，样式表负责设置书写方向。这是样式表：</p>

    <pre class="example">
/* 双向规则 */
HEBREW, HE-QUO  {direction: rtl; unicode-bidi: embed}
ENGLISH         {direction: ltr; unicode-bidi: embed}

/* 显示规则 */
HEBREW, ENGLISH, PAR  {display: block}
EMPH                  {font-weight: bold}
</pre>

    <p>
      HEBREW元素是具有从右到左基本方向的块，ENGLISH元素是具有从左到右基本方向的块。PAR是从其父元素继承基本方向的块。因此，前两个PAR从右上角开始阅读，最后三个从左上角开始阅读。请注意，HEBREW和ENGLISH作为元素名称仅用于显式说明；通常情况下，元素名称应传达结构，而不参考语言。
    </p>
    <p>EMPH元素是内联级别的，由于其<a href="visuren.html#propdef-unicode-bidi" class="noxref"><span
          class="propinst-unicode-bidi">'unicode-bidi'</span></a>值为'normal'（初始值），因此对文本顺序没有影响。另一方面，HE-QUO元素创建了一个嵌入。</p>
    <p>如果行长度较长，此文本的格式可能如下所示：</p>
    <pre class="ascii-art">
               5WERBEH 4WERBEH english3 2WERBEH 1WERBEH

                                8WERBEH <b>7WERBEH</b> 6WERBEH

english9 english10 english11 13WERBEH 12WERBEH

english14 english15 english16

english17 20WERBEH english19 18WERBEH
</pre>

    <p>请注意，HE-QUO嵌入导致HEBREW18位于english19的右侧。</p>
    <p>如果必须换行，它可能更像这样：</p>
    <pre class="ascii-art">
       2WERBEH 1WERBEH
  -EH 4WERBEH english3
                 5WERB

   -EH <b>7WERBEH</b> 6WERBEH
                 8WERB

english9 english10 en-
glish11 12WERBEH
13WERBEH

english14 english15
english16

english17 18WERBEH
20WERBEH english19
</pre>

    <p>
      由于HEBREW18必须在english19之前阅读，因此它位于english19的上一行。仅仅从早期格式中拆分长行是行不通的。还要注意，english19的第一个音节可能适合上一行，但通常会抑制在从右到左的上下文中对从左到右单词的连字符断字，反之亦然，以避免在行中间显示连字符。
    </p>
  </div>

  <hr class="navbar">

  <div class="navbar">
    <p><a href="box.html">上一页</a> &nbsp;
      <a href="visudet.html">下一页</a> &nbsp;
      <a href="index.html#minitoc">内容</a> &nbsp;
      <a href="propidx.html">属性</a> &nbsp;
      <a href="indexlist.html">索引</a> &nbsp;
  </div>
  <script src="https://www.w3.org/scripts/TR/2016/fixup.js"></script>
</body>

</html>