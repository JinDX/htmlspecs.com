<!DOCTYPE html>

<html lang="zh-hans">

<head>
    <meta charset=utf-8>

    <title>选择器 3 级</title>

    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

    <link href="https://www.w3.org/TR/2018/REC-selectors-3-20181106/" rel=canonical>
    <!--
  <link href="http://purl.org/dc/terms/" rel="schema.dcterms">
  <link href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright" rel="dcterms.rights">
  -->

    <meta content="Selectors Level 3" name=dcterms.title>
    <meta content=text name=dcterms.type>
    <meta content=2018-01-30 name=dcterms.date>
    <meta content="Tantek Çelik" name=dcterms.creator>
    <meta content="Elika J. Etemad" name=dcterms.creator>
    <meta content="Daniel Glazman" name=dcterms.creator>
    <meta content="Ian Hickson" name=dcterms.creator>
    <meta content="Peter Linss" name=dcterms.creator>
    <meta content="John Williams" name=dcterms.creator>
    <meta content=W3C name=dcterms.publisher>
    <meta content="https://www.w3.org/TR/2018/REC-selectors-3-20181106/" name=dcterms.identifier>
    <link href="https://www.w3.org/TR/selectors-3/default.css" rel=stylesheet type="text/css">
    <link href="https://www.w3.org/StyleSheets/TR/2016/W3C-REC.css" rel=stylesheet type="text/css">
    <script defer="" src="https://test.csswg.org/harness/annotate.js#!selectors-3_dev/selectors-3"></script>

<body>
    <div class=head> <!--begin-logo-->
        <p><a href="https://www.w3.org/"><img alt=W3C height=48 src="https://www.w3.org/StyleSheets/TR/2016/logos/W3C"
                    width=72></a>
            <!--end-logo-->

        <h1 id=title>选择器 3 级</h1>

        <h2 class="no-num no-toc">W3C 推荐标准 2018年11月06日</h2>

        <dl>
            <dt>此版本：</dt>

            <dd>
                <a href="https://www.w3.org/TR/2018/REC-selectors-3-20181106/">
                    https://www.w3.org/TR/2018/REC-selectors-3-20181106/</a>
            </dd>

            <dt>最新版本：</dt>

            <dd><a href="https://www.w3.org/TR/selectors-3/">
                    https://www.w3.org/TR/selectors-3/</a></dd>

            <dt>之前的版本：</dt>

            <dd><a href="https://www.w3.org/TR/2018/PR-selectors-3-20180911/">
                    https://www.w3.org/TR/2018/PR-selectors-3-20180911/</a></dd>


            <dt>选择器的最新版本：</dt>
            <dd><a href="https://www.w3.org/TR/selectors/">https://www.w3.org/TR/selectors/</a></dd>

            <dt>编辑草案：</dt>
            <dd><a href="https://drafts.csswg.org/selectors-3/">https://drafts.csswg.org/selectors-3/</a></dd>


            <dt>反馈：</dt>

            <dd>在 <a href="https://github.com/w3c/csswg-drafts/labels/selectors-3">GitHub 上提交问题</a>

            <dt id=editors-list>编辑：</dt>

            <dd class=vcard><a class="url fn" href="http://www.tantek.com/" lang=tr>Tantek Çelik</a> (受邀专家)

            <dd class=vcard><a class="url fn" href="http://fantasai.inkedblade.net/contact">Elika J. Etemad</a>
                (受邀专家)

            <dd class=vcard><span class=fn>Daniel Glazman</span> (Disruptive
                Innovations SARL)

            <dd class=vcard><a class="url fn" href="mailto:ian@hixie.ch">Ian
                    Hickson</a> (<span class=company><a href="https://www.google.com/">Google</a></span>)

            <dd class=vcard><span class=fn>Peter Linss</span> (前编辑, <span class=company><a
                        href="http://www.netscape.com/">Netscape/AOL</a></span>)

            <dd class=vcard><span class=fn>John Williams</span> (前编辑, <span class=company><a
                        href="http://www.quark.com/">Quark, Inc.</a></span>)
        </dl>
        <p>请查看<a
                href="https://www.w3.org/Style/2018/REC-selectors-3-20181106-errata.html"><strong>勘误表</strong></a>以了解自发布以来报告的任何错误或问题。
        </p>

        <!--begin-copyright-->
        <p class="copyright"><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> © 2018 <a
                href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a
                href="https://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a
                href="https://www.ercim.eu/"><abbr
                    title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a
                href="https://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a
                href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a
                href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a
                href="https://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>
        <!--end-copyright-->
        <hr title="页眉分隔符">
    </div>

    <h2 class="no-num no-toc" id=abstract>摘要</h2>

    <p><a
            href="#selector"><em>选择器</em></a>是与树中的元素匹配的模式，因此是可用于在XML文档中选择节点的几种技术之一。选择器已针对HTML和XML的使用进行了优化，并且设计为可在性能关键的代码中使用。

    <p><abbr title="层叠样式表">CSS</abbr>（层叠样式表）是一种用于描述<abbr title="超文本标记语言">HTML</abbr>和<abbr
            title="可扩展标记语言">XML</abbr>文档在屏幕、纸张、语音等介质上呈现的语言。CSS 使用选择器将样式属性绑定到文档中的元素。

    <p>本文档描述了<abbr title="CSS 第一版">CSS1</abbr><a href="#ref-CSS1">[CSS1]<!--{{CSS1}}--></a>和<abbr
            title="CSS 第二版">CSS2</abbr><a href="#ref-CSS21">[CSS21]<!--{{!CSS21}}--></a>中已经存在的选择器，并进一步为<abbr
            title="CSS 第三版">CSS3</abbr>和可能需要它们的其他语言引入了新选择器。

    <p>选择器定义了以下功能：

    <pre>expression ∗ element → boolean</pre>

    <p>即，给定一个元素和一个选择器，本规范定义该元素是否与选择器匹配。

    <p>这些表达式还可以用于例如通过在子树中的所有元素上评估表达式来选择一组元素或从一组元素中选择单个元素。<abbr title="简单树转换表">STTS</abbr>（简单树转换表），一种用于转换XML树的语言，使用此机制。<a
            href="#ref-STTS3">[STTS3]<!--{{STTS3}}--></a>

    <h2 class="no-num no-toc" id=status>本文档的状态</h2>
    <!--begin-status-->

    <p><em>本节描述了本文档在发布时的状态。其他文档可能会取代本文档。在<a
                href="https://www.w3.org/TR/">W3C技术报告索引</a>中可以找到当前W3C出版物的列表及本技术报告的最新修订版。</em></p>

    <p>本W3C推荐标准与2018年9月11日的<a
            href="https://www.w3.org/TR/2018/PR-selectors-3-20180911/">建议推荐标准</a>完全相同，只是状态和模板更新为W3C推荐标准。</p>

    <p>本文件已由W3C成员、软件开发人员及其他W3C小组和感兴趣的各方进行了审查，并由主管推荐为W3C推荐标准。它是一个稳定的文件，可以作为参考材料或从其他文档中引用。W3C在制定推荐标准时的作用是引起对规范的关注，并促进其广泛部署。这增强了Web的功能和互操作性。
    </p>

    <p>本文档由<a href="https://www.w3.org/Style/CSS/members">CSS工作组</a>作为<a
            href="https://www.w3.org/2018/Process-20180201/#Reports">W3C推荐标准</a>制作。</p>

    <p>建议推荐标准是一份已被广泛审查并准备实施的文件。W3C鼓励大家实施本规范，并在2018年10月11日之前通过<a
            href="https://github.com/w3c/csswg-drafts/labels/selectors-3">GitHub问题</a>返回意见。所有问题和评论都<a
            href="https://lists.w3.org/Archives/Public/public-css-archive/">已归档</a>，还有一个<a
            href="https://lists.w3.org/Archives/Public/www-style/">历史归档</a>。

    <p>本文件由遵循<a href="https://www.w3.org/Consortium/Patent-Policy/">W3C专利政策</a>的工作组制作。W3C维护了<a
            href="https://www.w3.org/2004/01/pp-impl/32061/status"
            rel=disclosure>与本工作组交付物相关的任何专利披露的公开列表</a>；该页面还包括披露专利的说明。个人如果实际知道某项专利且认为其中包含<a
            href="https://www.w3.org/Consortium/Patent-Policy/#def-essential">基本专利权要求</a>，则必须根据<a
            href="https://www.w3.org/Consortium/Patent-Policy/#sec-Disclosure">W3C专利政策第6节</a>的规定披露该信息。</p>

    <p>本文件受<a id="w3c_process_revision" href="https://www.w3.org/2018/Process-20180201/">2018年2月1日W3C流程文档</a>的管辖。</p>
    <!--end-status-->

    <p>一个单独的<a href="https://test.csswg.org/harness/suite/selectors-3_dev/">测试套件</a>和<a
            href="https://test.csswg.org/harness/results/selectors-3_dev/grouped/">实施报告</a>也已提供。

    <nav id=toc>
        <h2 class="no-num no-toc" id=contents>目录</h2>
        <!--begin-toc-->
        <ul class=toc>
            <li><a href="#context"><span class=secno>1. </span>简介</a>
                <ul class=toc>
                    <li><a href="#dependencies"><span class=secno>1.1.
                            </span>依赖关系</a>

                    <li><a href="#terminology"><span class=secno>1.2.
                            </span>术语</a>

                    <li><a href="#changesFromCSS2"><span class=secno>1.3. </span>与 CSS2 的变化</a>
                </ul>

            <li><a href="#selectors"><span class=secno>2. </span>选择器</a>

            <li><a href="#casesens"><span class=secno>3. </span>区分大小写</a>

            <li><a href="#selector-syntax"><span class=secno>4. </span>选择器语法</a>

            <li><a href="#grouping"><span class=secno>5. </span>选择器组</a>

            <li><a href="#simple-selectors"><span class=secno>6. </span>简单选择器</a>
                <ul class=toc>
                    <li><a href="#type-selectors"><span class=secno>6.1. </span>类型选择器</a>
                        <ul class=toc>
                            <li><a href="#typenmsp"><span class=secno>6.1.1. </span>类型选择器和命名空间</a>
                        </ul>

                    <li><a href="#universal-selector"><span class=secno>6.2.
                            </span>通用选择器</a>
                        <ul class=toc>
                            <li><a href="#univnmsp"><span class=secno>6.2.1. </span>通用选择器和命名空间</a>
                        </ul>

                    <li><a href="#attribute-selectors"><span class=secno>6.3.
                            </span>属性选择器</a>
                        <ul class=toc>
                            <li><a href="#attribute-representation"><span class=secno>6.3.1.
                                    </span>属性存在与值选择器</a>

                            <li><a href="#attribute-substrings"><span class=secno>6.3.2.
                                    </span>子串匹配属性选择器</a>

                            <li><a href="#attrnmsp"><span class=secno>6.3.3. </span>属性选择器和命名空间</a>

                            <li><a href="#def-values"><span class=secno>6.3.4. </span>DTD 中的默认属性值</a>
                        </ul>

                    <li><a href="#class-html"><span class=secno>6.4. </span>类选择器</a>

                    <li><a href="#id-selectors"><span class=secno>6.5. </span>ID 选择器</a>

                    <li><a href="#pseudo-classes"><span class=secno>6.6.
                            </span>伪类</a>
                        <ul class=toc>
                            <li><a href="#dynamic-pseudos"><span class=secno>6.6.1.
                                    </span>动态伪类</a>
                                <ul class=toc>
                                    <li><a href="#the-link-pseudo-classes-link-and-visited"><span class=secno>6.6.1.1.
                                            </span>链接伪类：:link 和 :visited</a>

                                    <li><a href="#the-user-action-pseudo-classes-hover-act"><span class=secno>6.6.1.2.
                                            </span>用户操作伪类：:hover, :active 和 :focus</a>
                                </ul>

                            <li><a href="#target-pseudo"><span class=secno>6.6.2. </span>目标伪类 :target</a>

                            <li><a href="#lang-pseudo"><span class=secno>6.6.3. </span>语言伪类 :lang</a>

                            <li><a href="#UIstates"><span class=secno>6.6.4. </span>UI 元素状态伪类</a>
                                <ul class=toc>
                                    <li><a href="#enableddisabled"><span class=secno>6.6.4.1.
                                            </span>:enabled 和 :disabled 伪类</a>

                                    <li><a href="#checked"><span class=secno>6.6.4.2. </span>:checked 伪类</a>

                                    <li><a href="#indeterminate"><span class=secno>6.6.4.3. </span>:indeterminate 伪类</a>
                                </ul>

                            <li><a href="#structural-pseudos"><span class=secno>6.6.5.
                                    </span>结构伪类</a>
                                <ul class=toc>
                                    <li><a href="#root-pseudo"><span class=secno>6.6.5.1. </span>:root 伪类</a>

                                    <li><a href="#nth-child-pseudo"><span class=secno>6.6.5.2.
                                            </span>:nth-child() 伪类</a>

                                    <li><a href="#nth-last-child-pseudo"><span class=secno>6.6.5.3.
                                            </span>:nth-last-child() 伪类</a>

                                    <li><a href="#nth-of-type-pseudo"><span class=secno>6.6.5.4.
                                            </span>:nth-of-type() 伪类</a>

                                    <li><a href="#nth-last-of-type-pseudo"><span class=secno>6.6.5.5.
                                            </span>:nth-last-of-type() 伪类</a>

                                    <li><a href="#first-child-pseudo"><span class=secno>6.6.5.6.
                                            </span>:first-child 伪类</a>

                                    <li><a href="#last-child-pseudo"><span class=secno>6.6.5.7.
                                            </span>:last-child 伪类</a>

                                    <li><a href="#first-of-type-pseudo"><span class=secno>6.6.5.8.
                                            </span>:first-of-type 伪类</a>

                                    <li><a href="#last-of-type-pseudo"><span class=secno>6.6.5.9.
                                            </span>:last-of-type 伪类</a>

                                    <li><a href="#only-child-pseudo"><span class=secno>6.6.5.10.
                                            </span>:only-child 伪类</a>

                                    <li><a href="#only-of-type-pseudo"><span class=secno>6.6.5.11.
                                            </span>:only-of-type 伪类</a>

                                    <li><a href="#empty-pseudo"><span class=secno>6.6.5.12.
                                            </span>:empty 伪类</a>
                                </ul>

                            <li><a href="#content-selectors"><span class=secno>6.6.6.
                                    </span>空白</a>

                            <li><a href="#negation"><span class=secno>6.6.7. </span>否定伪类</a>
                        </ul>
                </ul>

            <li><a href="#pseudo-elements"><span class=secno>7.
                    </span>伪元素</a>
                <ul class=toc>
                    <li><a href="#first-line"><span class=secno>7.1. </span>::first-line 伪元素</a>
                        <ul class=toc>
                            <li><a href="#first-formatted-line"><span class=secno>7.1.1.
                                    </span>CSS 中的首行格式定义</a>
                        </ul>

                    <li><a href="#first-letter"><span class=secno>7.2. </span>::first-letter 伪元素</a>
                        <ul class=toc>
                            <li><a href="#application-in-css"><span class=secno>7.2.1.
                                    </span>CSS 中的应用</a>
                        </ul>

                    <li><a href="#selection"><span class=secno>7.3. </span>空白</a>

                    <li><a href="#gen-content"><span class=secno>7.4. </span>::before 和 ::after 伪元素</a>
                </ul>

            <li><a href="#combinators"><span class=secno>8. </span>组合器</a>
                <ul class=toc>
                    <li><a href="#descendant-combinators"><span class=secno>8.1.
                            </span>后代组合器</a>

                    <li><a href="#child-combinators"><span class=secno>8.2. </span>子代组合器</a>

                    <li><a href="#sibling-combinators"><span class=secno>8.3.
                            </span>兄弟组合器</a>
                        <ul class=toc>
                            <li><a href="#adjacent-sibling-combinators"><span class=secno>8.3.1.
                                    </span>相邻兄弟组合器</a>

                            <li><a href="#general-sibling-combinators"><span class=secno>8.3.2.
                                    </span>普通兄弟组合器</a>
                        </ul>
                </ul>

            <li><a href="#specificity"><span class=secno>9. </span>计算选择器的特异性</a>

            <li><a href="#w3cselgrammar"><span class=secno>10. </span>选择器的语法</a>
                <ul class=toc>
                    <li><a href="#grammar"><span class=secno>10.1. </span>语法</a>

                    <li><a href="#lex"><span class=secno>10.2. </span>词法分析器</a>
                </ul>

            <li><a href="#profiling"><span class=secno>11. </span>配置文件</a>

            <li><a href="#Conformance"><span class=secno>12. </span>一致性和要求</a>

            <li><a href="#Tests"><span class=secno>13. </span>测试</a>

            <li><a href="#ACKS"><span class=secno>14. </span>致谢</a>

            <li><a href="#references"><span class=secno>15. </span>参考文献</a>
                <ul class=toc>
                    <li><a href="#normative-references"><span class=secno>15.1.
                            </span>规范性参考</a>

                    <li><a href="#informative-references"><span class=secno>15.2.
                            </span>补充性参考</a>

                    <li><a href="#changes"><span class=secno>15.3. </span>变更</a>
                </ul>
        </ul>
        <!--end-toc-->
    </nav>

    <h2 id="context"><span class="secno">1. </span>简介</h2>

    <p>选择器级别 1 和选择器级别 2 定义为在 <a href="https://www.w3.org/TR/REC-CSS1">CSS1</a> 和 <a
            href="https://www.w3.org/TR/CSS21/">CSS2.1</a> 规范中定义的选择器功能的子集，
        分别。


    <h3 id=dependencies><span class=secno>1.1. </span>依赖关系</h3>

    <p>本规范中的某些功能特定于CSS，或具有CSS特有的限制或规则。在本规范中，这些内容已根据CSS2.1进行了描述。<a href="#ref-CSS21">[CSS21]<!--{{!CSS21}}--></a>

    <h3 id=terminology><span class=secno>1.2. </span>术语</h3>

    <p>本规范的所有文本都是规范性的，除了示例、注释和明确标记为非规范性的部分。

    <p>附加术语在<a href="https://www.w3.org/TR/CSS21/conform.html#defs">定义</a>部分中进行了定义。<a
            href="#ref-CSS21">[CSS21]<!--{{!CSS21}}--></a> 文档源代码和片段示例以 XML <a
            href="#ref-XML10">[XML10]<!--{{XML10}}--></a> 或 HTML <a
            href="#ref-HTML401">[HTML401]<!--{{HTML401}}--></a><a href="#ref-HTML5">[HTML5]<!--{{HTML5}}--></a> 语法提供。

    <h3 id=changesFromCSS2><span class=secno>1.3. </span>与 CSS2 的变化</h3>

    <p><em>本节为非规范性内容。</em>

    <p>CSS2中的选择器与本规范中的选择器之间的主要区别包括：

    <ul>
        <li>基本定义列表（选择器、选择器组、简单选择器等）已更改；特别是，CSS2中称为简单选择器的内容现在称为简单选择器序列，而“简单选择器”一词现在用于此序列的组件

        <li>元素类型选择器、通用选择器和属性选择器现在允许可选的命名空间组件

        <li>引入了<a href="#general-sibling-combinators">新组合器</a>

        <li>新的简单选择器，包括子串匹配属性选择器，以及新的伪类

        <li>新的伪元素，并引入了 "::" 伪元素表示法

        <li>语法已重新编写

        <li>将配置文件添加到集成选择器的规范中，并定义每个规范实际支持的选择器集

        <li>选择器现在是一个CSS3模块和独立的规范；其他规范现在可以独立于CSS引用本文档

        <li>该规范现在有自己的测试套件
    </ul>


    <h2 id=selectors><span class=secno>2. </span>选择器</h2>

    <p><em>本节为非规范性内容，仅总结了以下部分。</em>

    <p>选择器代表一种结构。该结构可以作为一种条件（例如在CSS规则中），决定选择器在文档树中匹配哪些元素，或作为与该结构相对应的HTML或XML片段的扁平描述。

    <p>选择器可以从简单的元素名称到丰富的上下文表示。

    <p>下表总结了选择器的语法：

    <table class=selectorsReview>
        <thead>
            <tr>
                <th class=pattern>模式

                <th class=meaning>表示

                <th class=described>描述

                <th class=origin>级别

        <tbody>
            <tr>
                <td class=pattern>*

                <td class=meaning>任何元素

                <td class=described><a href="#universal-selector">通用选择器</a>

                <td class=origin>2

            <tr>
                <td class=pattern>E

                <td class=meaning>类型为E的元素

                <td class=described><a href="#type-selectors">类型选择器</a>

                <td class=origin>1

            <tr>
                <td class=pattern>E[foo]

                <td class=meaning>具有“foo”属性的E元素

                <td class=described><a href="#attribute-selectors">属性选择器</a>

                <td class=origin>2

            <tr>
                <td class=pattern>E[foo="bar"]

                <td class=meaning>“foo”属性值完全等于“bar”的E元素

                <td class=described><a href="#attribute-selectors">属性选择器</a>

                <td class=origin>2

            <tr>
                <td class=pattern>E[foo~="bar"]

                <td class=meaning>“foo”属性值是一个以空格分隔的值列表，其中之一完全等于“bar”的E元素

                <td class=described><a href="#attribute-selectors">属性选择器</a>

                <td class=origin>2

            <tr>
                <td class=pattern>E[foo^="bar"]

                <td class=meaning>“foo”属性值以字符串“bar”开头的E元素

                <td class=described><a href="#attribute-selectors">属性选择器</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E[foo$="bar"]

                <td class=meaning>“foo”属性值以字符串“bar”结尾的E元素

                <td class=described><a href="#attribute-selectors">属性选择器</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E[foo*="bar"]

                <td class=meaning>“foo”属性值包含子字符串“bar”的E元素

                <td class=described><a href="#attribute-selectors">属性选择器</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E[foo|="en"]

                <td class=meaning>“foo”属性具有以连字符分隔的值列表，并以“en”开头（从左边开始）的E元素

                <td class=described><a href="#attribute-selectors">属性选择器</a>

                <td class=origin>2

            <tr>
                <td class=pattern>E:root

                <td class=meaning>文档的根元素E

                <td class=described><a href="#structural-pseudos">结构伪类</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E:nth-child(n)

                <td class=meaning>父元素的第n个子元素E

                <td class=described><a href="#structural-pseudos">结构伪类</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E:nth-last-child(n)

                <td class=meaning>父元素的倒数第n个子元素E

                <td class=described><a href="#structural-pseudos">结构伪类</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E:nth-of-type(n)

                <td class=meaning>其类型的第n个兄弟元素E

                <td class=described><a href="#structural-pseudos">结构伪类</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E:nth-last-of-type(n)

                <td class=meaning>其类型的倒数第n个兄弟元素E

                <td class=described><a href="#structural-pseudos">结构伪类</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E:first-child

                <td class=meaning>父元素的第一个子元素E

                <td class=described><a href="#structural-pseudos">结构伪类</a>

                <td class=origin>2

            <tr>
                <td class=pattern>E:last-child

                <td class=meaning>父元素的最后一个子元素E

                <td class=described><a href="#structural-pseudos">结构伪类</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E:first-of-type

                <td class=meaning>其类型的第一个兄弟元素E

                <td class=described><a href="#structural-pseudos">结构伪类</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E:last-of-type

                <td class=meaning>其类型的最后一个兄弟元素E

                <td class=described><a href="#structural-pseudos">结构伪类</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E:only-child

                <td class=meaning>父元素的唯一子元素E

                <td class=described><a href="#structural-pseudos">结构伪类</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E:only-of-type

                <td class=meaning>其类型的唯一兄弟元素E

                <td class=described><a href="#structural-pseudos">结构伪类</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E:empty

                <td class=meaning>没有子元素（包括文本节点）的E元素

                <td class=described><a href="#structural-pseudos">结构伪类</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E:link<br>
                    E:visited

                <td class=meaning>作为超链接的源锚点的E元素，其目标尚未访问(:link)或已访问(:visited)

                <td class=described><a href="#link">链接伪类</a>

                <td class=origin>1

            <tr>
                <td class=pattern>E:active<br>
                    E:hover<br>
                    E:focus

                <td class=meaning>在某些用户操作期间的E元素

                <td class=described><a href="#useraction-pseudos">用户操作伪类</a>

                <td class=origin>1 和 2

            <tr>
                <td class=pattern>E:target

                <td class=meaning>作为引用URI目标的E元素

                <td class=described><a href="#target-pseudo">目标伪类</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E:lang(fr)

                <td class=meaning>语言为“fr”的E类型元素（文档语言规定了如何确定语言）

                <td class=described><a href="#lang-pseudo">:lang() 伪类</a>

                <td class=origin>2

            <tr>
                <td class=pattern>E:enabled<br>
                    E:disabled

                <td class=meaning>启用或禁用的用户界面元素E

                <td class=described><a href="#UIstates">UI元素状态伪类</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E:checked<!--<br>E:indeterminate-->

                <td class=meaning>选中的用户界面元素E<!--或处于不确定状态-->(例如单选按钮或复选框)

                <td class=described><a href="#UIstates">UI元素状态伪类</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E::first-line

                <td class=meaning>E元素的第一个格式化行

                <td class=described><a href="#first-line">::first-line 伪元素</a>

                <td class=origin>1

            <tr>
                <td class=pattern>E::first-letter

                <td class=meaning>E元素的第一个格式化字母

                <td class=described><a href="#first-letter">::first-letter 伪元素</a>

                <td class=origin>1

            <tr>
                <td class=pattern>E::before

                <td class=meaning>E元素之前生成的内容

                <td class=described><a href="#gen-content">::before 伪元素</a>

                <td class=origin>2

            <tr>
                <td class=pattern>E::after

                <td class=meaning>E元素之后生成的内容

                <td class=described><a href="#gen-content">::after 伪元素</a>

                <td class=origin>2

            <tr>
                <td class=pattern>E.warning

                <td class=meaning>类为“warning”的E元素（文档语言规定了如何确定类）

                <td class=described><a href="#class-html">类选择器</a>

                <td class=origin>1

            <tr>
                <td class=pattern>E#myid

                <td class=meaning>ID为“myid”的E元素

                <td class=described><a href="#id-selectors">ID选择器</a>

                <td class=origin>1

            <tr>
                <td class=pattern>E:not(s)

                <td class=meaning>不匹配简单选择器s的E元素

                <td class=described><a href="#negation">否定伪类</a>

                <td class=origin>3

            <tr>
                <td class=pattern>E F

                <td class=meaning>E元素的后代F元素

                <td class=described><a href="#descendant-combinators">后代组合器</a>

                <td class=origin>1

            <tr>
                <td class=pattern>E &gt; F

                <td class=meaning>E元素的子元素F

                <td class=described><a href="#child-combinators">子代组合器</a>

                <td class=origin>2

            <tr>
                <td class=pattern>E + F

                <td class=meaning>紧接在E元素之后的F元素

                <td class=described><a href="#adjacent-sibling-combinators">相邻兄弟组合器</a>

                <td class=origin>2

            <tr>
                <td class=pattern>E ~ F

                <td class=meaning>紧接在E元素之后的F元素

                <td class=described><a href="#general-sibling-combinators">普通兄弟组合器</a>

                <td class=origin>3
    </table>

    <h2 id=casesens><span class=secno>3. </span>区分大小写</h2>

    <p>在ASCII范围内，所有选择器语法都是不区分大小写的（即[a-z]和[A-Z]是等效的），除了那些不受选择器控制的部分。选择器中文档语言元素名称、属性名称和属性值的大小写敏感性取决于文档语言。例如，在HTML中，元素名称不区分大小写，但在XML中，它们区分大小写。命名空间前缀的大小写敏感性在<a
            href="#ref-CSS3NAMESPACE">[CSS3NAMESPACE]<!--{{!CSS3NAMESPACE}}--></a>中定义。

    <h2 id=selector-syntax><span class=secno>4. </span>选择器语法</h2>

    <p><dfn id=selector>选择器</dfn>是由一个或多个<a href="#sequence">简单选择器序列</a>组成的链条，它们由<a href="#combinators">组合器</a>分隔。一个<a
            href="#pseudo-elements">伪元素</a>可以附加到选择器中最后一个简单选择器序列的末尾。

    <p><dfn id=sequence-of-simple-selectors><a id=sequence>简单选择器序列</a></dfn>是一串<a
            href="#simple-selectors-dfn">简单选择器</a>，它们之间没有<a href="#combinators">组合器</a>分隔。它总是以<a
            href="#type-selectors">类型选择器</a>或<a href="#universal-selector">通用选择器</a>开头。序列中不允许使用其他类型选择器或通用选择器。

    <p><dfn id=simple-selector><a id=simple-selectors-dfn></a><a href="#simple-selectors">简单选择器</a></dfn>可以是<a
            href="#type-selectors">类型选择器</a>、<a href="#universal-selector">通用选择器</a>、<a
            href="#attribute-selectors">属性选择器</a>、<a href="#class-html">类选择器</a>、<a href="#id-selectors">ID选择器</a>或<a
            href="#pseudo-classes">伪类</a>。

    <p><dfn
            id=combinators0>组合器</dfn>包括：空格、“大于号”（U+003E，<code>&gt;</code>）、“加号”（U+002B，<code>+</code>）和“波浪号”（U+007E，<code>~</code>）。空格可以出现在组合器与其周围的简单选择器之间。<a
            id=whitespace></a>空格中只包含“空格”（U+0020）、“制表符”（U+0009）、“换行符”（U+000A）、“回车符”（U+000D）和“换页符”（U+000C）。其他类似空格的字符，如“em-space”（U+2003）和“汉字空格”（U+3000），从不属于空格的一部分。

    <p>文档树中由选择器表示的元素是选择器的<dfn id=subjects-of-the-selector><a
                id=subject></a>主语</dfn>。由单个简单选择器序列组成的选择器表示满足其要求的任何元素。将另一个简单选择器序列和组合器前置于一个序列之前会增加额外的匹配约束，因此选择器的主语始终是由最后一个简单选择器序列表示的元素的子集。

    <p>空选择器（不包含简单选择器序列和伪元素）是<a href="#Conformance">无效选择器</a>。

    <p>选择器中的字符可以按照与CSS相同的<a href="https://www.w3.org/TR/CSS21/syndata.html#characters">转义规则</a>用反斜杠进行转义。<a
            href="#ref-CSS21">[CSS21]<!--{{!CSS21}}--></a>。

    <p id=nsdecl>某些选择器支持命名空间前缀。声明命名空间前缀的机制应由使用选择器的语言指定。如果语言未指定命名空间前缀声明机制，则不声明任何前缀。在CSS中，命名空间前缀通过<a
            href="https://www.w3.org/TR/css3-namespace/#declaration"><code>@namespace</code></a>规则声明。<a
            href="#ref-CSS3NAMESPACE">[CSS3NAMESPACE]<!--{{!CSS3NAMESPACE}}--></a>

    <h2 id=grouping><span class=secno>5. </span>选择器组</h2>

    <p>用逗号分隔的选择器列表表示列表中每个单独选择器选择的所有元素的并集。（逗号为U+002C。）例如，在CSS中，当多个选择器共享相同的声明时，它们可以组合成一个用逗号分隔的列表。逗号前后可以出现空格。

    <div class=example>
        <p>CSS示例：

        <p>在此示例中，我们将三个具有相同声明的规则简化为一个。因此，

        <pre>h1 { font-family: sans-serif }
h2 { font-family: sans-serif }
h3 { font-family: sans-serif }</pre>

        <p>等价于：

        <pre>h1, h2, h3 { font-family: sans-serif }</pre>
    </div>

    <p><strong>警告</strong>：此示例中的等价性成立是因为所有选择器都是有效选择器。如果其中一个选择器无效，则整个选择器组将无效。这会使所有三个标题元素的规则无效，而在前一种情况下，只有其中一个标题规则会失效。

    <div class=example>
        <p>无效的CSS示例：

        <pre>h1 { font-family: sans-serif }
h2..foo { font-family: sans-serif }
h3 { font-family: sans-serif }</pre>

        <p>不等价于：

        <pre>h1, h2..foo, h3 { font-family: sans-serif }</pre>

        <p>因为上述选择器（<code>h1, h2..foo, h3</code>）完全无效，并且整个样式规则将被丢弃。（当选择器未组合时，只有<code>h2..foo</code>的规则会被丢弃。）
    </div>

    <h2 id=simple-selectors><span class=secno>6. </span>简单选择器</h2>

    <h3 id=type-selectors><span class=secno>6.1. </span>类型选择器</h3>

    <p><dfn id=type-selector>类型选择器</dfn>是使用<a href="https://www.w3.org/TR/css3-namespace/#css-qnames">CSS
            合格名称</a>语法编写的文档语言元素类型名称。<a
            href="#ref-CSS3NAMESPACE">[CSS3NAMESPACE]<!--{{!CSS3NAMESPACE}}--></a>。类型选择器表示文档树中元素类型的一个实例。

    <div class=example>
        <p>示例：

        <p>以下选择器表示文档树中的<code>h1</code>元素：

        <pre>h1</pre>
    </div>

    <h4 id=typenmsp><span class=secno>6.1.1. </span>类型选择器和命名空间</h4>

    <p>类型选择器允许使用可选的命名空间组件：可以在元素名称前附加一个之前<a href="#nsdecl">声明</a>的命名空间前缀，并通过命名空间分隔符“竖线”（U+007C，<code>|</code>）分隔。（参见例如<a
            href="#ref-XML-NAMES">[XML-NAMES]<!--{{XML-NAMES}}--></a>了解在XML中使用命名空间。）

    <p>命名空间组件可以为空（命名空间分隔符前没有前缀），表示选择器仅代表没有命名空间的元素。

    <p>可以使用星号作为命名空间前缀，表示选择器代表任何命名空间中的元素（包括没有命名空间的元素）。

    <p>没有命名空间组件（没有命名空间分隔符）的元素类型选择器表示不考虑元素命名空间的元素（相当于“<code>*|</code>”），除非已为命名空间选择器<a
            href="#nsdecl">声明</a>默认命名空间（例如在CSS中，在样式表中）。如果已声明默认命名空间，则此类选择器将仅表示默认命名空间中的元素。

    <p>包含未为命名空间选择器<a href="#nsdecl">声明</a>过的命名空间前缀的类型选择器是<a href="#Conformance">无效</a>选择器。

    <p>在支持命名空间的客户端中，元素类型选择器的名称部分（如果存在，则是命名空间分隔符后的部分）只会与元素的<a
            href="https://www.w3.org/TR/REC-xml-names/#NT-LocalPart">本地部分</a>匹配<a
            href="https://www.w3.org/TR/REC-xml-names/#ns-qualnames">合格名称</a>。

    <p>总结如下：

    <dl>
        <dt><code>ns|E</code>

        <dd>命名空间ns中名称为E的元素

        <dt><code>*|E</code>

        <dd>任何命名空间中名称为E的元素，包括没有命名空间的元素

        <dt><code>|E</code>

        <dd>没有命名空间的名称为E的元素

        <dt><code>E</code>

        <dd>如果没有为选择器<a href="#nsdecl">声明</a>默认命名空间，这相当于*|E。否则相当于ns|E，其中ns是默认命名空间。
    </dl>

    <div class=example>
        <p>CSS 示例：

        <pre>@namespace foo url(http://www.example.com);
 foo|h1 { color: blue }  /* 第一条规则 */
 foo|* { color: yellow } /* 第二条规则 */
 |h1 { color: red }      /* ...*/
 *|h1 { color: green }
 h1 { color: green }</pre>

        <p>第一条规则（不包括<code>@namespace</code> at规则）将仅匹配"http://www.example.com"命名空间中的<code>h1</code>元素。

        <p>第二条规则将匹配"http://www.example.com"命名空间中的所有元素。

        <p>第三条规则将仅匹配没有命名空间的<code>h1</code>元素。

        <p>第四条规则将匹配任何命名空间（包括没有命名空间）的<code>h1</code>元素。

        <p>由于未定义默认命名空间，因此最后一条规则等同于第四条规则。
    </div>

    <h3 id=universal-selector><span class=secno>6.2. </span>通用选择器</h3>

    <p><dfn id=universal-selector0>通用选择器</dfn>，写作<a href="https://www.w3.org/TR/css3-namespace/#css-qnames">CSS 合格名称</a>
        <a href="#ref-CSS3NAMESPACE">[CSS3NAMESPACE]<!--{{!CSS3NAMESPACE}}--></a>，其本地名称为星号（<dfn data-dfn-type=selector
            data-export=data-export id=x>*</dfn>
        U+002A），代表任何元素类型的合格名称。如果未为选择器指定默认命名空间，则它代表文档树中任何命名空间（包括没有命名空间的元素）中的任何单个元素。如果已指定默认命名空间，请参见下文<a
            href="#univnmsp">通用选择器和命名空间</a>。

    <p>如果由<code>*</code>表示的通用选择器（即没有命名空间前缀）不是<a href="#sequence">简单选择器序列</a>的唯一组件或紧跟在<a
            href="#pseudo-elements">伪元素</a>之后，则可以省略<code>*</code>，并暗示通用选择器的存在。

    <div class=example>
        <p>示例：

        <ul>
            <li><code>*[hreflang|=en]</code>和<code>[hreflang|=en]</code>是等效的，

            <li><code>*.warning</code>和<code>.warning</code>是等效的，

            <li><code>*#myid</code>和<code>#myid</code>是等效的。
        </ul>
    </div>

    <p class=note><strong>注意：</strong>建议不要省略<code>*</code>，因为这会减少例如<code
            style="white-space: nowrap">div :first-child</code>和<code
            style="white-space: nowrap">div:first-child</code>之间的潜在混淆。在这种情况下，<code
            style="white-space: nowrap">div *:first-child</code>更具可读性。

    <h4 id=univnmsp><span class=secno>6.2.1. </span>通用选择器和命名空间</h4>

    <p>通用选择器允许使用可选的命名空间组件。使用方式如下：

    <dl>
        <dt><code>ns|*</code>

        <dd>命名空间 ns 中的所有元素

        <dt><code>*|*</code>

        <dd>所有元素

        <dt><code>|*</code>

        <dd>没有命名空间的所有元素

        <dt><code>*</code>

        <dd>如果未指定默认命名空间，这相当于 *|*。否则相当于 ns|*，其中 ns 是默认命名空间。
    </dl>

    <p>包含未<a href="#nsdecl">声明</a>的命名空间前缀的通用选择器是<a href="#Conformance">无效</a>选择器。

    <h3 id=attribute-selectors><span class=secno>6.3. </span>属性选择器</h3>

    <p>选择器允许表示元素的属性。当选择器用作与元素匹配的表达式时，如果该元素具有与属性选择器表示的属性匹配的属性，则必须将属性选择器视为匹配元素。

    <h4 id=attribute-representation><span class=secno>6.3.1. </span>属性存在与值选择器</h4>

    <p>CSS2 引入了四种属性选择器：

    <dl>
        <dt><code>[att]</code>

        <dd>表示具有<code>att</code>属性的元素，无论属性的值如何。

        <dt><code>[att=val]</code>

        <dd>表示具有<code>att</code>属性且值正好为"val"的元素。

        <dt><code>[att~=val]</code>

        <dd>表示具有<code>att</code>属性且值为<a
                href="#whitespace">空格</a>分隔的单词列表的元素，其中之一正好为"val"。如果"val"包含空格，它将永远不会表示任何内容（因为单词是由空格<em>分隔的</em>）。此外，如果"val"是空字符串，它将永远不会表示任何内容。

        <dt><code>[att|=val]</code>

        <dd>表示具有<code>att</code>属性的元素，其值要么正好为"val"，要么以"val"开头，紧跟"-"（U+002D）。这主要用于允许语言子代码匹配（例如，HTML
            中的<code>a</code>元素上的<code>hreflang</code>属性），如 BCP 47 中所述（<a
                href="#ref-BCP47">[BCP47]<!--{{BCP47}}--></a>）或其后续版本。有关<code>lang</code>（或<code>xml:lang</code>）语言子代码匹配的更多信息，请参见<a
                href="#lang-pseudo"><code>:lang</code>伪类</a>。
    </dl>

    <p>属性值必须是 CSS <a href="https://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">标识符</a>或<a
            href="https://www.w3.org/TR/CSS21/syndata.html#strings">字符串</a>。<a
            href="#ref-CSS21">[CSS21]<!--{{!CSS21}}--></a> 选择器中属性名称和值的大小写敏感性取决于文档语言。

    <div class=example>
        <p>示例：

        <p>以下属性选择器表示带有<code>title</code>属性的<code>h1</code>元素，无论其值如何：

        <pre>h1[title]</pre>

        <p>在以下示例中，选择器表示一个<code>span</code>元素，其<code>class</code>属性的值正好为"example"：

        <pre>span[class="example"]</pre>

        <p>可以使用多个属性选择器来表示元素的多个属性，或对同一属性的多个条件。在此，选择器表示一个<code>span</code>元素，其<code>hello</code>属性的值正好为"Cleveland"，并且其<code>goodbye</code>属性的值正好为"Columbus"：

        <pre>span[hello="Cleveland"][goodbye="Columbus"]</pre>

        <p>以下 CSS 规则说明了"="和"~="之间的区别。第一个选择器将匹配例如具有<code>rel</code>属性值为"copyright copyleft
            copyeditor"的<code>a</code>元素。第二个选择器只会匹配<code>href</code>属性值正好为"http://www.w3.org/"的<code>a</code>元素。

        <pre>a[rel~="copyright"] { ... }
a[href="http://www.w3.org/"] { ... }</pre>

        <p>以下选择器表示<code>hreflang</code>属性值正好为"fr"的<code>a</code>元素。

        <pre>a[hreflang=fr]</pre>

        <p>以下选择器表示<code>hreflang</code>属性值以"en"开头的<code>a</code>元素，包括"en"、"en-US"和"en-scouse"：

        <pre>a[hreflang|="en"]</pre>

        <p>以下选择器表示<code>DIALOGUE</code>元素，只要它的<code>character</code>属性具有两种不同的值之一：

        <pre>DIALOGUE[character=romeo]
DIALOGUE[character=juliet]</pre>
    </div>

    <h4 id=attribute-substrings><span class=secno>6.3.2. </span>子字符串匹配属性选择器</h4>

    <p>提供了三个额外的属性选择器，用于匹配属性值中的子字符串：

    <dl>
        <dt><code>[att^=val]</code>

        <dd>表示具有<code>att</code>属性且值以前缀"val"开头的元素。如果"val"是空字符串，则选择器不表示任何内容。

        <dt><code>[att$=val]</code>

        <dd>表示具有<code>att</code>属性且值以后缀"val"结尾的元素。如果"val"是空字符串，则选择器不表示任何内容。

        <dt><code>[att*=val]</code>

        <dd>表示具有<code>att</code>属性且值中至少包含一个"val"子字符串的元素。如果"val"是空字符串，则选择器不表示任何内容。
    </dl>

    <p>属性值必须是 CSS <a href="https://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">标识符</a>或<a
            href="https://www.w3.org/TR/CSS21/syndata.html#strings">字符串</a>。<a
            href="#ref-CSS21">[CSS21]<!--{{!CSS21}}--></a> 选择器中属性名称的大小写敏感性取决于文档语言。

    <div class=example>
        <p>示例：

        <p>以下选择器表示引用图像的 HTML <code>object</code>：

        <pre>object[type^="image/"]</pre>

        <p>以下选择器表示<code>href</code>属性值以“.html”结尾的 HTML 锚点<code>a</code>：

        <pre>a[href$=".html"]</pre>

        <p>以下选择器表示<code>title</code>属性值包含子字符串"hello"的 HTML 段落：

        <pre>p[title*="hello"]</pre>
    </div>

    <h4 id=attrnmsp><span class=secno>6.3.3. </span>属性选择器和命名空间</h4>

    <p>属性选择器中的属性名称以<a href="https://www.w3.org/TR/css3-namespace/#css-qnames">CSS 合格名称</a>形式给出：可以在属性名称前附加一个之前<a
            href="#nsdecl">声明</a>的命名空间前缀，并通过命名空间分隔符“竖线” (<code>|</code>) 分隔。根据 XML
        推荐规范中的命名空间，默认命名空间不适用于属性，因此没有命名空间组件的属性选择器仅适用于没有命名空间的属性（相当于"<code>|attr</code>"）。可以使用星号作为命名空间前缀，表示选择器将匹配所有属性名称，而不考虑属性的命名空间。

    <p>包含尚未<a href="#nsdecl">声明</a>的命名空间前缀的属性名称的属性选择器是<a href="#Conformance">无效</a>选择器。

    <div class=example>
        <p>CSS 示例：

        <pre>@namespace foo "http://www.example.com";
[foo|att=val] { color: blue }
[*|att] { color: yellow }
[|att] { color: green }
[att] { color: green }</pre>

        <p>第一条规则将只匹配"att"属性位于"http://www.example.com"命名空间且值为"val"的元素。

        <p>第二条规则将匹配具有"att"属性的所有元素，而不考虑属性的命名空间（包括没有命名空间的情况）。

        <p>最后两条规则是等效的，并且只匹配属性<code>att</code>不在命名空间中的元素。
    </div>

    <h4 id=def-values><span class=secno>6.3.4. </span>DTD 中的默认属性值</h4>

    <p>属性选择器表示文档树中的属性值。如何构建文档树超出了选择器的范围。在某些文档格式中，默认属性值可以在 DTD
        或其他地方定义，但只有当这些默认值出现在文档树中时，它们才能被属性选择器选择。选择器的设计应确保无论默认值是否包含在文档树中，都能正常工作。

    <p>例如，XML UA 可以但<strong>不</strong>要求读取 DTD 的“外部子集”，但<strong>要求</strong>在文档的“内部子集”中查找默认属性值。（例如，参见<a
            href="#ref-XML10">[XML10]<!--{{XML10}}--></a> 以了解这些子集的定义。）根据 UA 的不同，DTD 的外部子集中定义的默认属性值可能会或可能不会出现在文档树中。

    <p>支持 XML 命名空间的 UA 可以但<strong>不</strong>要求使用其对该命名空间的了解来将默认属性值视为存在于文档中。（例如，XHTML UA 并<strong>不</strong>要求使用其对 XHTML
        DTD 的内置知识。有关 XML 1.0 中命名空间的详细信息，请参见<a href="#ref-XML-NAMES">[XML-NAMES]<!--{{XML-NAMES}}--></a>。）

    <p class=note><strong>注意：</strong>通常，实施选择会忽略外部子集。这对应于 XML 规范中定义的非验证处理器的行为。

    <div class=example>
        <p>示例：

        <p>考虑一个带有<code>radix</code>属性的<code>EXAMPLE</code>元素，其默认值为<code>"decimal"</code>。DTD 片段可能为

        <pre class=dtd-example>&lt;!ATTLIST EXAMPLE radix (decimal,octal) "decimal"></pre>

        <p>如果样式表包含以下规则

        <pre>EXAMPLE[radix=decimal] { /*... 默认属性设置 ...*/ }
EXAMPLE[radix=octal]   { /*... 其他设置...*/ }</pre>

        <p>第一条规则可能不会匹配<code>radix</code>属性由默认设置而非显式设置的元素。为了捕获所有情况，必须删除默认值的属性选择器：

        <pre>EXAMPLE                { /*... 默认属性设置 ...*/ }
EXAMPLE[radix=octal]   { /*... 其他设置...*/ }</pre>

        <p>在此，因为选择器<code>EXAMPLE[radix=octal]</code>比单独的类型选择器更具体，因此第二条规则中的样式声明将覆盖第一条规则中的声明，用于<code>radix</code>属性值为<code>"octal"</code>的元素。必须小心确保所有仅适用于默认情况下的属性声明都在非默认情况下的样式规则中被覆盖。
    </div>

    <h3 id=class-html><span class=secno>6.4. </span>类选择器</h3>

    <p>在使用HTML时，作者可以使用“句点”符号（也称为“full
        stop”，U+002E，<code>.</code>）作为表示<code>class</code>属性的替代表示法<code>~=</code>。因此，对于HTML，<code>div.value</code>和<code>div[class~=value]</code>具有相同的含义。属性值必须紧跟在句点符号（<code>.</code>）之后。

    <p>如果UA具有命名空间特定的知识，能够确定哪个属性是相应命名空间的“class”属性，则UA可以在XML文档中应用使用句点（<code>.</code>）符号的选择器。一个这样的命名空间特定知识的示例是特定命名空间规范中的描述（例如，SVG
        1.1 <a href="#ref-SVG11">[SVG11]<!--{{SVG11}}--></a> 描述了 <a
            href="https://www.w3.org/TR/SVG11/styling.html#ClassAttribute">SVG 的 <code>class</code> 属性</a>
        及UA应该如何解释它，类似地，MathML <a href="#ref-MATHML3">[MATHML3]<!--{{MATHML3}}--></a> 描述了 <a
            href="https://www.w3.org/TR/MathML3/chapter2.html#fund.globatt">MathML 的 <code>class</code> 属性</a>。）

    <div class=example>
        <p>CSS示例：

        <p>我们可以为所有<code>class~="pastoral"</code>的元素分配样式信息，如下所示：

        <pre>*.pastoral { color: green }  /* 所有 class~=pastoral 的元素 */</pre>

        <p>或仅

        <pre>.pastoral { color: green }  /* 所有 class~=pastoral 的元素 */</pre>

        <p>以下内容仅为<code>class~="pastoral"</code>的H1元素分配样式：

        <pre>H1.pastoral { color: green }  /* class~=pastoral 的 H1 元素 */</pre>

        <p>根据这些规则，下面的第一个<code>H1</code>实例将不会是绿色的文本，而第二个将是绿色的文本：

        <pre>&lt;H1&gt;Not green&lt;/H1&gt;
&lt;H1 class="pastoral"&gt;Very green&lt;/H1&gt;</pre>

        <p>以下规则匹配任何<code>P</code>元素，其<code>class</code>属性被分配了包含<code>pastoral</code>和<code>marine</code>的以空格分隔的值列表：

        <pre>p.pastoral.marine { color: green }</pre>

        <p>当<code>class="pastoral blue aqua marine"</code>时，此规则匹配，但当<code>class="pastoral blue"</code>时不匹配。
    </div>

    <p class=note>
        <strong>注意：</strong>由于CSS赋予<code>class</code>属性相当大的权力，作者可以设计他们自己的“文档语言”，其基于几乎没有相关展示的元素（例如HTML中的<code>DIV</code>和<code>SPAN</code>），并通过<code>class</code>属性分配样式信息。作者应避免这种做法，因为文档语言的结构元素通常具有公认和接受的含义，而作者定义的类可能没有。

    <p class=note><strong>注意：</strong>如果一个元素有多个类属性，在搜索类之前，其值必须用空格连接在一起。截至目前，工作组尚未意识到可以达到这种情况的任何方式，因此，此行为在本规范中明确为非规范性的。

    <h3 id=id-selectors><span class=secno>6.5. </span>ID选择器</h3>

    <p>文档语言可能包含声明为ID类型的属性。ID类型属性的特殊之处在于，在符合规范的文档中，无论承载它们的元素类型如何，不能有两个具有相同值的ID类型属性；无论文档语言是什么，ID类型属性都可以用来唯一标识其元素。在HTML中，所有ID属性都命名为"id"；XML应用程序可能会以不同的方式命名ID属性，但相同的限制适用。

    <p>文档语言的ID类型属性允许作者为文档树中的一个元素实例分配标识符。ID选择器包含一个“井号”（U+0023，<code>#</code>），紧跟在ID值之后，该值必须是CSS <a
            href="https://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">标识符</a>。ID选择器表示具有与ID选择器中的标识符匹配的标识符的元素实例。

    <p>选择器不指定UA如何知道元素的ID类型属性。UA可以例如读取文档的DTD，将信息硬编码或询问用户。

    <div class=example>
        <p>示例：

        <p>以下ID选择器表示其ID类型属性值为“chapter1”的<code>h1</code>元素：

        <pre>h1#chapter1</pre>

        <p>以下ID选择器表示ID类型属性值为“chapter1”的任何元素：

        <pre>#chapter1</pre>

        <p>以下选择器表示ID类型属性值为“z98y”的任何元素。

        <pre>*#z98y</pre>
    </div>

    <p class=note><strong>注意：</strong>在XML 1.0中<a
            href="#ref-XML10">[XML10]<!--{{XML10}}--></a>，关于哪个属性包含元素的ID的信息包含在DTD或模式中。当解析XML时，UA并不总是读取DTD，因此可能不知道元素的ID是什么（尽管UA可能具有命名空间特定的知识，使其能够确定哪个属性是该命名空间的ID属性）。如果样式表作者知道或怀疑UA可能不知道元素的ID是什么，他应该改用普通属性选择器：<code>[name=p371]</code>代替<code>#p371</code>。

    <p>如果一个元素有多个ID属性，那么在ID选择器的目的下，所有这些属性都必须被视为该元素的ID。这种情况可以通过混合使用xml:id、DOM、XML DTDs和命名空间特定的知识来实现。

    <h3 id=pseudo-classes><span class=secno>6.6. </span>伪类</h3>

    <p>引入伪类的概念是为了允许基于文档树之外的信息或无法使用其他简单选择器表达的信息进行选择。

    <p>伪类总是由“冒号”（<code>:</code>）后跟伪类名称，后面可选地跟一个括号内的值组成。

    <p>伪类允许出现在选择器包含的所有简单选择器序列中。伪类可以出现在简单选择器序列中的任何位置，在前导类型选择器或通用选择器（可能省略）之后。伪类名称不区分大小写。有些伪类是互斥的，而另一些可以同时应用于同一个元素。伪类可以是动态的，这意味着元素在用户与文档交互时可能获得或失去伪类。

    <h4 id=dynamic-pseudos><span class=secno>6.6.1. </span>动态伪类</h4>

    <p>动态伪类根据元素的名称、属性或内容以外的特征对元素进行分类，原则上这些特征无法从文档树中推导出。

    <p>动态伪类不会出现在文档源或文档树中。

    <h5 id=the-link-pseudo-classes-link-and-visited><span class=secno>6.6.1.1. </span><a id=link>链接伪类：:link 和
            :visited</a></h5>

    <p>用户代理通常会将未访问的链接与以前访问过的链接显示得不同。选择器提供了伪类<dfn data-dfn-type=selector data-export=data-export
            id=sel-link>:link</dfn>和<dfn data-dfn-type=selector data-export=data-export
            id=sel-visited>:visited</dfn>来区分它们：

    <ul>
        <li><a href="#sel-link"><code>:link</code></a>伪类适用于尚未访问的链接。
        <li><a href="#sel-visited"><code>:visited</code></a>伪类适用于用户已访问的链接。
    </ul>

    <p>在一段时间后，用户代理可能会选择将访问过的链接返回到（未访问）“<a href="#sel-link"><code class=css>:link</code></a>”状态。

    <p>这两种状态是互斥的。

    <div class=example>
        <p>示例：

        <p>以下选择器表示已访问且带有<code>external</code>类的链接：

        <pre>a.external:visited</pre>
    </div>

    <p class=note><strong>注意：</strong>样式表作者可能会滥用:link 和 :visited 伪类，在未经用户同意的情况下确定用户访问过哪些网站。

    <p>因此，UA 可能会将所有链接视为未访问的链接，或实施其他措施，以在不同地呈现已访问和未访问链接的同时保护用户的隐私。

    <h5 id=the-user-action-pseudo-classes-hover-act><span class=secno>6.6.1.2. </span><a id=useraction-pseudos>用户操作伪类
            :hover, :active 和 :focus</a></h5>

    <p>交互式用户代理有时会根据用户操作更改渲染。选择器提供了三个伪类，用于选择用户正在操作的元素。

    <ul>
        <li><dfn data-dfn-type=selector data-export=data-export id=sel-hover>:hover</dfn>
            伪类适用于用户使用指针设备指示一个元素时，但不一定激活它。例如，当光标（鼠标指针）悬停在由元素生成的框上时，视觉用户代理可以应用此伪类。不支持<a
                href="https://www.w3.org/TR/CSS21/media.html#interactive-media-group">交互媒体</a>的用户代理不必支持此伪类。一些支持<a
                href="https://www.w3.org/TR/CSS21/media.html#interactive-media-group">交互媒体</a>的符合标准的用户代理可能无法支持此伪类（例如，不检测悬停的笔设备）。

        <li><dfn data-dfn-type=selector data-export=data-export id=sel-active>:active</dfn>
            伪类适用于用户激活一个元素时。例如，在用户按下鼠标按钮和释放它之间。在有多个鼠标按钮的系统上，<a href="#sel-active"><code>:active</code></a>
            仅适用于主按钮或主要激活按钮（通常是“左”鼠标按钮）及其任何别名。

        <li><dfn data-dfn-type=selector data-export=data-export id=sel-focus>:focus</dfn>
            伪类适用于具有焦点的元素（接受键盘或鼠标事件或其他形式的输入）。
    </ul>

    <p>文档语言或实现可能对哪些元素可以变为<a href="#sel-active"><code>:active</code></a>或获得<a
            href="#sel-focus"><code>:focus</code></a>有特定限制。

    <p>这些伪类不是互斥的。一个元素可以同时匹配多个伪类。

    <p>选择器没有定义一个元素的父元素是否也是“<a href="#sel-active"><code class=css>:active</code></a>”或“<a href="#sel-hover"><code
                class=css>:hover</code></a>”状态。

    <p class=note><strong>注意：</strong>如果元素处于“<a href="#sel-hover"><code
                class=css>:hover</code></a>”状态，因为其子元素被指针设备指定，那么可能会有一个不在指针设备下的元素也应用“<a href="#sel-hover"><code
                class=css>:hover</code></a>”。

    <div class=example>
        <p>示例：

        <pre>a:link    /* 未访问的链接 */
a:visited /* 已访问的链接 */
a:hover   /* 用户悬停 */
a:active  /* 活动链接 */</pre>

        <p>动态伪类组合的示例：

        <pre>a:focus
a:focus:hover</pre>

        <p>最后一个选择器匹配同时处于伪类 :focus 和伪类 :hover 的 <code>a</code> 元素。
    </div>

    <p class=note><strong>注意：</strong>一个元素可以同时是“<a href="#sel-link"><code class=css>:visited</code></a>”和“<a
            href="#sel-active"><code class=css>:active</code></a>”（或“<a href="#sel-link"><code
                class=css>:link</code></a>”和“<a href="#sel-active"><code class=css>:active</code></a>”）。

    <h4 id=target-pseudo><span class=secno>6.6.2. </span>目标伪类 :target</h4>

    <p>某些 URI 指向资源中的一个位置。这种 URI 以“井号”（#）结尾，后跟锚点标识符（称为片段标识符）。

    <p>带有片段标识符的 URI 链接到文档中的某个元素，该元素称为目标元素。例如，这里有一个指向 HTML 文档中名为 <code>section_2</code> 的锚点的 URI：

    <pre>http://example.com/html/top.html#section_2</pre>

    <p>目标元素可以通过 <dfn data-dfn-type=selector data-export=data-export id=sel-target>:target</dfn> 伪类表示。如果文档的 URI
        没有片段标识符，则该文档没有目标元素。

    <div class=example>
        <p>示例：

        <pre>p.note:target</pre>

        <p>此选择器表示类<code>note</code>的<code>p</code>元素，该元素是引用URI的目标元素。
    </div>

    <div class=example>
        <p>CSS 示例：

        <p>在此，如果存在目标元素，使用 <a href="#sel-target"><code>:target</code></a> 伪类将目标元素设置为红色并在其前面放置一张图片：

        <pre>*:target { color : red }
*:target::before { content : url(target.png) }</pre>
    </div>

    <h4 id=lang-pseudo><span class=secno>6.6.3. </span>语言伪类 :lang</h4>

    <p>如果文档语言指定了如何确定元素的自然语言，则可以编写基于其语言表示元素的选择器。例如，在 HTML <a href="#ref-HTML401">[HTML401]<!--{{HTML401}}--></a> 中，语言由
        <code>lang</code> 属性和可能的信息（如 <code>meta</code> 元素或协议如 HTTP 头）组合确定。XML 使用名为 <code>xml:lang</code>
        的属性，可能还存在其他文档语言特定的方法来确定语言。

    <p>伪类 <dfn data-dfn-type=selector data-export=data-export data-lt=":lang" id=sel-lang>:lang(C)</dfn> 表示处于语言 C
        的元素。元素是否由 <code>:lang()</code> 选择器表示，仅基于元素的语言值（如果需要，规范化为 BCP 47 语法）是否等于标识符 C，或是否以标识符 C 开头并紧跟 "-"（U+002D）。在 ASCII
        范围内，C 与元素的语言值的匹配是大小写不敏感的。标识符 C 不必是有效的语言名称。

    <p>C 必须是有效的 CSS <a href="https://www.w3.org/TR/CSS21/syndata.html#value-def-identifier">标识符</a> <a
            href="#ref-CSS21">[CSS21]<!--{{!CSS21}}--></a>，且不能为空。（否则，选择器无效。）

    <p class=note><strong>注意：</strong>建议文档和协议使用 BCP 47 <a href="#ref-BCP47">[BCP47]<!--{{BCP47}}--></a> 或其后续版本中的代码，以及在基于
        XML 的文档中通过 "xml:lang" 属性指示语言 <a href="#ref-XML10">[XML10]<!--{{XML10}}--></a>。参见 <a
            href="https://www.w3.org/International/questions/qa-lang-2or3.en.html">"FAQ: 两个字母或三个字母的语言代码。"</a>

    <div class=example>
        <p>示例：

        <p>以下两个选择器表示在比利时法语或德语中的 HTML 文档。接下来的两个选择器表示在比利时法语或德语中任意元素内的 <code>q</code> 引用。

        <pre>html:lang(fr-be)
html:lang(de)
:lang(fr-be) &gt; q
:lang(de) &gt; q</pre>
    </div>

    <p><a href="#sel-lang"><code>:lang(C)</code></a> 与 "<code class=css>|=</code>" 运算符之间的区别在于 "<code
            class=css>|=</code>" 运算符仅针对元素上的给定属性进行比较，而 <a href="#sel-lang"><code>:lang(C)</code></a> 伪类使用 UA
        对文档语义的了解来进行比较。

    <div class=example>
        <p>在这个 HTML 示例中，只有 BODY 匹配 <code>[lang|=fr]</code>（因为它有一个 LANG 属性），但 BODY 和 P 都匹配
            <code>:lang(fr)</code>（因为两者都是法语）。P 不匹配 <code>[lang|=fr]</code>，因为它没有 LANG 属性。

        <pre>&lt;body lang=fr>
  &lt;p>Je suis français.&lt;/p>
&lt;/body></pre>
    </div>

    <h4 id=UIstates><span class=secno>6.6.4. </span>UI 元素状态伪类</h4>

    <h5 id=enableddisabled><span class=secno>6.6.4.1. </span>:enabled 和 :disabled 伪类</h5>

    <p><dfn data-dfn-type=selector data-export=data-export id=sel-enabled>:enabled</dfn>
        伪类表示处于启用状态的用户界面元素；这些元素具有相应的禁用状态。

    <p>相反，<dfn data-dfn-type=selector data-export=data-export id=sel-disabled>:disabled</dfn>
        伪类表示处于禁用状态的用户界面元素；这些元素具有相应的启用状态。

    <p>启用状态、禁用状态以及用户界面元素的定义取决于具体的语言。在典型的文档中，大多数元素既不匹配 <a href="#sel-enabled"><code>:enabled</code></a>，也不匹配 <a
            href="#sel-disabled"><code>:disabled</code></a>。

    <p class=note><strong>注意：</strong>可能影响用户与给定用户界面元素交互能力的 CSS 属性并不影响它是否匹配 <a
            href="#sel-enabled"><code>:enabled</code></a> 或 <a
            href="#sel-disabled"><code>:disabled</code></a>；例如，<code>display</code> 和 <code>visibility</code>
        属性对元素的启用/禁用状态没有影响。

    <h5 id=checked><span class=secno>6.6.4.2. </span>:checked 伪类</h5>

    <p>单选按钮和复选框元素可以由用户切换。一些菜单项在用户选择它们时被“选中”。当这些元素被切换为“开”时，<dfn data-dfn-type=selector data-export=data-export
            id=sel-checked>:checked</dfn> 伪类适用。虽然 <a href="#sel-checked"><code>:checked</code></a>
        伪类本质上是动态的，可以通过用户操作改变，但由于它也可以基于文档中的语义属性，因此适用于所有媒体。例如，<a href="#sel-checked"><code>:checked</code></a> 伪类最初适用于具有
        HTML4 中描述的 <code>selected</code> 和 <a href="#sel-checked"><code>checked</code></a> 属性的元素，但用户当然可以将这些元素切换为“关”，此时
        <a href="#sel-checked"><code>:checked</code></a> 伪类将不再适用。

    <h5 id=indeterminate><span class=secno>6.6.4.3. </span>:indeterminate 伪类</h5>

    <div class=note>
        <p><strong>注意：</strong>单选按钮和复选框元素可以由用户切换，但有时会处于不确定状态，既未选中也未取消选中。这可能是由于元素属性或 DOM 操作导致的。

        <p>本规范的未来版本可能会引入一个 <code>:indeterminate</code> 伪类，适用于这些元素。
            <!--While the <code>:indeterminate</code> pseudo-class is dynamic in nature, and is altered by user action, since it can also be based on the presence of an element attribute, it applies to all media.

<p>Components of a radio-group initialized with no pre-selected choice are an example of :indeterminate state.-->
    </div>

    <h4 id=structural-pseudos><span class=secno>6.6.5. </span>结构性伪类</h4>

    <p>选择器引入了<dfn id=structural-pseudo-classes>结构性伪类</dfn>的概念，以便基于存在于文档树中的额外信息进行选择，但这些信息不能通过其他简单选择器或组合器表示。

    <p>计算元素在其同级元素列表中的位置时，不计算独立的文本和其他非元素节点；索引编号从1开始。

    <h5 id=root-pseudo><span class=secno>6.6.5.1. </span>:root 伪类</h5>

    <p><dfn data-dfn-type=selector data-export=data-export id=sel-root>:root</dfn> 伪类表示文档的根元素。在 HTML 4 中，这始终是
        <code>HTML</code> 元素。

    <h5 id=nth-child-pseudo><span class=secno>6.6.5.2. </span>:nth-child() 伪类</h5>

    <p><dfn data-dfn-type=selector data-export=data-export data-lt=":nth-child()"
            id=sel-nth-child>:nth-child(<var>a</var><code>n</code>+<var>b</var>)</dfn> 伪类表示一个元素，该元素在文档树中有
        <var>a</var><code>n</code>+<var>b</var>-1 个同级元素位于其<a href="#sel-before"><strong>之前</strong></a>，对于任何正整数或零值的
        <code>n</code> 都有效。它不需要有父元素。对于 <var>a</var> 和 <var>b</var> 大于零的值，这实际上将元素的子元素分为 <var>a</var>
        个元素的组（最后一组取余数），并选择每组的第 <var>b</var> 个元素。例如，这允许选择器选择表中的每隔一行，并可以用于在四个周期中交替更改段落文本的颜色。<var>a</var> 和 <var>b</var>
        的值必须是整数（正数、负数或零）。元素的第一个子元素的索引为1。

    <p>此外，<code>:nth-child()</code> 还可以接受 ‘<code class=css><code>odd</code></code>’ 和 ‘<code
            class=css><code>even</code></code>’ 作为参数。‘<code class=css><code>odd</code></code>’ 的含义与 <code>2n+1</code>
        相同，‘<code class=css><code>even</code></code>’ 的含义与 <code>2n</code> 相同。

    <p><code>:nth-child()</code> 的参数必须符合以下语法，其中 <code>INTEGER</code> 与令牌 <code>[0-9]+</code> 匹配，其余的令牌化由第10.2节中的 <a
            href="#lex">词法扫描器</a> 提供：

    <pre>nth
  : S* [ ['-'|'+']? INTEGER? {N} [ S* ['-'|'+'] S* INTEGER ]? |
         ['-'|'+']? INTEGER | {O}{D}{D} | {E}{V}{E}{N} ] S*
  ;</pre>

    <div class=example>
        <p>示例：

        <pre>tr:nth-child(2n+1) /* 代表 HTML 表的每一奇数行 */
tr:nth-child(odd)  /* 同上 */
tr:nth-child(2n+0) /* 代表 HTML 表的每一偶数行 */
tr:nth-child(even) /* 同上 */

/* 在 CSS 中交替段落颜色 */
p:nth-child(4n+1) { color: navy; }
p:nth-child(4n+2) { color: green; }
p:nth-child(4n+3) { color: maroon; }
p:nth-child(4n+4) { color: purple; }</pre>
    </div>

    <p>当 <var>b</var> 值前面有负号时，表达式中的 "+" 字符必须移除（实际上用表示 <var>b</var> 的负值的 "-" 字符替换）。

    <div class=example>
        <p>示例：

        <pre>:nth-child(10n-1)  /* 代表第9、第19、第29个元素 */
:nth-child(10n+9)  /* 同上 */
:nth-child(10n+-1) /* 语法上无效，将被忽略 */</pre>
    </div>

    <p>当 <var>a</var>=0 时，<var>a</var><code>n</code> 部分无需包含（除非 <var>b</var> 部分已经被省略）。当未包含 <var>a</var><code>n</code> 且
        <var>b</var> 为非负值时，<code>+</code> 符号可以省略。在这种情况下，语法简化为 <code>:nth-child(<var>b</var>)</code>。

    <div class=example>
        <p>示例：

        <pre>foo:nth-child(0n+5)   /* 表示 foo 元素为其父元素的第5个子元素 */
foo:nth-child(5)      /* 同上 */</pre>
    </div>

    <p>当 <var>a</var>=1 或 <var>a</var>=-1 时，规则中的 <code>1</code> 可以省略。

    <div class=example>
        <p>示例：

        <p>以下选择器因此是等效的：

        <pre>bar:nth-child(1n+0)   /* 代表所有 bar 元素，特异性 (0,1,1) */
bar:nth-child(n+0)    /* 同上 */
bar:nth-child(n)      /* 同上 */
bar                   /* 同上但特异性较低 (0,0,1) */</pre>
    </div>

    <p>如果 <var>b</var>=0，则选择每 <var>a</var> 个元素中的每一个。在这种情况下，+<var>b</var>（或 -<var>b</var>）部分可以省略，除非 <var>a</var> 部分已经被省略。

    <div class=example>
        <p>示例：

        <pre>tr:nth-child(2n+0) /* 代表 HTML 表的每一偶数行 */
tr:nth-child(2n) /* 同上 */</pre>
    </div>

    <p>允许在 "(" 之后，")" 之前，以及 "+" 或 "-" 两侧存在空白字符，若两者都存在。

    <div class=example>
        <p>包含空白的有效示例：

        <pre>
:nth-child( 3n + 1 )
:nth-child( +3n - 2 )
:nth-child( -n+ 6)
:nth-child( +6 )
</pre>

        <p>包含空白的无效示例：

        <pre>
:nth-child(3 n)
:nth-child(+ 2n)
:nth-child(+ 2)
</pre>
    </div>

    <p>如果 <var>a</var> 和 <var>b</var> 都等于零，则伪类在文档树中不代表任何元素。

    <p><var>a</var> 的值可以是负数，但只有 <var>a</var><code>n</code>+<var>b</var> 的正值，针对 <code>n</code>≥0 的情况下，才能代表文档树中的某个元素。

    <div class=example>
        <p>示例：

        <pre>html|tr:nth-child(-n+6)  /* 表示 XHTML 表的前6行 */</pre>
    </div>

    <h5 id=nth-last-child-pseudo><span class=secno>6.6.5.3. </span>:nth-last-child() 伪类</h5>

    <p><dfn data-dfn-type=selector data-export=data-export data-lt=":nth-last-child()"
            id=sel-nth-last-child>:nth-last-child(<var>a</var>n+<var>b</var>)</dfn> 伪类表示一个元素，该元素在文档树中有
        <var>a</var><code>n</code>+<var>b</var>-1 个同级元素位于其<a href="#sel-after"><strong>之后</strong></a>，对于任何正整数或零值的
        <code>n</code> 都有效。它不需要有父元素。有关其参数的语法，请参见 <a href="#nth-child-pseudo"><code>:nth-child()</code></a> 伪类。它还接受
        ‘<code class=css><code>even</code></code>’ 和 ‘<code class=css><code>odd</code></code>’ 作为参数。

    <div class=example>
        <p>示例：

        <pre>tr:nth-last-child(-n+2)    /* 代表 HTML 表的最后两行 */

foo:nth-last-child(odd)    /* 代表其父元素中的所有奇数 foo 元素，从最后一个开始计数 */</pre>
    </div>

    <h5 id=nth-of-type-pseudo><span class=secno>6.6.5.4. </span>:nth-of-type() 伪类</h5>

    <p><dfn data-dfn-type=selector data-export=data-export data-lt=":nth-of-type()"
            id=sel-nth-of-type>:nth-of-type(<var>a</var>n+<var>b</var>)</dfn> 伪类表示一个元素，该元素在文档树中有
        <var>a</var><code>n</code>+<var>b</var>-1 个具有相同扩展元素名称的同级元素位于其<a
            href="#sel-before"><strong>之前</strong></a>，对于任何零值或正整数的 <code>n</code> 都有效。它不需要有父元素。有关其参数的语法，请参见 <a
            href="#nth-child-pseudo"><code>:nth-child()</code></a> 伪类。它还接受 ‘<code class=css><code>even</code></code>’ 和
        ‘<code class=css><code>odd</code></code>’ 作为参数。

    <div class=example>
        <p>CSS 示例：

        <p>这允许作者交替排列浮动图像的位置：

        <pre>img:nth-of-type(2n+1) { float: right; }
img:nth-of-type(2n) { float: left; }</pre>
    </div>

    <h5 id=nth-last-of-type-pseudo><span class=secno>6.6.5.5. </span>:nth-last-of-type() 伪类</h5>

    <p><dfn data-dfn-type=selector data-export=data-export data-lt=":nth-last-of-type()"
            id=sel-nth-last-of-type>:nth-last-of-type(<var>a</var>n+<var>b</var>)</dfn> 伪类表示一个元素，该元素在文档树中有
        <var>a</var><code>n</code>+<var>b</var>-1 个具有相同扩展元素名称的同级元素位于其<a
            href="#sel-after"><strong>之后</strong></a>，对于任何零值或正整数的 <code>n</code> 都有效。它不需要有父元素。有关其参数的语法，请参见 <a
            href="#nth-child-pseudo"><code>:nth-child()</code></a> 伪类。它还接受 ‘<code class=css><code>even</code></code>’ 和
        ‘<code class=css><code>odd</code></code>’ 作为参数。

    <div class=example>
        <p>示例：

        <p>要表示 XHTML <code>body</code> 中的所有 <code>h2</code> 子元素，除了第一个和最后一个，可以使用以下选择器：

        <pre>body &gt; h2:nth-of-type(n+2):nth-last-of-type(n+2)</pre>

        <p>在这种情况下，也可以使用 <code>:not()</code>，尽管选择器的长度相同：

        <pre>body &gt; h2:not(:first-of-type):not(:last-of-type)</pre>
    </div>

    <h5 id=first-child-pseudo><span class=secno>6.6.5.6. </span>:first-child 伪类</h5>

    <p>与 <code>:nth-child(1)</code> 相同。<dfn data-dfn-type=selector data-export=data-export
            id=sel-first-child>:first-child</dfn> 伪类表示作为同级元素列表中第一个的元素。

    <div class=example>
        <p>示例：

        <p>以下选择器表示作为 <code>div</code> 元素第一个子元素的 <code>p</code> 元素：

        <pre>div &gt; p:first-child</pre>

        <p>此选择器可以表示以下片段中的 <code>div</code> 内的 <code>p</code>：

        <pre>&lt;p&gt; The last P before the note.&lt;/p&gt;
&lt;div class="note"&gt;
   &lt;p&gt; The first P inside the note.&lt;/p&gt;
&lt;/div&gt;</pre>
        但不能表示以下片段中的第二个 <code>p</code>：
        <pre>&lt;p&gt; The last P before the note.&lt;/p&gt;
&lt;div class="note"&gt;
   &lt;h2&gt; Note &lt;/h2&gt;
   &lt;p&gt; The first P inside the note.&lt;/p&gt;
&lt;/div&gt;</pre>

        <p>以下两个选择器通常是等效的：

        <pre>* &gt; a:first-child /* a 是任何元素的第一个子元素 */
a:first-child /* 相同（假设 a 不是根元素） */</pre>
    </div>

    <h5 id=last-child-pseudo><span class=secno>6.6.5.7. </span>:last-child 伪类</h5>

    <p>与 <code>:nth-last-child(1)</code> 相同。<dfn data-dfn-type=selector data-export=data-export
            id=sel-last-child>:last-child</dfn> 伪类表示作为同级元素列表中最后一个的元素。

    <div class=example>
        <p>示例：

        <p>以下选择器表示作为有序列表 <code>ol</code> 中最后一个子元素的列表项 <code>li</code>。

        <pre>ol &gt; li:last-child</pre>
    </div>

    <h5 id=first-of-type-pseudo><span class=secno>6.6.5.8. </span>:first-of-type 伪类</h5>

    <p>与 <code>:nth-of-type(1)</code> 相同。<dfn data-dfn-type=selector data-export=data-export
            id=sel-first-of-type>:first-of-type</dfn> 伪类表示作为同级元素中第一个同类型元素的元素。

    <div class=example>
        <p>示例：

        <p>以下选择器表示定义列表 <code>dl</code> 中的定义标题 <code>dt</code>，该 <code>dt</code> 是其父元素子元素列表中的第一个同类型元素。

        <pre>dl dt:first-of-type</pre>

        <p>它有效表示以下示例中的前两个 <code>dt</code> 元素，但不适用于第三个：

        <pre>&lt;dl&gt;
 &lt;dt&gt;gigogne&lt;/dt&gt;
 &lt;dd&gt;
  &lt;dl&gt;
   &lt;dt&gt;fusée&lt;/dt&gt;
   &lt;dd&gt;multistage rocket&lt;/dd&gt;
   &lt;dt&gt;table&lt;/dt&gt;
   &lt;dd&gt;nest of tables&lt;/dd&gt;
  &lt;/dl&gt;
 &lt;/dd&gt;
&lt;/dl&gt;</pre>
    </div>

    <h5 id=last-of-type-pseudo><span class=secno>6.6.5.9. </span>:last-of-type 伪类</h5>

    <p>与 <code>:nth-last-of-type(1)</code> 相同。<dfn data-dfn-type=selector data-export=data-export
            id=sel-last-of-type>:last-of-type</dfn> 伪类表示作为同级元素中最后一个同类型元素的元素。

    <div class=example>
        <p>示例：

        <p>以下选择器表示表行 <code>tr</code> 的最后一个数据单元格 <code>td</code>。

        <pre>tr &gt; td:last-of-type</pre>
    </div>

    <h5 id=only-child-pseudo><span class=secno>6.6.5.10. </span>:only-child 伪类</h5>

    <p><dfn data-dfn-type=selector data-export=data-export id=sel-only-child>:only-child</dfn> 伪类表示没有兄弟姐妹的元素。与
        <code>:first-child:last-child</code> 或 <code>:nth-child(1):nth-last-child(1)</code> 相同，但特异性较低。

    <h5 id=only-of-type-pseudo><span class=secno>6.6.5.11. </span>:only-of-type 伪类</h5>

    <p><dfn data-dfn-type=selector data-export=data-export id=sel-only-of-type>:only-of-type</dfn> 伪类表示没有同类型兄弟姐妹的元素。与
        <code>:first-of-type:last-of-type</code> 或 <code>:nth-of-type(1):nth-last-of-type(1)</code> 相同，但特异性较低。

    <h5 id=empty-pseudo><span class=secno>6.6.5.12. </span>:empty 伪类</h5>

    <p><dfn data-dfn-type=selector data-export=data-export id=sel-empty>:empty</dfn> 伪类表示没有任何子元素的元素。在文档树中，只有元素节点和内容节点（如
        DOM <a href="#ref-DOM-LEVEL-3-CORE">[DOM-LEVEL-3-CORE]<!--{{DOM-LEVEL-3-CORE}}--></a> 文本节点、CDATA
        节点和实体引用）其数据长度非零时才会被认为影响空状态；注释、处理指令和其他节点不会影响元素是否被认为是空的。

    <div class=example>
        <p>示例：

        <p><code>p:empty</code> 是以下片段的有效表示：

        <pre>&lt;p&gt;&lt;/p&gt;</pre>

        <p><code>foo:empty</code> 不能有效表示以下片段：

        <pre>&lt;foo&gt;bar&lt;/foo&gt;</pre>

        <pre>&lt;foo&gt;&lt;bar&gt;bla&lt;/bar&gt;&lt;/foo&gt;</pre>

        <pre>&lt;foo&gt;this is not &lt;bar&gt;:empty&lt;/bar&gt;&lt;/foo&gt;</pre>
    </div>

    <h4 id=content-selectors><span class=secno>6.6.6. </span>空白</h4>
    <!-- It’s the Return of Appendix H!!! Run away! -->

    <p>本节故意留空。（本节之前定义了 <code>:contains()</code> 伪类。）</p>
    <!-- (used to be :contains()) -->

    <h4 id=negation><span class=secno>6.6.7. </span>否定伪类</h4>

    <p>否定伪类 <dfn data-dfn-type=selector data-export=data-export data-lt=":not()" id=sel-not>:not(<var>X</var>)</dfn>
        是一种功能性符号，接受<a href="#simple-selectors-dfn">简单选择器</a>（不包括否定伪类本身）作为参数。它表示不被其参数表示的元素。

    <p>否定伪类不能嵌套；<code>:not(:not(...))</code> 是无效的。此外，由于伪元素不是简单选择器，因此它们不能作为 <code>:not()</code> 的有效参数。

    <div class=example>
        <p>示例：

        <p>以下选择器匹配 HTML 文档中所有未禁用的 <code>button</code> 元素。

        <pre>button:not([DISABLED])</pre>

        <p>以下选择器表示除 <code>FOO</code> 元素之外的所有元素。

        <pre>*:not(FOO)</pre>

        <p>以下一组选择器表示除链接之外的所有 HTML 元素。

        <pre>html|*:not(:link):not(:visited)</pre>
    </div>

    <p>默认命名空间声明不会影响否定伪类的参数，除非该参数是通用选择器或类型选择器。

    <div class=example>
        <p>示例：

        <p>假设默认命名空间绑定到 "http://example.com/"，则以下选择器表示不在该命名空间中的所有元素：

        <pre>*|*:not(*)</pre>

        <p>以下选择器匹配任何未被悬停的元素，无论其命名空间如何。特别是，它不仅限于匹配默认命名空间中未被悬停的元素，而当不在默认命名空间中的元素被悬停时，它们也不会匹配规则。

        <pre>*|*:not(:hover)</pre>
    </div>

    <p class=note><strong>注意</strong>：:not() 伪类允许编写无用的选择器。例如 <code>:not(*|*)</code>，它不表示任何元素，或者
        <code>foo:not(bar)</code>，它等效于 <code>foo</code>，但具有更高的特异性。

    <h2 id=pseudo-elements><span class=secno>7. </span>伪元素</h2>

    <p>伪元素创建了关于文档树的抽象，超出了文档语言所指定的范围。例如，文档语言不提供访问元素内容的首字母或首行的机制。伪元素允许作者引用这些原本无法访问的信息。伪元素还可以为作者提供引用源文档中不存在的内容的方式（例如 <a
            href="#sel-before"><code>::before</code></a> 和 <a href="#sel-after"><code>::after</code></a> 伪元素可以访问生成的内容）。

    <p>伪元素由两个冒号（<code>::</code>）加上伪元素的名称组成。

    <p>当前文档引入了此 <code>::</code> 表记法，以区分伪类和伪元素。为了与现有样式表兼容，用户代理还必须接受在 CSS 第 1 和第 2 级中引入的伪元素的旧单冒号表记法（即 <a
            href="#sel-first-line"><code>:first-line</code></a>、<a
            href="#first-letter0"><code>:first-letter</code></a>、<a href="#sel-before"><code>:before</code></a> 和 <a
            href="#sel-after"><code>:after</code></a>）。此兼容性不适用于本规范中引入的新伪元素。

    <p>每个选择器中只能出现一个伪元素，并且如果存在伪元素，它必须出现在表示选择器<a href="#subject">主体</a>的简单选择器序列之后。<span
            class=note><strong>注意：</strong>未来版本的本规范可能允许每个选择器中使用多个伪元素。</span>

    <h3 id=first-line><span class=secno>7.1. </span>::first-line 伪元素</h3>

    <p><dfn data-dfn-type=selector data-export=data-export id=sel-first-line>::first-line</dfn> 伪元素描述了元素的第一行格式化内容。

    <div class=example>
        <p>CSS 示例：

        <pre>p::first-line { text-transform: uppercase }</pre>

        <p>上述规则的含义是“将每个 <code>p</code> 元素的第一行字母更改为大写”。

        <p>选择器 <code>p::first-line</code> 不匹配任何实际文档元素。它匹配的是符合要求的用户代理将在每个 <code>p</code> 元素的开头插入的伪元素。
    </div>

    <p>请注意，第一行的长度取决于多个因素，包括页面的宽度、字体大小等。因此，普通的 HTML 段落可能如下所示：

    <pre>
&lt;P&gt;This is a somewhat long HTML
paragraph that will be broken into several
lines. The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/P&gt;
</pre>

    <p>其行的分割方式如下：

    <pre>
THIS IS A SOMEWHAT LONG HTML PARAGRAPH THAT
will be broken into several lines. The first
line will be identified by a fictional tag
sequence. The other lines will be treated as
ordinary lines in the paragraph.
</pre>

    <p>用户代理可能会“重写”此段落，以包含<a href="#sel-first-line"><code>::first-line</code></a> 的<em>虚构标签序列</em>。此虚构标签序列有助于显示属性的继承。

    <pre>
&lt;P&gt;<b>&lt;P::first-line&gt;</b> This is a somewhat long HTML
paragraph that <b>&lt;/P::first-line&gt;</b> will be broken into several
lines. The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/P&gt;
</pre>

    <p>如果伪元素拆分了实际元素，所需效果通常可以通过关闭然后重新打开元素的虚构标签序列来描述。因此，如果我们使用 <code>span</code> 元素标记前面的段落：

    <pre>
&lt;P&gt;<b>&lt;SPAN class="test"&gt;</b> This is a somewhat long HTML
paragraph that will be broken into several
lines.<b>&lt;/SPAN&gt;</b> The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/P&gt;
</pre>

    <p>用户代理可以在插入<a href="#sel-first-line"><code>::first-line</code></a> 伪元素的虚构标签序列时，模拟 <code>span</code> 的开始和结束标签。

    <pre>
&lt;P&gt;&lt;P::first-line&gt;<b>&lt;SPAN class="test"&gt;</b> This is a
somewhat long HTML
paragraph that will <b>&lt;/SPAN&gt;</b>&lt;/P::first-line&gt;<b>&lt;SPAN class="test"&gt;</b> be
broken into several
lines.<b>&lt;/SPAN&gt;</b> The first line will be identified
by a fictional tag sequence. The other lines
will be treated as ordinary lines in the
paragraph.&lt;/P&gt;
</pre>

    <h4 id=first-formatted-line><span class=secno>7.1.1. </span>CSS 中的首行格式化定义</h4>

    <p>在 CSS 中，<a href="#sel-first-line"><code>::first-line</code></a>
        伪元素只能在附加到块状容器（例如块框、行内块、表格标题或表格单元格）时生效。在这种情况下，它指的是该容器的<dfn id=first-formatted-line0>首行格式化</dfn>内容。

    <p>元素的首行格式化内容可能出现在同一流中的块级后代中（即由于浮动或定位而不脱离文档流的块级后代）。例如，在 <code>&lt;DIV>&lt;P>This line...&lt;/P>&lt;/DIV></code>
        中，<code>DIV</code> 的第一行是 <code>P</code> 的第一行（假设 <code>P</code> 和 <code>DIV</code> 均为块级元素）。

    <p>表格单元格或行内块的第一行不能是祖先元素的首行格式化内容。因此，在
        <code>&lt;DIV&gt;&lt;P STYLE="display: inline-block">Hello&lt;BR&gt;Goodbye&lt;/P&gt; etcetera&lt;/DIV&gt;</code>
        中，<code>DIV</code> 的首行格式化内容不是“Hello”行。

    <p class=note><strong>注意：</strong>注意，此片段中的 <code>p</code> 的第一行：<code>&lt;p&gt;&lt;br&gt;First...</code> 不包含任何字母（假设
        <code>br</code> 在 HTML 4 中的默认样式）。“First”一词不在首行格式化内容中。

    <p>用户代理应表现得好像 <a href="#sel-first-line"><code>::first-line</code></a> 伪元素的虚构开始标签嵌套在最内部的封闭块级元素之内。（由于 CSS1 和 CSS2
        在此案例中未作说明，作者不应依赖此行为。）例如，以下段落的虚构标签序列为：

    <pre>
&lt;DIV&gt;
  &lt;P&gt;第一段&lt;/P&gt;
  &lt;P&gt;第二段&lt;/P&gt;
&lt;/DIV&gt;
</pre>

    <p>其虚构标签序列为：

    <pre>
&lt;DIV&gt;
  &lt;P>&lt;DIV::first-line>&lt;P::first-line>First paragraph&lt;/P::first-line>&lt;/DIV::first-line>&lt;/P&gt;
  &lt;P>&lt;P::first-line>Second paragraph&lt;/P::first-line>&lt;/P&gt;
&lt;/DIV&gt;
</pre>

    <p><a href="#sel-first-line"><code>::first-line</code></a> 伪元素类似于行内级元素，但有某些限制。以下 CSS 属性适用于 <a
            href="#sel-first-line"><code>::first-line</code></a> 伪元素：字体属性、颜色属性、背景属性、‘<code
            class=property>word-spacing</code>’、‘<code class=property>letter-spacing</code>’、‘<code
            class=property>text-decoration</code>’、‘<code class=property>text-transform</code>’、‘<code
            class=property>line-height</code>’。用户代理也可能应用其他属性。

    <p>在 CSS 继承过程中，发生在第一行上的子元素部分仅从 <a href="#sel-first-line"><code>::first-line</code></a> 伪元素继承适用于 <a
            href="#sel-first-line"><code>::first-line</code></a>
        伪元素的属性。对于所有其他属性，继承自首行伪元素的非伪元素父元素。（未出现在首行中的子元素部分总是从该子元素的父元素继承。）

    <h3 id=first-letter><span class=secno>7.2. </span>::first-letter 伪元素</h3>

    <p><dfn data-dfn-type=selector data-export=data-export id=first-letter0>::first-letter</dfn>
        伪元素表示元素的第一个字母，如果该字母之前没有任何其他内容（例如图像或行内表格）在其行上。::first-letter 伪元素可用于“首字母大写”和“首字下沉”，这是常见的排版效果。

    <p>标点符号（即在 Unicode 中定义的“开括号”（Ps）、“闭括号”（Pe）、“首括号”（Pi）、“尾括号”（Pf）和“其他”（Po）标点符号类中的字符）如果位于第一个字母之前或之后，应包含在内。<a
            href="#ref-UNICODE">[UNICODE]<!--{{!UNICODE}}--></a>

    <div class=figure>
        <p><img alt="引用符号应包含在首字母之前。" src=https://www.w3.org/TR/selectors-3/first-letter2.gif>
    </div>

    <p><a href="#first-letter0"><code>::first-letter</code></a> 也适用于第一个字母实际上是数字的情况，例如“67 million dollars is a lot of
        money.”中的“6”。

    <p class=note><strong>注意：</strong>在某些情况下，<a href="#first-letter0"><code>::first-letter</code></a>
        伪元素应包含不仅仅是行上的第一个非标点字符。例如，组合字符必须与其基字符保持在一起。此外，一些语言可能对如何处理某些字母组合有特定规则。用户代理对 <a
            href="#first-letter0"><code>::first-letter</code></a> 的定义应至少包括 UAX29
        定义的默认字形簇，并且可以根据需要包含更多内容。例如，在荷兰语中，如果字母组合“ij”出现在元素的开头，则两个字母都应被视为 <a
            href="#first-letter0"><code>::first-letter</code></a> 伪元素的一部分。<a
            href="#ref-UAX29">[UAX29]<!--{{UAX29}}--></a>

    <p>如果形成 <a href="#first-letter0"><code>::first-letter</code></a> 的字母不在同一元素中，例如 <code>&lt;p>‘&lt;em>T...</code>
        中的“‘T”，用户代理可以从其中一个元素、两个元素或根本不创建伪元素来创建 <a href="#first-letter0"><code>::first-letter</code></a> 伪元素。

    <p>同样，如果块的首字母不在行的开头（例如由于双向重排），则用户代理可能不会创建伪元素。

    <div class=example>
        <p>示例：

        <p><a id=overlapping-example>以下 CSS 和 HTML 示例</a>说明了重叠伪元素如何相互作用。每个 P 元素的首字母将为绿色，字体大小为 ‘<code
                class=css>24pt</code>’。其余的第一行格式化内容将为‘<code class=property>blue</code>’，而段落的其余部分将为‘<code
                class=property>red</code>’。

        <pre>p { color: red; font-size: 12pt }
p::first-letter { color: green; font-size: 200% }
p::first-line { color: blue }

&lt;P&gt;Some text that ends up on two lines&lt;/P&gt;</pre>

        <p>假设在“ends”一词之前会发生换行，这段落的<span class=index-inst id=fictional-tag-sequence
                title="fictional tag sequence">虚构标签序列</span>可能为：

        <pre>&lt;P&gt;
&lt;P::first-line&gt;
&lt;P::first-letter&gt;
S
&lt;/P::first-letter&gt;ome text that
&lt;/P::first-line&gt;
ends up on two lines
&lt;/P&gt;</pre>

        <p>请注意，<a href="#first-letter0"><code>::first-letter</code></a> 元素位于 <a
                href="#sel-first-line"><code>::first-line</code></a> 元素内部。<a
                href="#sel-first-line"><code>::first-line</code></a> 上设置的属性将被 <a
                href="#first-letter0"><code>::first-letter</code></a> 继承，但如果在 <a
                href="#first-letter0"><code>::first-letter</code></a> 上设置了相同的属性，则会被覆盖。
    </div>

    <p>首字母必须出现在<a href="#first-formatted-line">第一行格式化内容</a>中。例如，在此 HTML 片段中：<code>&lt;p&gt;&lt;br&gt;First...</code>
        第一行不包含任何字母，<a href="#first-letter0"><code>::first-letter</code></a> 不匹配任何内容（假设 <code>br</code> 在 HTML 4
        中的默认样式）。特别是，它不匹配“First”的“F”。

    <h4 id=application-in-css><span class=secno>7.2.1. </span>在 CSS 中的应用</h4>

    <p>在 CSS 中，<a href="#first-letter0"><code>::first-letter</code></a> 伪元素适用于块状容器，如块级元素、列表项、表格单元格、表格标题和行内块级元素。<span
            class=note><strong>注意：</strong>本规范的未来版本可能会允许该伪元素应用于更多的显示类型。</span>

    <p><a href="#first-letter0"><code>::first-letter</code></a> 伪元素可以与所有包含文本的元素一起使用，或与具有包含文本的后代的元素一起使用。用户代理应表现得好像
        ::first-letter 伪元素的虚构开始标签位于元素的第一个文本之前，即使该第一个文本位于后代元素中。

    <div class=example>
        <p>示例：

        <p>此 HTML 片段的虚构标签序列为：

        <pre>&lt;div&gt;
&lt;p&gt;第一个文本。</pre>

        <p>是：

        <pre>&lt;div&gt;
&lt;p&gt;&lt;div::first-letter&gt;&lt;p::first-letter&gt;第&lt;/...&gt;&lt;/...&gt;一个文本。</pre>
    </div>

    <p>在 CSS 中，表格单元格或行内块级元素的第一个字母不能是祖先元素的第一个字母。因此，在
        <code>&lt;DIV&gt;&lt;P STYLE="display: inline-block">Hello&lt;BR&gt;Goodbye&lt;/P&gt; etcetera&lt;/DIV&gt;</code>
        中，<code>DIV</code> 的第一个字母不是字母 “H”。事实上，<code>DIV</code> 没有第一个字母。

    <p>如果一个元素是列表项（‘<code class=css>display: list-item</code>’），则<a href="#first-letter0"><code>::first-letter</code></a>
        适用于标记之后主框中的第一个字母。用户代理可以忽略具有‘<code class=css>list-style-position: inside</code>’ 的列表项上的 <a
            href="#first-letter0"><code>::first-letter</code></a>。如果一个元素有<a href="#sel-before"><code>::before</code></a>
        或<a href="#sel-after"><code>::after</code></a>内容，<a href="#first-letter0"><code>::first-letter</code></a>
        适用于包括该内容的元素的第一个字母。

    <div class=example>
        <p>示例：

        <p>在规则 <code>p::before {content: "Note: "}</code> 之后，选择器 <code>p::first-letter</code> 匹配 “Note” 的 “N”。
    </div>

    <p>在 CSS 中，如果‘<code class=property>float</code>’ 属性为‘<code class=property>none</code>’，::first-line
        伪元素类似于行内级元素；否则，它类似于浮动元素。以下属性适用于 <a href="#first-letter0"><code>::first-letter</code></a> 伪元素：字体属性、‘<code
            class=property>text-decoration</code>’、‘<code class=property>text-transform</code>’、‘<code
            class=property>letter-spacing</code>’、‘<code class=property>word-spacing</code>’（在适用时）、‘<code
            class=property>line-height</code>’、‘<code class=property>float</code>’、‘<code
            class=property>vertical-align</code>’（仅当‘<code class=property>float</code>’为‘<code
            class=property>none</code>’时）、边距属性、填充属性、边框属性、颜色属性、背景属性。用户代理也可能应用其他属性。为了允许用户代理渲染排版上正确的首字下沉或首字大写，用户代理可以基于字母的形状选择行高、宽度和高度，不同于普通元素。

    <div class=example>
        <p>示例：

        <p>此 CSS 和 HTML 示例展示了首字大写的可能渲染。注意，‘<code class=property>line-height</code>’继承自 <a
                href="#first-letter0"><code>::first-letter</code></a> 伪元素是
            1.1，但在此示例中，用户代理计算了第一个字母的高度，因此它不会在前两行之间造成任何不必要的空白。还要注意，首字母的虚构开始标签位于<span>span</span>内，因此第一个字母的字体重量为正常，而不是<span>span</span>中的加粗：

        <pre>
p { line-height: 1.1 }
p::first-letter { font-size: 3em; font-weight: normal }
span { font-weight: bold }
...
&lt;p&gt;&lt;span&gt;Het hemelsche&lt;/span&gt; gerecht heeft zich ten lange lesten&lt;br&gt;
Erbarremt over my en mijn benaeuwde vesten&lt;br&gt;
En arme burgery, en op mijn volcx gebed&lt;br&gt;
En dagelix geschrey de bange stad ontzet.
</pre>

        <div class=figure>
            <p><img alt="图示 ::first-letter 伪元素" src=https://www.w3.org/TR/selectors-3/initial-cap.png>
        </div>
    </div>

    <div class=example>
        <p>以下 CSS 将使首字下沉跨越约两行：

        <pre>
&lt;!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN"&gt;
&lt;HTML&gt;
 &lt;HEAD&gt;
  &lt;TITLE&gt;Drop cap initial letter&lt;/TITLE&gt;
  &lt;STYLE type="text/css"&gt;
   P               { font-size: 12pt; line-height: 1.2 }
   P::first-letter { font-size: 200%; font-weight: bold; float: left }
   SPAN            { text-transform: uppercase }
  &lt;/STYLE&gt;
 &lt;/HEAD&gt;
 &lt;BODY&gt;
  &lt;P&gt;&lt;SPAN&gt;The first&lt;/SPAN&gt; few words of an article
    in The Economist.&lt;/P&gt;
 &lt;/BODY&gt;
&lt;/HTML&gt;
</pre>

        <p>此示例可能格式化如下：

        <div class=figure>
            <p><img alt="图示 ::first-letter 和 ::first-line 伪元素的组合效果"
                    src=https://www.w3.org/TR/selectors-3/first-letter.gif>
        </div>

        <p><span class=index-inst id=fictional-tag-sequence0 title="虚构标签序列">虚构标签序列</span>是：

        <pre>
&lt;P&gt;
&lt;SPAN&gt;
&lt;P::first-letter&gt;
T
&lt;/P::first-letter&gt;he first
&lt;/SPAN&gt;
few words of an article in the Economist.
&lt;/P&gt;
</pre>

        <p>请注意，<a href="#first-letter0"><code>::first-letter</code></a> 伪元素标签紧贴内容（即首字符），而 ::first-line
            伪元素的开始标签插入在块级元素的开始标签之后。
    </div>

    <p>为了实现传统的首字下沉格式，用户代理可以近似字体大小，例如对齐基线。此外，格式化时可以考虑字形轮廓。

    <h3 id=selection><span class=secno>7.3. </span>空白</h3>

    <p>本节故意留空。（本节之前定义了<code>::selection</code>伪元素。）

    <h3 id=gen-content><span class=secno>7.4. </span><code>::before</code> 和 <code>::after</code> 伪元素</h3>

    <p><dfn data-dfn-type=selector data-export=data-export id=sel-before>::before</dfn> 和 <dfn data-dfn-type=selector
            data-export=data-export id=sel-after>::after</dfn> 伪元素可用于描述元素内容之前或之后生成的内容。它们在 CSS 2.1 中进行了说明 <a
            href="#ref-CSS21">[CSS21]<!--{{!CSS21}}--></a>。

    <p>当<a href="#first-letter0"><code>::first-letter</code></a> 和 <a
            href="#sel-first-line"><code>::first-line</code></a> 伪元素应用于包含生成内容的元素时，它们应用于包括生成内容的元素的第一个字母或行。

    <h2 id=combinators><span class=secno>8. </span>组合器</h2>

    <h3 id=descendant-combinators><span class=secno>8.1. </span>后代组合器</h3>

    <p>有时，作者可能希望选择器描述文档树中另一个元素的后代元素（例如，“位于 <code>H1</code> 元素内的 <code>EM</code> 元素”）。后代组合器表达这种关系。后代组合器是分隔两个简单选择器序列的<a
            href="#whitespace">空白符</a>。形式为“<code>A B</code>”的选择器表示元素 <code>B</code> 是某个祖先元素 <code>A</code> 的任意后代。

    <div class=example>
        <p>示例：

        <p>例如，考虑以下选择器：

        <pre>h1 em</pre>

        <p>它表示 <code>em</code> 元素是 <code>h1</code> 元素的后代。这是对以下片段的正确且有效的部分描述：

        <pre>&lt;h1&gt;This &lt;span class="myclass"&gt;headline
is &lt;em&gt;very&lt;/em&gt; important&lt;/span&gt;&lt;/h1&gt;</pre>

        <p>以下选择器：

        <pre>div * p</pre>

        <p>表示 <code>p</code> 元素是 <code>div</code> 元素的孙辈或更远的后代。注意两侧的空白符不是通用选择器的一部分；空白符是一个组合器，表示 <code>div</code>
            必须是某个元素的祖先，而该元素必须是 <code>p</code> 的祖先。

        <p>以下选择器结合了后代组合器和<a href="#attribute-selectors">属性选择器</a>，表示一个元素（1）具有 <code>href</code> 属性，（2）位于 <code>p</code>
            内，且 <code>p</code> 本身位于 <code>div</code> 内：

        <pre>div p *[href]</pre>
    </div>

    <h3 id=child-combinators><span class=secno>8.2. </span>子组合器</h3>

    <p><dfn id=child-combinator>子组合器</dfn>描述了两个元素之间的子关系。子组合器由“尖括号符号”（U+003E，<code>&gt;</code>）字符组成，并分隔两个简单选择器序列。

    <div class=example>
        <p>示例：

        <p>以下选择器表示 <code>body</code> 的子元素 <code>p</code>：

        <pre>body &gt; p</pre>

        <p>以下示例结合了后代组合器和子组合器。

        <pre>div ol&gt;li p</pre>
        <!-- LEAVE THOSE SPACES OUT! see below -->
        <p>它表示一个 <code>p</code> 元素，该元素是 <code>li</code> 元素的后代；<code>li</code> 元素必须是 <code>ol</code>
            元素的子元素；<code>ol</code> 元素必须是 <code>div</code> 的后代。注意，"&gt;" 组合器周围的可选空白符已被省略。
    </div>

    <p>有关选择元素的第一个子元素的信息，请参见上面关于<code><a href="#structural-pseudos">:first-child</a></code>伪类的部分。

    <h3 id=sibling-combinators><span class=secno>8.3. </span>兄弟组合器</h3>

    <p>有两种不同的兄弟组合器：紧邻兄弟组合器和后续兄弟组合器。在这两种情况下，非元素节点（例如元素之间的文本）在考虑元素的相邻关系时会被忽略。

    <h4 id=adjacent-sibling-combinators><span class=secno>8.3.1. </span>紧邻兄弟组合器</h4>

    <p><dfn
            id=next-sibling-combinator>紧邻兄弟组合器</dfn>由“加号”（U+002B，<code>+</code>）字符组成，该字符分隔两个简单选择器序列。由这两个序列表示的元素在文档树中共享相同的父元素，并且第一个序列表示的元素紧邻第二个序列表示的元素之前。

    <div class=example>
        <p>示例：

        <p>以下选择器表示紧邻 <code>math</code> 元素之后的 <code>p</code> 元素：

        <pre>math + p</pre>

        <p>以下选择器在概念上与前一个示例中的选择器类似，只是它添加了一个属性选择器——它对 <code>h1</code> 元素添加了一个约束，即它必须具有<code>class="opener"</code>：

        <pre>h1.opener + h2</pre>
    </div>

    <h4 id=general-sibling-combinators><span class=secno>8.3.2. </span>后续兄弟组合器</h4>

    <p><dfn
            id=subsequent-sibling-combinator>后续兄弟组合器</dfn>由“波浪号”（U+007E，<code>~</code>）字符组成，该字符分隔两个简单选择器序列。由这两个序列表示的元素在文档树中共享相同的父元素，并且第一个序列表示的元素在第二个序列表示的元素之前（不一定是紧邻的）。

    <div class=example>
        <p>示例：

        <pre>h1 ~ pre</pre>

        <p>表示一个 <code>pre</code> 元素跟随在 <code>h1</code> 之后。它是以下片段的正确且有效的部分描述：

        <pre>&lt;h1&gt;Definition of the function a&lt;/h1&gt;
&lt;p&gt;Function a(x) has to be applied to all figures in the table.&lt;/p&gt;
&lt;pre&gt;function a(x) = 12x/13.5&lt;/pre&gt;</pre>
    </div>

    <h2 id=specificity><span class=secno>9. </span>计算选择器的特异性</h2>

    <p>选择器的特异性计算如下：

    <ul>
        <li>计算选择器中 ID 选择器的数量（= a）

        <li>计算选择器中类选择器、属性选择器和伪类的数量（= b）

        <li>计算选择器中类型选择器和伪元素的数量（= c）

        <li>忽略通用选择器
    </ul>

    <p>位于<a href="#negation">否定伪类</a>中的选择器像其他选择器一样计算，但否定本身不计为伪类。

    <p>将三个数字 a-b-c 连接在一起（在一个大基数的数字系统中）得出特异性。

    <div class=example>
        <p>示例：

        <pre>*               /* a=0 b=0 c=0 -&gt; 特异性 =   0 */
LI              /* a=0 b=0 c=1 -&gt; 特异性 =   1 */
UL LI           /* a=0 b=0 c=2 -&gt; 特异性 =   2 */
UL OL+LI        /* a=0 b=0 c=3 -&gt; 特异性 =   3 */
H1 + *[REL=up]  /* a=0 b=1 c=1 -&gt; 特异性 =  11 */
UL OL LI.red    /* a=0 b=1 c=3 -&gt; 特异性 =  13 */
LI.red.level    /* a=0 b=2 c=1 -&gt; 特异性 =  21 */
#x34y           /* a=1 b=0 c=0 -&gt; 特异性 = 100 */
#s12:not(FOO)   /* a=1 b=0 c=1 -&gt; 特异性 = 101 */
</pre>
    </div>

    <p class=note><strong>注意：</strong>允许相同简单选择器的重复出现，并且会增加特异性。

    <p class=note><strong>注意：</strong>HTML <code>style</code> 属性中指定的样式的特异性在 CSS 2.1 中有所描述。<a
            href="#ref-CSS21">[CSS21]<!--{{!CSS21}}--></a>.

    <h2 id=w3cselgrammar><span class=secno>10. </span>选择器的语法</h2>

    <h3 id=grammar><span class=secno>10.1. </span>语法</h3>

    <p>下面的语法定义了选择器的语法。它是全局LL(1)且可以是局部LL(2)的（但请注意，大多数UA不应直接使用它，因为它不表达解析约定）。该生成规则的格式已针对人工阅读进行了优化，并使用了一些超出Yacc的简写符号（参见 <a
            href="#ref-YACC">[YACC]<!--{{!YACC}}--></a>）：

    <ul>
        <li><b>*</b>: 0个或更多

        <li><b>+</b>: 1个或更多

        <li><b>?</b>: 0个或1个

        <li><b>|</b>: 分隔替代项

        <li><b>[ ]</b>: 分组
    </ul>

    <p>生成规则如下：

    <pre>selectors_group
  : selector [ COMMA S* selector ]*
  ;

selector
  : simple_selector_sequence [ combinator simple_selector_sequence ]*
  ;

combinator
  /* combinators can be surrounded by whitespace */
  : PLUS S* | GREATER S* | TILDE S* | S+
  ;

simple_selector_sequence
  : [ type_selector | universal ]
    [ HASH | class | attrib | pseudo | negation ]*
  | [ HASH | class | attrib | pseudo | negation ]+
  ;

type_selector
  : [ namespace_prefix ]? element_name
  ;

namespace_prefix
  : [ IDENT | '*' ]? '|'
  ;

element_name
  : IDENT
  ;

universal
  : [ namespace_prefix ]? '*'
  ;

class
  : '.' IDENT
  ;

attrib
  : '[' S* [ namespace_prefix ]? IDENT S*
        [ [ PREFIXMATCH |
            SUFFIXMATCH |
            SUBSTRINGMATCH |
            '=' |
            INCLUDES |
            DASHMATCH ] S* [ IDENT | STRING ] S*
        ]? ']'
  ;

pseudo
  /* '::' starts a pseudo-element, ':' a pseudo-class */
  /* Exceptions: :first-line, :first-letter, :before and :after. */
  /* Note that pseudo-elements are restricted to one per selector and */
  /* occur only in the last simple_selector_sequence. */
  : ':' ':'? [ IDENT | functional_pseudo ]
  ;

functional_pseudo
  : FUNCTION S* expression ')'
  ;

expression
  /* In CSS3, the expressions are identifiers, strings, */
  /* or of the form "an+b" */
  : [ [ PLUS | '-' | DIMENSION | NUMBER | STRING | IDENT ] S* ]+
  ;

negation
  : NOT S* negation_arg S* ')'
  ;

negation_arg
  : type_selector | universal | HASH | class | attrib | pseudo
  ;</pre>

    <h3 id=lex><span class=secno>10.2. </span>词法扫描器</h3>

    <p>以下是<a id=x3>标记生成器</a>，使用Flex（参见 <a href="#ref-FLEX">[FLEX]<!--{{!FLEX}}--></a>）表示法编写。标记生成器是不区分大小写的。

    <p>两个 "\377" 表示当前版本的Flex可以处理的最高字符编号（十进制255）。它们应被读取为 "\4177777"（十进制1114111），这是Unicode/ISO-10646中的最高可能码点。<a
            href="#ref-UNICODE">[UNICODE]<!--{{!UNICODE}}--></a>

    <pre>%option case-insensitive

ident     [-]?{nmstart}{nmchar}*
name      {nmchar}+
nmstart   [_a-z]|{nonascii}|{escape}
nonascii  [^\0-\177]
unicode   \\[0-9a-f]{1,6}(\r\n|[ \n\r\t\f])?
escape    {unicode}|\\[^\n\r\f0-9a-f]
nmchar    [_a-z0-9-]|{nonascii}|{escape}
num       [0-9]+|[0-9]*\.[0-9]+
string    {string1}|{string2}
string1   \"([^\n\r\f\\"]|\\{nl}|{nonascii}|{escape})*\"
string2   \'([^\n\r\f\\']|\\{nl}|{nonascii}|{escape})*\'
invalid   {invalid1}|{invalid2}
invalid1  \"([^\n\r\f\\"]|\\{nl}|{nonascii}|{escape})*
invalid2  \'([^\n\r\f\\']|\\{nl}|{nonascii}|{escape})*
nl        \n|\r\n|\r|\f
w         [ \t\r\n\f]*

D         d|\\0{0,4}(44|64)(\r\n|[ \t\r\n\f])?
E         e|\\0{0,4}(45|65)(\r\n|[ \t\r\n\f])?
N         n|\\0{0,4}(4e|6e)(\r\n|[ \t\r\n\f])?|\\n
O         o|\\0{0,4}(4f|6f)(\r\n|[ \t\r\n\f])?|\\o
T         t|\\0{0,4}(54|74)(\r\n|[ \t\r\n\f])?|\\t
V         v|\\0{0,4}(58|78)(\r\n|[ \t\r\n\f])?|\\v

%%

[ \t\r\n\f]+     return S;

"~="             return INCLUDES;
"|="             return DASHMATCH;
"^="             return PREFIXMATCH;
"$="             return SUFFIXMATCH;
"*="             return SUBSTRINGMATCH;
{ident}          return IDENT;
{string}         return STRING;
{ident}"("       return FUNCTION;
{num}            return NUMBER;
"#"{name}        return HASH;
{w}"+"           return PLUS;
{w}"&gt;"           return GREATER;
{w}","           return COMMA;
{w}"~"           return TILDE;
":"{N}{O}{T}"("  return NOT;
@{ident}         return ATKEYWORD;
{invalid}        return INVALID;
{num}%           return PERCENTAGE;
{num}{ident}     return DIMENSION;
"&lt;!--"           return CDO;
"--&gt;"            return CDC;

\/\*[^*]*\*+([^/*][^*]*\*+)*\/                    /* ignore comments */

.                return *yytext;</pre>

    <h2 id=profiling><span class=secno>11. </span>概要文件</h2>

    <p>每个使用选择器的规范必须定义它允许和排除的选择器子集，并描述该子集中所有组件的局部含义。

    <p>非规范性示例：

    <div class=profile>
        <table class=tprofile>
            <tbody>
                <tr>
                    <th class=title colspan=2>选择器概要文件

                <tr>
                    <th>规范

                    <td>CSS level 1

                <tr>
                    <th>接受

                    <td>类型选择器<br>
                        类选择器<br>
                        ID 选择器<br>
                        :link, :visited 和 :active 伪类<br>
                        后代组合器<br>
                        ::first-line 和 ::first-letter 伪元素

                <tr>
                    <th>排除

                    <td>
                        <p>通用选择器<br>
                            属性选择器<br>
                            :hover 和 :focus 伪类<br>
                            :target 伪类<br>
                            :lang() 伪类<br>
                            所有 UI 元素状态伪类<br>
                            所有结构性伪类<br>
                            否定伪类<br>
                            ::before 和 ::after 伪元素<br>
                            子组合器<br>
                            兄弟组合器

                        <p>命名空间

                <tr>
                    <th>额外限制

                    <td>每个简单选择器序列仅允许一个类选择器
        </table>
        <br>
        <br>

        <table class=tprofile>
            <tbody>
                <tr>
                    <th class=title colspan=2>选择器概要文件

                <tr>
                    <th>规范

                    <td>CSS level 2

                <tr>
                    <th>接受

                    <td>类型选择器<br>
                        通用选择器<br>
                        属性存在和值选择器<br>
                        类选择器<br>
                        ID 选择器<br>
                        :link, :visited, :active, :hover, :focus, :lang() 和 :first-child 伪类<br>
                        后代组合器<br>
                        子组合器<br>
                        下一个兄弟组合器<br>
                        ::first-line 和 ::first-letter 伪元素<br>
                        ::before 和 ::after 伪元素

                <tr>
                    <th>排除

                    <td>
                        <p>子串匹配属性选择器<br>
                            :target 伪类<br>
                            所有 UI 元素状态伪类<br>
                            除 :first-child 之外的所有结构性伪类<br>
                            否定伪类<br>
                            后续兄弟组合器

                        <p>命名空间

                <tr>
                    <th>额外限制

                    <td>允许每个简单选择器序列中多个类选择器（CSS1 限制）
        </table>

        <p>在 CSS 中，选择器表示模式匹配规则，用于确定哪些样式规则适用于文档树中的元素。

        <p>以下选择器（CSS level 2）将<b>匹配</b>在章节 1 标题 <code>h1</code> 内设置了 <code>name</code> 属性的所有锚点 <code>a</code>：

        <pre>h1 a[name]</pre>

        <p>所有附加到此类选择器的 CSS 声明都将应用于与其匹配的元素。
    </div>

    <div class=profile>
        <table class=tprofile>
            <tbody>
                <tr>
                    <th class=title colspan=2>选择器概要文件

                <tr>
                    <th>规范

                    <td>STTS 3

                <tr>
                    <th>接受

                    <td>
                        <p>类型选择器<br>
                            通用选择器<br>
                            属性选择器<br>
                            类选择器<br>
                            ID 选择器<br>
                            所有结构性伪类<br>
                            所有组合器

                        <p>命名空间

                <tr>
                    <th>排除

                    <td>不接受的伪类<br>
                        伪元素<br>

                <tr>
                    <th>额外限制

                    <td>某些选择器和组合器不允许在 STTS 声明右侧的片段描述中使用。
        </table>

        <p>选择器在 STTS 3 中可用于两种不同的方式：

        <ol>
            <li>与 CSS 选择机制等效的选择机制：附加到给定选择器的声明应用于与该选择器匹配的元素，

            <li>片段描述出现在声明右侧。
        </ol>
    </div>

    <h2 id=Conformance><span class=secno>12. </span>一致性与要求</h2>

    <p>本节仅定义了与当前规范的一致性。

    <p>由于特定设备的限制，用户代理无法实现本规范的一部分（例如，非交互式用户代理可能不会实现动态伪类，因为它们在没有交互性的情况下没有意义），这并不意味着不符合规范。

    <p>所有重用选择器的规范必须包含<a href="#profiling">概要文件</a>，列出它接受或排除的选择器子集，并描述它对当前规范添加的限制。

    <p>无效性是由解析错误引起的，例如未识别的标记或当前解析点不允许的标记。

    <p>用户代理必须遵守处理解析错误的规则：

    <ul>
        <li>包含<a href="#nsdecl">未声明命名空间前缀</a>的简单选择器是无效的

        <li>包含无效简单选择器、无效组合器或无效标记的选择器是无效的。

        <li>包含无效选择器的选择器组是无效的。
    </ul>

    <p>重用选择器的规范必须定义如何处理解析错误。（在 CSS 的情况下，将丢弃使用该选择器的整个规则。）

    <h2 id=Tests><span class=secno>13. </span>测试</h2>

    <p>本规范有<a
            href="https://test.csswg.org/harness/suite/selectors-3_dev/">一个测试套件</a>，允许用户代理验证其对规范的基本一致性。该测试套件并不声称是详尽无遗的，也不涵盖选择器的所有可能组合情况。

    <h2 id=ACKS><span class=secno>14. </span>致谢</h2>

    <p>CSS 工作组感谢多年来对本规范提出意见的所有人。

    <p>特别是，工作组想向 Donna McManus、Justin Baker、Joel Sklar 和 Molly Ives Brower 致以特别的谢意，他们对最后的草案进行了最终的编辑审查。工作组还要感谢 Adam
        Kuehn、Boris Zbarsky、David Perrell、Elliotte Harold、Matthew Raymond、Ruud Steltenpool、Patrick Garies、Anton Prowse 和
        W3C 国际化工作组的最后审查意见和友善的言辞。

    <h2 id=references><span class=secno>15. </span>参考文献</h2>

    <h3 id=normative-references><span class=secno>15.1. </span>规范性参考文献</h3>
    <!--begin-normative-->
    <!-- Sorted by label -->

    <dl class=bibliography><!---->

        <dt id=ref-CSS21>[CSS21]

        <dd>Bert Bos 等人。<a href="https://www.w3.org/TR/2011/REC-CSS2-20110607"><cite>层叠样式表第2级修订版（CSS 2.1）规范。</cite></a>
            2011年6月7日。W3C 推荐标准。URL: <a
                href="https://www.w3.org/TR/2011/REC-CSS2-20110607">http://www.w3.org/TR/2011/REC-CSS2-20110607</a>
        </dd>
        <!---->

        <dt id=ref-CSS3NAMESPACE>[CSS3NAMESPACE]

        <dd>Elika J. Etemad。<a href="https://www.w3.org/TR/2014/REC-css-namespaces-3-20140320/"><cite>CSS
                    命名空间模块第3级。</cite></a> 2011年9月29日。W3C 推荐标准。URL: <a
                href="https://www.w3.org/TR/2014/REC-css-namespaces-3-20140320/">http://www.w3.org/TR/2014/REC-css-namespaces-3-20140320/</a>
        </dd>
        <!---->

        <dt id=ref-FLEX>[FLEX]

        <dd><cite>Flex: 词法扫描生成器。</cite> 版本 2.3.7，ISBN 1882114213</dd>
        <!---->

        <dt id=ref-UNICODE>[UNICODE]

        <dd>The Unicode Consortium。<a
                href="http://www.unicode.org/standard/versions/enumeratedversions.html"><cite>Unicode 标准。</cite></a>
            2012年。定义自：Unicode 标准，版本 6.2.0（加利福尼亚州山景城：Unicode Consortium，2012年，ISBN 978-1-936213-07-8），并随着新版本的发布不时更新。URL:
            <a
                href="http://www.unicode.org/standard/versions/enumeratedversions.html">http://www.unicode.org/standard/versions/enumeratedversions.html</a>
        </dd>
        <!---->

        <dt id=ref-YACC>[YACC]

        <dd>S. C. Johnson。<cite>YACC - Yet another compiler compiler。</cite> 默里山。1975年。技术报告。</dd>
        <!---->
    </dl>
    <!--end-normative-->

    <h3 id=informative-references><span class=secno>15.2. </span>参考性文献</h3>
    <!--begin-informative-->
    <!-- Sorted by label -->

    <dl class=bibliography><!---->

        <dt id=ref-BCP47>[BCP47]

        <dd>A. Phillips; M. Davis。<a href="ftp://ftp.rfc-editor.org/in-notes/bcp/bcp47.txt"><cite>语言标识标签。</cite></a>
            2009年9月。47. BCP。当前由RFC 5646表示。URL: <a
                href="ftp://ftp.rfc-editor.org/in-notes/bcp/bcp47.txt">ftp://ftp.rfc-editor.org/in-notes/bcp/bcp47.txt</a>
        </dd>
        <!---->

        <dt id=ref-CSS1>[CSS1]

        <dd>Håkon Wium Lie; Bert Bos。<a
                href="https://www.w3.org/TR/2008/REC-CSS1-20080411"><cite>层叠样式表（CSS1）第1级规范。</cite></a> 2008年4月11日。W3C
            推荐标准。URL: <a
                href="https://www.w3.org/TR/2008/REC-CSS1-20080411">http://www.w3.org/TR/2008/REC-CSS1-20080411</a>
        </dd>
        <!---->

        <dt id=ref-DOM-LEVEL-3-CORE>[DOM-LEVEL-3-CORE]

        <dd>Gavin Nicol 等人。<a
                href="https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407"><cite>文档对象模型（DOM）第3级核心规范。</cite></a>
            2004年4月7日。W3C 推荐标准。URL: <a
                href="https://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407">http://www.w3.org/TR/2004/REC-DOM-Level-3-Core-20040407</a>
        </dd>
        <!---->

        <dt id=ref-HTML401>[HTML401]

        <dd>Dave Raggett; Arnaud Le Hors; Ian Jacobs。<a
                href="https://www.w3.org/TR/1999/REC-html401-19991224"><cite>HTML 4.01 规范。</cite></a> 1999年12月24日。W3C
            推荐标准。URL: <a
                href="https://www.w3.org/TR/1999/REC-html401-19991224">http://www.w3.org/TR/1999/REC-html401-19991224</a>
        </dd>
        <!---->

        <dt id=ref-HTML5>[HTML5]

        <dd>Ian Hickson 等人。<a href="https://www.w3.org/TR/2014/REC-html5-20141028/"><cite>HTML5。</cite></a>
            2014年10月28日。W3C 推荐标准。URL: <a
                href="https://www.w3.org/TR/2014/REC-html5-20141028/">http://www.w3.org/TR/2014/REC-html5-20141028/</a>
        </dd>
        <!---->

        <dt id=ref-MATHML3>[MATHML3]

        <dd>David Carlisle; Patrick Ion; Robert Miner。<a
                href="https://www.w3.org/TR/2014/REC-MathML3-20140410/"><cite>数学标记语言（MathML）版本3.0第2版。</cite></a>
            2014年4月10日。W3C 推荐标准。URL: <a
                href="https://www.w3.org/TR/2014/REC-MathML3-20140410/">http://www.w3.org/TR/2014/REC-MathML3-20140410/</a>
        </dd>
        <!---->

        <dt id=ref-STTS3>[STTS3]

        <dd>Daniel Glazman。<a href="https://www.w3.org/TR/NOTE-STTS3"><cite>简单树转换表3。</cite></a>
            法国电力公司。1998年11月11日。提交给W3C。URL: <a
                href="https://www.w3.org/TR/NOTE-STTS3">http://www.w3.org/TR/NOTE-STTS3</a>
        </dd>
        <!---->

        <dt id=ref-SVG11>[SVG11]

        <dd>Erik Dahlström 等人。<a
                href="https://www.w3.org/TR/2011/REC-SVG11-20110816/"><cite>可缩放矢量图形（SVG）1.1（第二版）。</cite></a>
            2011年8月16日。W3C 推荐标准。URL: <a
                href="https://www.w3.org/TR/2011/REC-SVG11-20110816/">http://www.w3.org/TR/2011/REC-SVG11-20110816/</a>
        </dd>
        <!---->

        <dt id=ref-UAX29>[UAX29]

        <dd>Mark Davis。<a href="http://www.unicode.org/reports/tr29/"><cite>Unicode 文本分段。</cite></a> 2012年9月12日。Unicode
            标准附录#29。URL: <a href="http://www.unicode.org/reports/tr29/">http://www.unicode.org/reports/tr29/</a>
        </dd>
        <!---->

        <dt id=ref-XML-NAMES>[XML-NAMES]

        <dd>Tim Bray 等人。<a href="https://www.w3.org/TR/2009/REC-xml-names-20091208/"><cite>XML中的命名空间（第三版）。</cite></a>
            2009年12月8日。W3C 推荐标准。URL: <a
                href="https://www.w3.org/TR/2009/REC-xml-names-20091208/">http://www.w3.org/TR/2009/REC-xml-names-20091208/</a>
        </dd>
        <!---->

        <dt id=ref-XML10>[XML10]

        <dd>C. M. Sperberg-McQueen 等人。<a
                href="https://www.w3.org/TR/2008/REC-xml-20081126/"><cite>可扩展标记语言（XML）1.0（第五版）。</cite></a>
            2008年11月26日。W3C 推荐标准。URL: <a
                href="https://www.w3.org/TR/2008/REC-xml-20081126/">http://www.w3.org/TR/2008/REC-xml-20081126/</a>
        </dd>
        <!---->
    </dl>
    <!--end-informative-->

    <h3 id=changes><span class=secno>15.3. </span>变更</h3>

    <p>自上一版推荐标准以来的实质性变更包括：

    <ul>
        <li>允许<a href="#structural-pseudos">结构伪类</a>匹配根元素。参见<a
                href="http://lists.w3.org/Archives/Public/www-style/2013Apr/0246.html">会议记录</a>和<a
                href="http://test.csswg.org/harness/details/selectors-3_dev/selector-structural-pseudo-root/">测试结果</a>，以及一个<a
                href="http://test.csswg.org/harness/test/selectors-3_dev/single/selector-structural-pseudo-root/format/html5/">测试用例</a>。
    </ul>

    <p role="navigation" id="back-to-top"><a href="#toc"><abbr title="Back to top">↑</abbr></a></p>


    <script src="//www.w3.org/scripts/TR/2016/fixup.js"></script>
    <script src="/dropdown.js"></script>